Project Code Summary
====================


==============================
File Path: App.tsx
==============================

import React, { useState } from 'react';
import Header from './components/Header';
import ChessBoard from './components/ChessBoard';
import ControlBar from './components/ControlBar';
import MoveListPanel from './components/MoveListPanel';
import CloudPanel from './components/CloudPanel';
import MainLayout from './components/MainLayout';
import AnalysisModal from './components/AnalysisModal';
import InfoModal from './components/InfoModal';
import BoardEditorModal from './components/BoardEditorModal';
import SettingsModal from './components/SettingsModal';
import ImportModal from './components/ImportModal';
import ExportModal from './components/ExportModal';
import GifExportModal from './components/GifExportModal';
import { MemorizationSetupModal, MemorizationReportModal } from './components/MemorizationModals';
import { X, List, Cloud, CheckCircle, AlertCircle, HelpCircle, Lightbulb, StopCircle, BookOpen } from 'lucide-react';
import { useMoveTree } from './hooks/useMoveTree';
import { Point, AnalysisResult, GameMetadata, AppSettings } from './types';
import { getChineseNotation, fenToBoard } from './lib/utils';

type TabView = 'none' | 'moves' | 'cloud';

const DEFAULT_SETTINGS: AppSettings = {
    enableSound: true,
    showPlayerNames: true,
    showVariationArrows: true,
    showCoords: true,
    animationSpeed: 300,
    boardSize: 'large'
};

const App: React.FC = () => {
  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);
  const [shouldAnimate, setShouldAnimate] = useState(true);

  const { 
    currentNode, rootNode, activePath, addMove, importGame, jumpToMove, 
    updateComment, batchUpdateComments, deleteCurrentMove, deleteNode, reorderChildren,
    linkMovesByFen, navigate, navigateVariation, jumpToStep, notification,
    closeNotification, confirmState, showConfirm, closeConfirm, setRootNode,
    memConfig, memErrors, memTotalSteps, memStartNodeId, getHint, showReport, startMemorization,
    stopMemorization, setShowReport
  } = useMoveTree(settings.enableSound);

  const [mobileTab, setMobileTab] = useState<TabView>('none');
  const [isFlipped, setIsFlipped] = useState(false);
  const [isMirrored, setIsMirrored] = useState(false);
  const [showAnalysis, setShowAnalysis] = useState(false);
  const [showEditor, setShowEditor] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showImport, setShowImport] = useState(false);
  const [showExport, setShowExport] = useState(false);
  const [showGifExport, setShowGifExport] = useState(false);
  const [showMemSetup, setShowMemSetup] = useState(false);
  const [flashCoord, setFlashCoord] = useState<Point | null>(null);
  const [hintMove, setHintMove] = useState<{from: Point, to: Point} | null>(null); // State for hint
  const [analysisResults, setAnalysisResults] = useState<AnalysisResult[]>([]);
  const [showInfoModal, setShowInfoModal] = useState(false);
  const [metadata, setMetadata] = useState<GameMetadata>({
      title: '', event: '', date: new Date().toISOString().split('T')[0],
      result: 'unknown', redName: '', blackName: ''
  });
  
  const [isCloudEnabled, setIsCloudEnabled] = useState(false);

  const handleRequestDelete = (msg: string) => showConfirm('確認刪除', msg, deleteCurrentMove);
  
  const handleRequestDeleteNode = (nodeId: string, msg: string) => showConfirm('確認刪除變著', msg, () => deleteNode(nodeId));

  const handleCloudMove = (coords: { from: Point, to: Point }) => {
     const board = currentNode.boardState;
     const piece = board[coords.from.r][coords.from.c];
     if (!piece || piece.color !== currentNode.turn) return;
     const targetPiece = board[coords.to.r][coords.to.c];
     const notation = getChineseNotation(board, { ...coords, piece, captured: targetPiece });
     const newBoard = board.map(row => [...row]);
     newBoard[coords.to.r][coords.to.c] = piece;
     newBoard[coords.from.r][coords.from.c] = null;
     setShouldAnimate(true);
     addMove({ ...coords, piece, captured: targetPiece, notation }, newBoard);
  };

  const handleEditorConfirm = (fen: string) => {
      try {
          const { board, turn } = fenToBoard(fen);
          setRootNode({
              id: 'root-' + Date.now(), parentId: null, move: null,
              boardState: board, children: [], comment: '',
              turn, selectedChildId: null, fen
          });
          setShowEditor(false);
      } catch (e) { alert("FEN 格式錯誤"); }
  };

  const handleHint = () => {
      const hint = getHint();
      if (hint) {
          setHintMove(hint);
          // Auto clear hint after 1.5 seconds
          setTimeout(() => setHintMove(null), 1500);
      }
  };

  const currentIndex = activePath.findIndex(n => n.id === currentNode.id);

  return (
    <>
      <MainLayout
        header={
          <Header 
            title={metadata.title}
            onOpenInfo={() => setShowInfoModal(true)} onOpenEdit={() => setShowEditor(true)}
            onOpenSettings={() => setShowSettings(true)} onOpenImport={() => setShowImport(true)}
            onOpenExport={() => setShowExport(true)} 
            onOpenGif={() => setShowGifExport(true)}
            onOpenMemorize={() => memConfig.active ? stopMemorization() : setShowMemSetup(true)}
            isMemorizing={memConfig.active}
          />
        }
        leftSidebar={
          <CloudPanel 
            currentFen={currentNode.fen} currentBoard={currentNode.boardState}
            onMoveClick={handleCloudMove} onOpenAnalysis={() => setShowAnalysis(true)}
            isEnabled={isCloudEnabled} onToggleEnabled={setIsCloudEnabled}
          />
        }
        rightSidebar={
          // HIDE sidebar content during memorization to prevent spoilers
          memConfig.active ? (
            <div className="flex flex-col h-full bg-zinc-900 items-center justify-center text-zinc-500 gap-4 p-8 text-center">
                <div className="w-16 h-16 rounded-full bg-amber-900/20 flex items-center justify-center animate-pulse">
                    <BookOpen size={32} className="text-amber-500" />
                </div>
                <div>
                    <h3 className="text-lg font-bold text-zinc-300">背譜模式進行中</h3>
                    <p className="text-sm mt-2">招法列表已隱藏，請專注於棋盤。</p>
                </div>
            </div>
          ) : (
            <MoveListPanel 
                movePath={activePath} currentNode={currentNode} rootNode={rootNode}
                onJumpToMove={n => { setShouldAnimate(false); jumpToMove(n); }}
                onUpdateComment={updateComment} onRequestDelete={handleRequestDelete} onRequestDeleteNode={handleRequestDeleteNode}
                onReorder={reorderChildren} onLinkFen={linkMovesByFen}
            />
          )
        }
        board={
          <ChessBoard 
            onMoveMade={(m, b) => {
                setShouldAnimate(true);
                const ok = addMove(m, b);
                if (!ok && memConfig.active) { setFlashCoord(m.to); setTimeout(() => setFlashCoord(null), 200); }
                return ok;
            }} 
            currentBoard={currentNode.boardState} currentTurn={currentNode.turn}
            lastMove={currentNode.move ? { from: currentNode.move.from, to: currentNode.move.to } : null}
            isFlipped={isFlipped} isMirrored={isMirrored}
            redName={metadata.redName} blackName={metadata.blackName}
            flashCoord={flashCoord} 
            hintMove={hintMove} // Pass hint move
            currentNode={currentNode}
            onNodeSelect={node => { setShouldAnimate(false); jumpToMove(node); }}
            settings={settings} shouldAnimate={shouldAnimate}
          />
        }
        controls={
          // Show different controls during memorization
          memConfig.active ? (
             <div className="flex gap-4 p-4 bg-zinc-900 border-t border-zinc-800 justify-center">
                 <button 
                    onClick={handleHint}
                    className="flex items-center gap-2 px-6 py-3 bg-yellow-600 hover:bg-yellow-500 text-white rounded-lg font-bold shadow-lg shadow-yellow-900/20 active:scale-95 transition-all"
                 >
                    <Lightbulb size={20} fill="currentColor" /> 提示
                 </button>
                 <button 
                    onClick={stopMemorization}
                    className="flex items-center gap-2 px-6 py-3 bg-red-600 hover:bg-red-500 text-white rounded-lg font-bold shadow-lg shadow-red-900/20 active:scale-95 transition-all"
                 >
                    <StopCircle size={20} /> 結束背譜
                 </button>
             </div>
          ) : (
            <ControlBar 
                onNavigate={dir => { setShouldAnimate(dir === 'next' || dir === 'end'); navigate(dir); }}
                onNavigateVariation={dir => { setShouldAnimate(false); navigateVariation(dir); }}
                onJumpToStep={s => { setShouldAnimate(false); jumpToStep(s); }}
                onFlip={() => setIsFlipped(!isFlipped)} onMirror={() => setIsMirrored(!isMirrored)}
                currentIndex={currentIndex !== -1 ? currentIndex : 0}
                totalSteps={activePath.length} disabled={memConfig.active}
            />
          )
        }
        mobileTabs={
          <div className="grid grid-cols-2 gap-2 h-full">
            <button onClick={() => setMobileTab('moves')} className="bg-zinc-800 border border-zinc-700 rounded-lg flex items-center justify-center gap-2 text-zinc-300 active:bg-zinc-700">
              <List size={18} /> <span className="text-sm font-bold">招法</span>
            </button>
            <button onClick={() => setMobileTab('cloud')} className="bg-zinc-800 border border-zinc-700 rounded-lg flex items-center justify-center gap-2 text-zinc-300 active:bg-zinc-700">
              <Cloud size={18} /> <span className="text-sm font-bold">雲庫</span>
            </button>
          </div>
        }
        mobileOverlay={
          mobileTab !== 'none' && (
            <div className="fixed inset-0 z-[60] bg-zinc-950 flex flex-col xl:hidden">
              <div className="flex items-center justify-between px-4 h-14 bg-zinc-900 border-b border-zinc-800 shrink-0">
                  <div className="flex gap-2 bg-zinc-800 p-1 rounded-lg">
                      <button onClick={() => setMobileTab('moves')} className={`px-4 py-1 rounded-md text-sm transition-all ${mobileTab === 'moves' ? 'bg-zinc-700 text-white' : 'text-zinc-400'}`}>招法</button>
                      <button onClick={() => setMobileTab('cloud')} className={`px-4 py-1 rounded-md text-sm transition-all ${mobileTab === 'cloud' ? 'bg-zinc-700 text-white' : 'text-zinc-400'}`}>雲庫</button>
                  </div>
                  <button onClick={() => setMobileTab('none')} className="w-8 h-8 flex items-center justify-center rounded-full bg-zinc-800 text-zinc-400"><X size={20} /></button>
              </div>
              <div className="flex-1 overflow-hidden relative bg-zinc-950">
                  {mobileTab === 'moves' ? (
                      <MoveListPanel movePath={activePath} currentNode={currentNode} rootNode={rootNode} onJumpToMove={n => { setShouldAnimate(false); jumpToMove(n); setMobileTab('none'); }} onUpdateComment={updateComment} onRequestDelete={handleRequestDelete} onRequestDeleteNode={handleRequestDeleteNode} onReorder={reorderChildren} onLinkFen={linkMovesByFen} />
                  ) : (
                      <CloudPanel 
                        currentFen={currentNode.fen} currentBoard={currentNode.boardState} 
                        onMoveClick={m => { handleCloudMove(m); setMobileTab('none'); }} 
                        onOpenAnalysis={() => { setShowAnalysis(true); setMobileTab('none'); }}
                        isEnabled={isCloudEnabled} onToggleEnabled={setIsCloudEnabled}
                      />
                  )}
              </div>
            </div>
          )
        }
      />

      {/* 彈窗組件 */}
      <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} settings={settings} onUpdate={setSettings} />
      <InfoModal isOpen={showInfoModal} onClose={() => setShowInfoModal(false)} metadata={metadata} onSave={setMetadata} />
      <BoardEditorModal isOpen={showEditor} onClose={() => setShowEditor(false)} initialFen={currentNode.fen} onConfirm={handleEditorConfirm} isFlippedInitial={isFlipped} />
      <ImportModal isOpen={showImport} onClose={() => setShowImport(false)} onImport={p => { importGame(p.fen, p.moves, p.root); if(p.header) setMetadata(m => ({...m, title: p.header.Title || m.title, redName: p.header.Red || m.redName, blackName: p.header.Black || m.blackName})); }} />
      <ExportModal isOpen={showExport} onClose={() => setShowExport(false)} rootNode={rootNode} metadata={metadata} />
      <MemorizationSetupModal isOpen={showMemSetup} onClose={() => setShowMemSetup(false)} onStart={startMemorization} />
      
      {/* Enhanced Report Modal with Full Path */}
      <MemorizationReportModal 
        isOpen={showReport} 
        onClose={() => setShowReport(false)} 
        errors={memErrors} 
        totalSteps={memTotalSteps}
        activePath={activePath}
        startNodeId={memStartNodeId}
        endNodeId={currentNode.id} // Pass current ID as End ID
      />
      
      <GifExportModal isOpen={showGifExport} onClose={() => setShowGifExport(false)} activePath={activePath} rootNode={rootNode} metadata={metadata} />
      {showAnalysis && <AnalysisModal onClose={() => setShowAnalysis(false)} movePath={activePath} onJumpToStep={s => { setShouldAnimate(false); jumpToStep(s); }} onBatchUpdateComments={batchUpdateComments} results={analysisResults} setResults={setAnalysisResults} />}

      {/* 通知與確認 */}
      {notification.show && (
          <div className="fixed inset-0 z-[110] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4">
              <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 max-w-sm w-full">
                  <div className="flex items-start gap-4 mb-4">
                      {notification.type === 'success' ? <CheckCircle className="text-green-500" size={28} /> : <AlertCircle className="text-red-500" size={28} />}
                      <div><h3 className="font-bold">{notification.title}</h3><p className="text-sm text-zinc-400">{notification.message}</p></div>
                  </div>
                  <button onClick={closeNotification} className="w-full py-2 bg-white text-zinc-950 font-bold rounded-lg">確定</button>
              </div>
          </div>
      )}
      {confirmState.show && (
          <div className="fixed inset-0 z-[110] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4">
              <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 max-w-sm w-full">
                  <div className="flex items-start gap-4 mb-4">
                      <HelpCircle className="text-amber-500" size={28} />
                      <div><h3 className="font-bold">{confirmState.title}</h3><p className="text-sm text-zinc-400">{confirmState.message}</p></div>
                  </div>
                  <div className="flex gap-3 mt-6">
                      <button onClick={closeConfirm} className="flex-1 py-2 bg-zinc-800 rounded-lg">取消</button>
                      <button onClick={() => { confirmState.onConfirm(); closeConfirm(); }} className="flex-1 py-2 bg-red-600 font-bold rounded-lg">確定刪除</button>
                  </div>
              </div>
          </div>
      )}
    </>
  );
};

export default App;


==============================
File Path: constants.ts
==============================
import { Piece } from './types';

export const PIECES: { red: Record<string, string>; black: Record<string, string> } = {
  red: { king: '帥', advisor: '仕', elephant: '相', horse: '傌', chariot: '俥', cannon: '炮', soldier: '兵' },
  black: { king: '將', advisor: '士', elephant: '象', horse: '馬', chariot: '車', cannon: '包', soldier: '卒' }
};

export const INITIAL_BOARD_SETUP = (): (Piece | null)[][] => {
    const board: (Piece | null)[][] = Array(10).fill(null).map(() => Array(9).fill(null));

    const setupSide = (row: number, color: 'red' | 'black', pieces: Record<string, string>) => {
        board[row][0] = { type: 'chariot', color, text: pieces.chariot };
        board[row][1] = { type: 'horse', color, text: pieces.horse };
        board[row][2] = { type: 'elephant', color, text: pieces.elephant };
        board[row][3] = { type: 'advisor', color, text: pieces.advisor };
        board[row][4] = { type: 'king', color, text: pieces.king };
        board[row][5] = { type: 'advisor', color, text: pieces.advisor };
        board[row][6] = { type: 'elephant', color, text: pieces.elephant };
        board[row][7] = { type: 'horse', color, text: pieces.horse };
        board[row][8] = { type: 'chariot', color, text: pieces.chariot };
    };

    // Black
    setupSide(0, 'black', PIECES.black);
    board[2][1] = { type: 'cannon', color: 'black', text: PIECES.black.cannon };
    board[2][7] = { type: 'cannon', color: 'black', text: PIECES.black.cannon };
    for(let i=0; i<9; i+=2) board[3][i] = { type: 'soldier', color: 'black', text: PIECES.black.soldier };

    // Red
    setupSide(9, 'red', PIECES.red);
    board[7][1] = { type: 'cannon', color: 'red', text: PIECES.red.cannon };
    board[7][7] = { type: 'cannon', color: 'red', text: PIECES.red.cannon };
    for(let i=0; i<9; i+=2) board[6][i] = { type: 'soldier', color: 'red', text: PIECES.red.soldier };

    return board;
};

==============================
File Path: gif.worker.js
==============================
// gif.worker.js 0.2.0 - https://github.com/jnordberg/gif.js
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);
//# sourceMappingURL=gif.worker.js.map

==============================
File Path: Header.tsx
==============================
import React from 'react';
import { Menu, Settings, Save, Edit, BookOpen, Info } from 'lucide-react';

interface HeaderProps {
    onOpenInfo?: () => void;
    onOpenEdit?: () => void;
}

const Header: React.FC<HeaderProps> = ({ onOpenInfo, onOpenEdit }) => {
    const itemClass = "flex items-center gap-2 px-3 py-2 text-sm font-medium text-zinc-300 hover:bg-zinc-800 hover:text-white rounded-md cursor-pointer transition-colors";

    return (
        <header className="w-full bg-zinc-900 border-b border-zinc-800 px-4 h-14 flex items-center justify-between shrink-0 z-50">
            <div className="flex items-center gap-2">
                <div className="w-8 h-8 bg-gradient-to-br from-amber-600 to-amber-800 rounded-lg flex items-center justify-center font-bold text-white shadow-inner">
                    弈
                </div>
                <span className="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-amber-200 to-amber-500 hidden sm:block">
                    Cloud Chess Note
                </span>
            </div>

            {/* Desktop Menu */}
            <nav className="hidden md:flex items-center gap-1">
                <button onClick={onOpenInfo} className={itemClass}><Info size={16}/> 資訊</button>
                <button onClick={onOpenEdit} className={itemClass}><Edit size={16}/> 編輯</button>
                <button className={itemClass}><BookOpen size={16}/> 背譜</button>
                <button className={itemClass}><Save size={16}/> 檔案</button>
                <button className={itemClass}><Settings size={16}/> 設定</button>
            </nav>

            {/* Mobile Menu Icon */}
            <button className="md:hidden p-2 text-zinc-400 hover:text-white">
                <Menu size={24} />
            </button>
        </header>
    );
};

export default Header;

==============================
File Path: index.html
==============================

<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Cloud Chess Note</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gif.js/0.2.0/gif.js"></script>
    <script>
      window.tailwind.config = {
        theme: {
          extend: {
            colors: {
              wood: {
                light: '#eecfa1',
                DEFAULT: '#d2b48c',
                dark: '#8b7355',
              },
              board: {
                bg: '#f0d9b5',
                line: '#5c4033',
              }
            }
          }
        }
      }
    </script>
    <style>
      :root { color-scheme: dark; }
      body {
        margin: 0;
        background-color: #09090b;
        color: #f4f4f5;
        font-family: "Microsoft JhengHei", system-ui, sans-serif;
        height: 100vh;
        overflow: hidden;
      }
      #root { height: 100%; display: flex; flex-direction: column; }
      ::-webkit-scrollbar { width: 6px; height: 6px; }
      ::-webkit-scrollbar-track { background: #18181b; }
      ::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 3px; }
      ::-webkit-scrollbar-thumb:hover { background: #52525b; }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.3.1",
    "react/": "https://esm.sh/react@18.3.1/",
    "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
    "react-dom": "https://esm.sh/react-dom@18.3.1",
    "lucide-react": "https://esm.sh/lucide-react@0.469.0?external=react",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/"
  }
}
</script>
<link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>
  <script type="module" src="/index.tsx"></script>
</body>
</html>


==============================
File Path: index.tsx
==============================

import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);


==============================
File Path: metadata.json
==============================
{
  "name": "Cloud Chess Note",
  "description": "A cross-platform Chinese Chess notation and analysis tool with a responsive design for both desktop and mobile.",
  "requestFramePermissions": []
}

==============================
File Path: package.json
==============================
{
  "name": "cloud-chess-note",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "18.3.1",
    "react-dom": "^19.2.3",
    "lucide-react": "0.469.0"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@vitejs/plugin-react": "^5.0.0",
    "typescript": "~5.8.2",
    "vite": "^6.2.0"
  }
}


==============================
File Path: project_all_code.txt
==============================
Project Code Summary
====================


==============================
File Path: App.tsx
==============================

import React, { useState } from 'react';
import Header from './components/Header';
import ChessBoard from './components/ChessBoard';
import ControlBar from './components/ControlBar';
import MoveListPanel from './components/MoveListPanel';
import CloudPanel from './components/CloudPanel';
import MainLayout from './components/MainLayout';
import AnalysisModal from './components/AnalysisModal';
import InfoModal from './components/InfoModal';
import BoardEditorModal from './components/BoardEditorModal';
import SettingsModal from './components/SettingsModal';
import ImportModal from './components/ImportModal';
import ExportModal from './components/ExportModal';
import GifExportModal from './components/GifExportModal';
import { MemorizationSetupModal, MemorizationReportModal } from './components/MemorizationModals';
import { X, List, Cloud, CheckCircle, AlertCircle, HelpCircle, Lightbulb, StopCircle, BookOpen } from 'lucide-react';
import { useMoveTree } from './hooks/useMoveTree';
import { Point, AnalysisResult, GameMetadata, AppSettings } from './types';
import { getChineseNotation, fenToBoard } from './lib/utils';

type TabView = 'none' | 'moves' | 'cloud';

const DEFAULT_SETTINGS: AppSettings = {
    enableSound: true,
    showPlayerNames: true,
    showVariationArrows: true,
    showCoords: true,
    animationSpeed: 300,
    boardSize: 'large'
};

const App: React.FC = () => {
  const [settings, setSettings] = useState<AppSettings>(DEFAULT_SETTINGS);
  const [shouldAnimate, setShouldAnimate] = useState(true);

  const { 
    currentNode, rootNode, activePath, addMove, importGame, jumpToMove, 
    updateComment, batchUpdateComments, deleteCurrentMove, deleteNode, reorderChildren,
    linkMovesByFen, navigate, navigateVariation, jumpToStep, notification,
    closeNotification, confirmState, showConfirm, closeConfirm, setRootNode,
    memConfig, memErrors, memTotalSteps, memStartNodeId, getHint, showReport, startMemorization,
    stopMemorization, setShowReport
  } = useMoveTree(settings.enableSound);

  const [mobileTab, setMobileTab] = useState<TabView>('none');
  const [isFlipped, setIsFlipped] = useState(false);
  const [isMirrored, setIsMirrored] = useState(false);
  const [showAnalysis, setShowAnalysis] = useState(false);
  const [showEditor, setShowEditor] = useState(false);
  const [showSettings, setShowSettings] = useState(false);
  const [showImport, setShowImport] = useState(false);
  const [showExport, setShowExport] = useState(false);
  const [showGifExport, setShowGifExport] = useState(false);
  const [showMemSetup, setShowMemSetup] = useState(false);
  const [flashCoord, setFlashCoord] = useState<Point | null>(null);
  const [hintMove, setHintMove] = useState<{from: Point, to: Point} | null>(null); // State for hint
  const [analysisResults, setAnalysisResults] = useState<AnalysisResult[]>([]);
  const [showInfoModal, setShowInfoModal] = useState(false);
  const [metadata, setMetadata] = useState<GameMetadata>({
      title: '', event: '', date: new Date().toISOString().split('T')[0],
      result: 'unknown', redName: '', blackName: ''
  });
  
  const [isCloudEnabled, setIsCloudEnabled] = useState(false);

  const handleRequestDelete = (msg: string) => showConfirm('確認刪除', msg, deleteCurrentMove);
  
  const handleRequestDeleteNode = (nodeId: string, msg: string) => showConfirm('確認刪除變著', msg, () => deleteNode(nodeId));

  const handleCloudMove = (coords: { from: Point, to: Point }) => {
     const board = currentNode.boardState;
     const piece = board[coords.from.r][coords.from.c];
     if (!piece || piece.color !== currentNode.turn) return;
     const targetPiece = board[coords.to.r][coords.to.c];
     const notation = getChineseNotation(board, { ...coords, piece, captured: targetPiece });
     const newBoard = board.map(row => [...row]);
     newBoard[coords.to.r][coords.to.c] = piece;
     newBoard[coords.from.r][coords.from.c] = null;
     setShouldAnimate(true);
     addMove({ ...coords, piece, captured: targetPiece, notation }, newBoard);
  };

  const handleEditorConfirm = (fen: string) => {
      try {
          const { board, turn } = fenToBoard(fen);
          setRootNode({
              id: 'root-' + Date.now(), parentId: null, move: null,
              boardState: board, children: [], comment: '',
              turn, selectedChildId: null, fen
          });
          setShowEditor(false);
      } catch (e) { alert("FEN 格式錯誤"); }
  };

  const handleHint = () => {
      const hint = getHint();
      if (hint) {
          setHintMove(hint);
          // Auto clear hint after 1.5 seconds
          setTimeout(() => setHintMove(null), 1500);
      }
  };

  const currentIndex = activePath.findIndex(n => n.id === currentNode.id);

  return (
    <>
      <MainLayout
        header={
          <Header 
            title={metadata.title}
            onOpenInfo={() => setShowInfoModal(true)} onOpenEdit={() => setShowEditor(true)}
            onOpenSettings={() => setShowSettings(true)} onOpenImport={() => setShowImport(true)}
            onOpenExport={() => setShowExport(true)} 
            onOpenGif={() => setShowGifExport(true)}
            onOpenMemorize={() => memConfig.active ? stopMemorization() : setShowMemSetup(true)}
            isMemorizing={memConfig.active}
          />
        }
        leftSidebar={
          <CloudPanel 
            currentFen={currentNode.fen} currentBoard={currentNode.boardState}
            onMoveClick={handleCloudMove} onOpenAnalysis={() => setShowAnalysis(true)}
            isEnabled={isCloudEnabled} onToggleEnabled={setIsCloudEnabled}
          />
        }
        rightSidebar={
          // HIDE sidebar content during memorization to prevent spoilers
          memConfig.active ? (
            <div className="flex flex-col h-full bg-zinc-900 items-center justify-center text-zinc-500 gap-4 p-8 text-center">
                <div className="w-16 h-16 rounded-full bg-amber-900/20 flex items-center justify-center animate-pulse">
                    <BookOpen size={32} className="text-amber-500" />
                </div>
                <div>
                    <h3 className="text-lg font-bold text-zinc-300">背譜模式進行中</h3>
                    <p className="text-sm mt-2">招法列表已隱藏，請專注於棋盤。</p>
                </div>
            </div>
          ) : (
            <MoveListPanel 
                movePath={activePath} currentNode={currentNode} rootNode={rootNode}
                onJumpToMove={n => { setShouldAnimate(false); jumpToMove(n); }}
                onUpdateComment={updateComment} onRequestDelete={handleRequestDelete} onRequestDeleteNode={handleRequestDeleteNode}
                onReorder={reorderChildren} onLinkFen={linkMovesByFen}
            />
          )
        }
        board={
          <ChessBoard 
            onMoveMade={(m, b) => {
                setShouldAnimate(true);
                const ok = addMove(m, b);
                if (!ok && memConfig.active) { setFlashCoord(m.to); setTimeout(() => setFlashCoord(null), 200); }
                return ok;
            }} 
            currentBoard={currentNode.boardState} currentTurn={currentNode.turn}
            lastMove={currentNode.move ? { from: currentNode.move.from, to: currentNode.move.to } : null}
            isFlipped={isFlipped} isMirrored={isMirrored}
            redName={metadata.redName} blackName={metadata.blackName}
            flashCoord={flashCoord} 
            hintMove={hintMove} // Pass hint move
            currentNode={currentNode}
            onNodeSelect={node => { setShouldAnimate(false); jumpToMove(node); }}
            settings={settings} shouldAnimate={shouldAnimate}
          />
        }
        controls={
          // Show different controls during memorization
          memConfig.active ? (
             <div className="flex gap-4 p-4 bg-zinc-900 border-t border-zinc-800 justify-center">
                 <button 
                    onClick={handleHint}
                    className="flex items-center gap-2 px-6 py-3 bg-yellow-600 hover:bg-yellow-500 text-white rounded-lg font-bold shadow-lg shadow-yellow-900/20 active:scale-95 transition-all"
                 >
                    <Lightbulb size={20} fill="currentColor" /> 提示
                 </button>
                 <button 
                    onClick={stopMemorization}
                    className="flex items-center gap-2 px-6 py-3 bg-red-600 hover:bg-red-500 text-white rounded-lg font-bold shadow-lg shadow-red-900/20 active:scale-95 transition-all"
                 >
                    <StopCircle size={20} /> 結束背譜
                 </button>
             </div>
          ) : (
            <ControlBar 
                onNavigate={dir => { setShouldAnimate(dir === 'next' || dir === 'end'); navigate(dir); }}
                onNavigateVariation={dir => { setShouldAnimate(false); navigateVariation(dir); }}
                onJumpToStep={s => { setShouldAnimate(false); jumpToStep(s); }}
                onFlip={() => setIsFlipped(!isFlipped)} onMirror={() => setIsMirrored(!isMirrored)}
                currentIndex={currentIndex !== -1 ? currentIndex : 0}
                totalSteps={activePath.length} disabled={memConfig.active}
            />
          )
        }
        mobileTabs={
          <div className="grid grid-cols-2 gap-2 h-full">
            <button onClick={() => setMobileTab('moves')} className="bg-zinc-800 border border-zinc-700 rounded-lg flex items-center justify-center gap-2 text-zinc-300 active:bg-zinc-700">
              <List size={18} /> <span className="text-sm font-bold">招法</span>
            </button>
            <button onClick={() => setMobileTab('cloud')} className="bg-zinc-800 border border-zinc-700 rounded-lg flex items-center justify-center gap-2 text-zinc-300 active:bg-zinc-700">
              <Cloud size={18} /> <span className="text-sm font-bold">雲庫</span>
            </button>
          </div>
        }
        mobileOverlay={
          mobileTab !== 'none' && (
            <div className="fixed inset-0 z-[60] bg-zinc-950 flex flex-col xl:hidden">
              <div className="flex items-center justify-between px-4 h-14 bg-zinc-900 border-b border-zinc-800 shrink-0">
                  <div className="flex gap-2 bg-zinc-800 p-1 rounded-lg">
                      <button onClick={() => setMobileTab('moves')} className={`px-4 py-1 rounded-md text-sm transition-all ${mobileTab === 'moves' ? 'bg-zinc-700 text-white' : 'text-zinc-400'}`}>招法</button>
                      <button onClick={() => setMobileTab('cloud')} className={`px-4 py-1 rounded-md text-sm transition-all ${mobileTab === 'cloud' ? 'bg-zinc-700 text-white' : 'text-zinc-400'}`}>雲庫</button>
                  </div>
                  <button onClick={() => setMobileTab('none')} className="w-8 h-8 flex items-center justify-center rounded-full bg-zinc-800 text-zinc-400"><X size={20} /></button>
              </div>
              <div className="flex-1 overflow-hidden relative bg-zinc-950">
                  {mobileTab === 'moves' ? (
                      <MoveListPanel movePath={activePath} currentNode={currentNode} rootNode={rootNode} onJumpToMove={n => { setShouldAnimate(false); jumpToMove(n); setMobileTab('none'); }} onUpdateComment={updateComment} onRequestDelete={handleRequestDelete} onRequestDeleteNode={handleRequestDeleteNode} onReorder={reorderChildren} onLinkFen={linkMovesByFen} />
                  ) : (
                      <CloudPanel 
                        currentFen={currentNode.fen} currentBoard={currentNode.boardState} 
                        onMoveClick={m => { handleCloudMove(m); setMobileTab('none'); }} 
                        onOpenAnalysis={() => { setShowAnalysis(true); setMobileTab('none'); }}
                        isEnabled={isCloudEnabled} onToggleEnabled={setIsCloudEnabled}
                      />
                  )}
              </div>
            </div>
          )
        }
      />

      {/* 彈窗組件 */}
      <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} settings={settings} onUpdate={setSettings} />
      <InfoModal isOpen={showInfoModal} onClose={() => setShowInfoModal(false)} metadata={metadata} onSave={setMetadata} />
      <BoardEditorModal isOpen={showEditor} onClose={() => setShowEditor(false)} initialFen={currentNode.fen} onConfirm={handleEditorConfirm} isFlippedInitial={isFlipped} />
      <ImportModal isOpen={showImport} onClose={() => setShowImport(false)} onImport={p => { importGame(p.fen, p.moves, p.root); if(p.header) setMetadata(m => ({...m, title: p.header.Title || m.title, redName: p.header.Red || m.redName, blackName: p.header.Black || m.blackName})); }} />
      <ExportModal isOpen={showExport} onClose={() => setShowExport(false)} rootNode={rootNode} metadata={metadata} />
      <MemorizationSetupModal isOpen={showMemSetup} onClose={() => setShowMemSetup(false)} onStart={startMemorization} />
      
      {/* Enhanced Report Modal with Full Path */}
      <MemorizationReportModal 
        isOpen={showReport} 
        onClose={() => setShowReport(false)} 
        errors={memErrors} 
        totalSteps={memTotalSteps}
        activePath={activePath}
        startNodeId={memStartNodeId}
        endNodeId={currentNode.id} // Pass current ID as End ID
      />
      
      <GifExportModal isOpen={showGifExport} onClose={() => setShowGifExport(false)} activePath={activePath} rootNode={rootNode} metadata={metadata} />
      {showAnalysis && <AnalysisModal onClose={() => setShowAnalysis(false)} movePath={activePath} onJumpToStep={s => { setShouldAnimate(false); jumpToStep(s); }} onBatchUpdateComments={batchUpdateComments} results={analysisResults} setResults={setAnalysisResults} />}

      {/* 通知與確認 */}
      {notification.show && (
          <div className="fixed inset-0 z-[110] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4">
              <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 max-w-sm w-full">
                  <div className="flex items-start gap-4 mb-4">
                      {notification.type === 'success' ? <CheckCircle className="text-green-500" size={28} /> : <AlertCircle className="text-red-500" size={28} />}
                      <div><h3 className="font-bold">{notification.title}</h3><p className="text-sm text-zinc-400">{notification.message}</p></div>
                  </div>
                  <button onClick={closeNotification} className="w-full py-2 bg-white text-zinc-950 font-bold rounded-lg">確定</button>
              </div>
          </div>
      )}
      {confirmState.show && (
          <div className="fixed inset-0 z-[110] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4">
              <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-6 max-w-sm w-full">
                  <div className="flex items-start gap-4 mb-4">
                      <HelpCircle className="text-amber-500" size={28} />
                      <div><h3 className="font-bold">{confirmState.title}</h3><p className="text-sm text-zinc-400">{confirmState.message}</p></div>
                  </div>
                  <div className="flex gap-3 mt-6">
                      <button onClick={closeConfirm} className="flex-1 py-2 bg-zinc-800 rounded-lg">取消</button>
                      <button onClick={() => { confirmState.onConfirm(); closeConfirm(); }} className="flex-1 py-2 bg-red-600 font-bold rounded-lg">確定刪除</button>
                  </div>
              </div>
          </div>
      )}
    </>
  );
};

export default App;


==============================
File Path: constants.ts
==============================
import { Piece } from './types';

export const PIECES: { red: Record<string, string>; black: Record<string, string> } = {
  red: { king: '帥', advisor: '仕', elephant: '相', horse: '傌', chariot: '俥', cannon: '炮', soldier: '兵' },
  black: { king: '將', advisor: '士', elephant: '象', horse: '馬', chariot: '車', cannon: '包', soldier: '卒' }
};

export const INITIAL_BOARD_SETUP = (): (Piece | null)[][] => {
    const board: (Piece | null)[][] = Array(10).fill(null).map(() => Array(9).fill(null));

    const setupSide = (row: number, color: 'red' | 'black', pieces: Record<string, string>) => {
        board[row][0] = { type: 'chariot', color, text: pieces.chariot };
        board[row][1] = { type: 'horse', color, text: pieces.horse };
        board[row][2] = { type: 'elephant', color, text: pieces.elephant };
        board[row][3] = { type: 'advisor', color, text: pieces.advisor };
        board[row][4] = { type: 'king', color, text: pieces.king };
        board[row][5] = { type: 'advisor', color, text: pieces.advisor };
        board[row][6] = { type: 'elephant', color, text: pieces.elephant };
        board[row][7] = { type: 'horse', color, text: pieces.horse };
        board[row][8] = { type: 'chariot', color, text: pieces.chariot };
    };

    // Black
    setupSide(0, 'black', PIECES.black);
    board[2][1] = { type: 'cannon', color: 'black', text: PIECES.black.cannon };
    board[2][7] = { type: 'cannon', color: 'black', text: PIECES.black.cannon };
    for(let i=0; i<9; i+=2) board[3][i] = { type: 'soldier', color: 'black', text: PIECES.black.soldier };

    // Red
    setupSide(9, 'red', PIECES.red);
    board[7][1] = { type: 'cannon', color: 'red', text: PIECES.red.cannon };
    board[7][7] = { type: 'cannon', color: 'red', text: PIECES.red.cannon };
    for(let i=0; i<9; i+=2) board[6][i] = { type: 'soldier', color: 'red', text: PIECES.red.soldier };

    return board;
};

==============================
File Path: gif.worker.js
==============================
// gif.worker.js 0.2.0 - https://github.com/jnordberg/gif.js
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);
//# sourceMappingURL=gif.worker.js.map

==============================
File Path: README.md
==============================
<div align="center">
<img width="1200" height="475" alt="GHBanner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
</div>

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/drive/1RZ1XP8bm5GuVOE6C_WHGk77av8rMKKau

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`


==============================
File Path: tsconfig.json
==============================
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}

==============================
File Path: types.ts
==============================

export type PieceColor = 'red' | 'black';
export type PieceType = 'king' | 'advisor' | 'elephant' | 'horse' | 'chariot' | 'cannon' | 'soldier';

export interface Piece {
  type: PieceType;
  color: PieceColor;
  text: string;
}

export interface Point {
  r: number;
  c: number;
}

export interface Move {
  from: Point;
  to: Point;
  piece: Piece;
  captured?: Piece | null;
  notation: string; // e.g., "炮二平五"
}

export interface GameState {
  board: (Piece | null)[][];
  turn: PieceColor;
  moves: Move[];
  selectedPiece: Point | null;
  lastMove: { from: Point; to: Point } | null;
}

// Tree Structure for Variations
export interface MoveNode {
    id: string;
    parentId: string | null;
    move: Move | null; // Null for root node
    boardState: (Piece | null)[][]; // Snapshot of the board after this move
    children: MoveNode[];
    comment: string;
    turn: PieceColor; // Whose turn is it AFTER this move?
    selectedChildId?: string | null; // The preferred child to follow for the "main line" view
    fen: string; // Forsyth–Edwards Notation of the current state
    
    // DhtmlXQ Support
    stepIndex?: number; // 1-based ply index
    ownerId?: number; // Variation ID for export
}

export interface CloudMove {
    move: string; // UCCI format
    score: number;
    rank: number;
    winrate: number;
    note: string;
}

export interface AnalysisResult {
    nodeId: string;
    moveIndex: number; // 1-based index (Round number * 2 - 1 or 0)
    moveNotation: string;
    fen: string;
    score: number | null; // Absolute score (Red perspective)
    deviation: number; // Loss compared to best move
    isRedTurn: boolean;
    bestMove: string; // Notation of the best move
    bestScore: number;
    quality: 'good' | 'inaccuracy' | 'mistake' | 'blunder'; // 正常 | 緩著 | 失著 | 錯著
}

export interface GameMetadata {
    title: string;
    event: string;
    date: string;
    result: 'unknown' | 'red' | 'black' | 'draw';
    redName: string;
    blackName: string;
}

// Memorization Types
export interface MemorizationConfig {
    active: boolean;
    side: 'red' | 'black' | 'both';
    mode: 'main' | 'random';
    randomRange: string; // e.g. "A-C" or empty for all
}

export interface MemorizationError {
    round: number;
    nodeId: string;
    correctNotations: string[];
    count: number;
}

// Settings
export interface AppSettings {
    enableSound: boolean;
    showPlayerNames: boolean;
    showVariationArrows: boolean;
    showCoords: boolean; // Extra suggestion
    animationSpeed: number; // in ms, default 300
    boardSize: 'small' | 'medium' | 'large';
}


==============================
File Path: utils.ts
==============================
// This file is deprecated. Please import from 'lib/utils' instead.
export {};

==============================
File Path: vite.config.ts
==============================
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig(({ mode }) => {
    const env = loadEnv(mode, '.', '');
    return {
      server: {
        port: 3000,
        host: '0.0.0.0',
      },
      plugins: [react()],
      define: {
        'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY),
        'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY)
      },
      resolve: {
        alias: {
          '@': path.resolve(__dirname, '.'),
        }
      }
    };
});


==============================
File Path: components\AnalysisModal.tsx
==============================

import React, { useState, useRef, useEffect } from 'react';
import { X, Play, Edit3, AlertTriangle, Activity } from 'lucide-react';
import { MoveNode, AnalysisResult } from '../types';
import { fetchCloudBookData, ucciToCoords, getChineseNotation } from '../lib/utils';

interface AnalysisModalProps {
    onClose: () => void;
    movePath: MoveNode[]; // The full active path
    onJumpToStep: (index: number) => void;
    onBatchUpdateComments: (updates: {id: string, text: string}[]) => void;
    results: AnalysisResult[];
    setResults: (results: AnalysisResult[]) => void;
}

const AnalysisModal: React.FC<AnalysisModalProps> = ({ 
    onClose, 
    movePath, 
    onJumpToStep, 
    onBatchUpdateComments,
    results,
    setResults
}) => {
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [progress, setProgress] = useState(0);
    const [hoverIndex, setHoverIndex] = useState<number | null>(null);
    const [selectedIndex, setSelectedIndex] = useState<number | null>(null); 
    const abortControllerRef = useRef<AbortController | null>(null);

    // If we have existing results, assume progress is complete or use previous length
    useEffect(() => {
        if (results.length > 0 && !isAnalyzing) {
            setProgress(100);
        }
    }, [results.length]);

    const startAnalysis = async () => {
        setIsAnalyzing(true);
        setResults([]);
        setSelectedIndex(null);
        setProgress(0);
        abortControllerRef.current = new AbortController();

        const newResults: AnalysisResult[] = [];
        const totalSteps = movePath.length - 1; 

        for (let i = 0; i < totalSteps; i++) {
            if (abortControllerRef.current.signal.aborted) break;

            const currentNode = movePath[i];
            const nextNode = movePath[i+1];
            
            const cloudMoves = await fetchCloudBookData(currentNode.fen);
            
            let actualMoveUcci = '';
            if (nextNode.move) {
                 const f = nextNode.move.from;
                 const t = nextNode.move.to;
                 const files = ['a','b','c','d','e','f','g','h','i'];
                 const ucciFrom = `${files[f.c]}${9 - f.r}`;
                 const ucciTo = `${files[t.c]}${9 - t.r}`;
                 actualMoveUcci = ucciFrom + ucciTo;
            }

            const playedCloudMove = cloudMoves.find(m => m.move === actualMoveUcci);
            const bestCloudMove = cloudMoves.length > 0 ? cloudMoves[0] : null;

            let deviation = 0;
            let finalScore = null; 
            let bestScore = 0;
            let bestMoveNotation = "";

            const isRedTurn = currentNode.turn === 'red';

            if (bestCloudMove) {
                const bestCoords = ucciToCoords(bestCloudMove.move);
                if (bestCoords) {
                    const piece = currentNode.boardState[bestCoords.from.r][bestCoords.from.c];
                    const target = currentNode.boardState[bestCoords.to.r][bestCoords.to.c];
                    if (piece) {
                        bestMoveNotation = getChineseNotation(currentNode.boardState, { from: bestCoords.from, to: bestCoords.to, piece, captured: target });
                    } else {
                        bestMoveNotation = bestCloudMove.move;
                    }
                }
                bestScore = bestCloudMove.score;
            }

            if (playedCloudMove) {
                const rawScore = playedCloudMove.score;
                const rawBestScore = bestCloudMove?.score || 0;

                if (isRedTurn) {
                    finalScore = rawScore;
                } else {
                    finalScore = -rawScore;
                    bestScore = -rawBestScore; 
                }

                deviation = Math.abs((bestCloudMove?.score || 0) - rawScore);

            } else if (bestCloudMove) {
                deviation = 250; 
                const estimatedRaw = (bestCloudMove.score || 0) - 250; 
                finalScore = isRedTurn ? estimatedRaw : -estimatedRaw;
            }

            let quality: AnalysisResult['quality'] = 'good';
            if (deviation > 500) quality = 'blunder'; 
            else if (deviation > 200) quality = 'mistake'; 
            else if (deviation > 50) quality = 'inaccuracy'; 

            newResults.push({
                nodeId: nextNode.id,
                moveIndex: i + 1,
                moveNotation: nextNode.move?.notation || "未知",
                fen: currentNode.fen,
                score: finalScore,
                deviation,
                isRedTurn: isRedTurn,
                bestMove: bestMoveNotation,
                bestScore: isRedTurn ? (bestCloudMove?.score || 0) : -(bestCloudMove?.score || 0), 
                quality
            });

            setResults([...newResults]);
            setProgress(((i + 1) / totalSteps) * 100);

            await new Promise(r => setTimeout(r, 150)); 
        }

        setIsAnalyzing(false);
    };

    const stopAnalysis = () => {
        if (abortControllerRef.current) {
            abortControllerRef.current.abort();
        }
        setIsAnalyzing(false);
    };

    const handleJumpTo = (indexInResults: number, moveIndex: number) => {
        setSelectedIndex(indexInResults);
        onJumpToStep(moveIndex);
    };

    const writeAnnotations = () => {
        if (results.length === 0) return;
        
        const updates: {id: string, text: string}[] = [];

        results.forEach(res => {
            if (res.quality !== 'good') {
                const node = movePath.find(n => n.id === res.nodeId);
                if (!node) return;
                
                let label = '';
                if (res.quality === 'blunder') label = '錯著';
                else if (res.quality === 'mistake') label = '失著';
                else if (res.quality === 'inaccuracy') label = '緩著';

                const note = `【${label}】\n評分: ${res.score}\n偏差: ${res.deviation}\n推薦: ${res.bestMove} (${res.bestScore})`;
                
                let newComment = node.comment || "";
                if (!newComment.includes(`評分: ${res.score}`)) {
                    if (newComment.trim().length > 0) {
                        newComment += "\n" + note;
                    } else {
                        newComment = note;
                    }
                    updates.push({ id: res.nodeId, text: newComment });
                }
            }
        });
        
        onBatchUpdateComments(updates);
        alert(`已將 ${updates.length} 條分析註釋寫入棋譜。`);
        onClose();
    };

    // --- Chart Logic ---
    const chartHeight = 220;
    const chartWidth = 600;
    const padding = 20;
    
    // Only map valid points to coordinates, but we need to keep the index logic consistent
    // So we map ALL points, but return null coords for invalid scores
    const getCoordinates = () => {
        if (results.length === 0) return "";
        const maxY = 600;
        const minY = -600;
        
        // Filter out null scores for the polyline only
        const validPoints = results
            .map((res, idx) => ({ ...res, idx }))
            .filter(r => r.score !== null && !isNaN(r.score));

        if (validPoints.length === 0) return "";

        const points = validPoints.map((res) => {
             const x = padding + (res.idx / (results.length - 1 || 1)) * (chartWidth - padding * 2);
             let val = res.score!;
             val = Math.max(minY, Math.min(maxY, val));
             const y = chartHeight - ((val - minY) / (maxY - minY)) * chartHeight;
             return `${x},${y}`;
        });
        
        return points.join(" ");
    };

    const getStats = (isRed: boolean) => {
        const sideResults = results.filter(r => r.isRedTurn === isRed);
        return {
            total: sideResults.length,
            good: sideResults.filter(r => r.quality === 'good').length,
            inaccuracy: sideResults.filter(r => r.quality === 'inaccuracy').length,
            mistake: sideResults.filter(r => r.quality === 'mistake').length,
            blunder: sideResults.filter(r => r.quality === 'blunder').length,
        };
    };

    const redStats = getStats(true);
    const blackStats = getStats(false);

    const getQualityColor = (q: string) => {
        switch(q) {
            case 'blunder': return '#dc2626'; // Red
            case 'mistake': return '#f97316'; // Orange
            case 'inaccuracy': return '#eab308'; // Yellow
            default: return '#3b82f6'; // Blue
        }
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-full max-w-5xl flex flex-col max-h-[95vh] mx-4">
                {/* Header */}
                <div className="px-6 py-4 border-b border-zinc-800 flex justify-between items-center shrink-0">
                    <h2 className="text-xl font-bold text-white flex items-center gap-2">
                        <Activity className="text-blue-500" />
                        全局形勢分析
                    </h2>
                    <button onClick={onClose} className="p-1 hover:bg-zinc-800 rounded text-zinc-400 hover:text-white">
                        <X size={24} />
                    </button>
                </div>

                {/* Body */}
                <div className="flex-1 overflow-y-auto p-4 md:p-6 space-y-6">
                    
                    {/* 1. Chart */}
                    <div className="bg-zinc-950 border border-zinc-800 rounded-lg p-4 relative h-64 select-none group">
                        {results.length > 0 ? (
                            <svg width="100%" height="100%" viewBox={`0 0 ${chartWidth} ${chartHeight}`} className="overflow-visible">
                                {/* Zero Line */}
                                <line x1={padding} y1={chartHeight/2} x2={chartWidth-padding} y2={chartHeight/2} stroke="#3f3f46" strokeWidth="1" strokeDasharray="4 4" />
                                
                                <polyline 
                                    points={getCoordinates()} 
                                    fill="none" 
                                    stroke="#3b82f6" 
                                    strokeWidth="2" 
                                    strokeLinecap="round" 
                                    strokeLinejoin="round" 
                                />

                                {results.map((res, idx) => {
                                    // Skip null or NaN scores for dots
                                    if (res.score === null || isNaN(res.score)) return null;

                                    const x = padding + (idx / (results.length - 1 || 1)) * (chartWidth - padding * 2);
                                    let val = res.score;
                                    val = Math.max(-600, Math.min(600, val));
                                    const y = chartHeight - ((val + 600) / 1200) * chartHeight;
                                    
                                    const color = getQualityColor(res.quality);
                                    
                                    // Highlight Logic
                                    const isSelected = selectedIndex === idx;
                                    const isHovered = hoverIndex === idx;
                                    
                                    // Base radius
                                    const r = (isHovered || isSelected) ? 6 : (res.quality !== 'good' ? 3.5 : 1.5);

                                    return (
                                        <g key={idx}>
                                            {/* Glow Effect for Selected Point */}
                                            {isSelected && (
                                                <circle 
                                                    cx={x} cy={y} r={12} 
                                                    fill={color} 
                                                    fillOpacity="0.3"
                                                    className="animate-pulse"
                                                />
                                            )}
                                            
                                            {/* Main Dot */}
                                            <circle 
                                                cx={x} cy={y} r={r} 
                                                fill={color}
                                                stroke={isSelected ? "#fff" : "none"}
                                                strokeWidth={isSelected ? 1.5 : 0}
                                                className="cursor-pointer transition-all"
                                                onMouseEnter={() => setHoverIndex(idx)}
                                                onMouseLeave={() => setHoverIndex(null)}
                                                onClick={() => handleJumpTo(idx, res.moveIndex)}
                                            />
                                        </g>
                                    );
                                })}
                            </svg>
                        ) : (
                            <div className="w-full h-full flex items-center justify-center text-zinc-600">
                                <Activity className="mr-2 animate-pulse" /> 等待開始分析...
                            </div>
                        )}
                        
                        {/* Tooltip */}
                        {hoverIndex !== null && results[hoverIndex] && (
                            <div className="absolute top-2 right-2 bg-zinc-800/95 p-3 rounded border border-zinc-700 text-xs shadow-xl backdrop-blur-sm z-10 pointer-events-none min-w-[140px]">
                                <div className="font-bold text-zinc-200 mb-1 border-b border-zinc-700 pb-1">
                                    第 {results[hoverIndex].moveIndex} 手 ({results[hoverIndex].isRedTurn ? '紅' : '黑'})
                                </div>
                                <div className="text-zinc-300 mb-1">{results[hoverIndex].moveNotation}</div>
                                <div className={`font-mono font-bold ${results[hoverIndex].score! > 0 ? "text-red-400" : "text-green-400"}`}>
                                    評分: {results[hoverIndex].score}
                                </div>
                                {results[hoverIndex].deviation > 0 && (
                                    <div className="text-amber-500 mt-1">
                                        虧損: {results[hoverIndex].deviation}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>

                    {/* 2. Controls */}
                    <div className="flex gap-3">
                        {!isAnalyzing ? (
                            <button 
                                onClick={startAnalysis}
                                className="flex-1 py-3 bg-blue-600 hover:bg-blue-500 text-white rounded-lg font-bold flex items-center justify-center gap-2 transition-colors shadow-lg shadow-blue-900/20"
                            >
                                <Play size={20} fill="currentColor" /> {results.length > 0 ? '重新分析' : '開始全盤分析'}
                            </button>
                        ) : (
                            <button 
                                onClick={stopAnalysis}
                                className="flex-1 py-3 bg-zinc-700 hover:bg-zinc-600 text-white rounded-lg font-bold transition-colors"
                            >
                                停止分析
                            </button>
                        )}
                        
                        <button 
                            onClick={writeAnnotations}
                            disabled={results.length === 0 || isAnalyzing}
                            className="px-6 py-3 bg-zinc-800 hover:bg-zinc-700 disabled:opacity-50 text-zinc-200 border border-zinc-700 rounded-lg font-medium flex items-center justify-center gap-2 transition-colors"
                        >
                            <Edit3 size={18} /> 寫入註釋
                        </button>
                    </div>

                    {/* Progress */}
                    {isAnalyzing && (
                        <div className="space-y-1">
                            <div className="h-2 bg-zinc-800 rounded-full overflow-hidden">
                                <div className="h-full bg-blue-500 transition-all duration-300" style={{ width: `${progress}%` }}></div>
                            </div>
                            <div className="text-xs text-center text-zinc-500">處理中... {Math.round(progress)}%</div>
                        </div>
                    )}

                    {/* 3. Statistics Split */}
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <StatCard title="紅方統計" stats={redStats} isRed={true} />
                        <StatCard title="黑方統計" stats={blackStats} isRed={false} />
                    </div>

                    {/* Legend */}
                    <div className="flex flex-wrap gap-4 text-xs justify-center text-zinc-400 bg-zinc-900/50 p-2 rounded-lg border border-zinc-800/50">
                        <div className="flex items-center gap-1.5"><span className="w-2.5 h-2.5 rounded-full bg-blue-500"></span> 正常</div>
                        <div className="flex items-center gap-1.5"><span className="w-2.5 h-2.5 rounded-full bg-yellow-500"></span> 緩著 ({'>'}50)</div>
                        <div className="flex items-center gap-1.5"><span className="w-2.5 h-2.5 rounded-full bg-orange-500"></span> 失著 ({'>'}200)</div>
                        <div className="flex items-center gap-1.5"><span className="w-2.5 h-2.5 rounded-full bg-red-600"></span> 錯著 ({'>'}500)</div>
                    </div>

                    {/* 4. Bad Moves List - Split by Color */}
                    {results.some(r => r.quality !== 'good') && (
                        <div className="space-y-4">
                            <h3 className="text-sm font-bold text-zinc-400 flex items-center gap-2">
                                <AlertTriangle size={16} />
                                重點失誤回顧
                            </h3>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                {/* Red Errors */}
                                <div className="space-y-2">
                                    <div className="text-xs font-bold text-red-400 border-b border-zinc-800 pb-1 mb-2">紅方失誤</div>
                                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                                        {results.map((res, idx) => {
                                            if (!res.isRedTurn || res.quality === 'good') return null;
                                            return <BadMoveItem key={res.nodeId} res={res} idx={idx} selectedIndex={selectedIndex} onJump={handleJumpTo} />;
                                        })}
                                        {results.filter(r => r.isRedTurn && r.quality !== 'good').length === 0 && (
                                            <div className="text-zinc-600 text-xs italic col-span-full">無明顯失誤</div>
                                        )}
                                    </div>
                                </div>
                                
                                {/* Black Errors */}
                                <div className="space-y-2">
                                    <div className="text-xs font-bold text-zinc-400 border-b border-zinc-800 pb-1 mb-2">黑方失誤</div>
                                    <div className="grid grid-cols-2 sm:grid-cols-3 gap-2">
                                        {results.map((res, idx) => {
                                            if (res.isRedTurn || res.quality === 'good') return null;
                                            return <BadMoveItem key={res.nodeId} res={res} idx={idx} selectedIndex={selectedIndex} onJump={handleJumpTo} />;
                                        })}
                                        {results.filter(r => !r.isRedTurn && r.quality !== 'good').length === 0 && (
                                            <div className="text-zinc-600 text-xs italic col-span-full">無明顯失誤</div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

const BadMoveItem: React.FC<{ 
    res: AnalysisResult; 
    idx: number; 
    selectedIndex: number | null;
    onJump: (index: number, moveIndex: number) => void;
}> = ({ res, idx, selectedIndex, onJump }) => {
    let borderColor = '';
    let bgColor = '';
    let textColor = '';
    
    if (res.quality === 'blunder') {
        borderColor = 'border-red-900/50'; bgColor = 'bg-red-950/30 hover:bg-red-900/20'; textColor = 'text-red-400';
    } else if (res.quality === 'mistake') {
        borderColor = 'border-orange-900/50'; bgColor = 'bg-orange-950/30 hover:bg-orange-900/20'; textColor = 'text-orange-400';
    } else {
        borderColor = 'border-yellow-900/50'; bgColor = 'bg-yellow-950/30 hover:bg-yellow-900/20'; textColor = 'text-yellow-400';
    }

    const isSelected = selectedIndex === idx;

    return (
        <button 
            onClick={() => onJump(idx, res.moveIndex)}
            className={`
                w-full px-3 py-2 rounded text-left border transition-all text-xs flex flex-col gap-1
                ${borderColor} ${bgColor} ${textColor}
                ${isSelected ? 'ring-2 ring-white/50 scale-[1.02]' : 'opacity-90'}
            `}
        >
            <div className="font-bold flex justify-between w-full">
                <span>#{res.moveIndex} {res.moveNotation}</span>
            </div>
            <div className="flex justify-between items-center opacity-80">
                 <span className="font-mono">{res.score}分</span>
                 <span className="font-mono">虧:{res.deviation}</span>
            </div>
        </button>
    );
};

const StatCard = ({ title, stats, isRed }: { title: string, stats: any, isRed: boolean }) => {
    return (
        <div className={`rounded-lg p-4 border ${isRed ? 'bg-red-950/10 border-red-900/20' : 'bg-zinc-950/50 border-zinc-800'}`}>
            <h3 className={`text-sm font-bold mb-3 flex justify-between ${isRed ? 'text-red-300' : 'text-zinc-300'}`}>
                {title} <span className="text-zinc-500 font-normal text-xs">{stats.total} 手</span>
            </h3>
            <div className="space-y-2">
                <StatRow label="錯著 (>500)" count={stats.blunder} total={stats.total} color="bg-red-600" textColor="text-red-400" />
                <StatRow label="失著 (>200)" count={stats.mistake} total={stats.total} color="bg-orange-500" textColor="text-orange-400" />
                <StatRow label="緩著 (>50)" count={stats.inaccuracy} total={stats.total} color="bg-yellow-500" textColor="text-yellow-400" />
                <StatRow label="正常" count={stats.good} total={stats.total} color="bg-blue-600" textColor="text-blue-400" />
            </div>
        </div>
    );
};

const StatRow = ({ label, count, total, color, textColor }: { label: string, count: number, total: number, color: string, textColor: string }) => {
    const percent = total > 0 ? Math.round((count / total) * 100) : 0;
    return (
        <div className="flex items-center gap-2 text-xs">
            <span className={`w-20 ${textColor} font-medium`}>{label}</span>
            <div className="flex-1 h-1.5 bg-zinc-800 rounded-full overflow-hidden">
                <div className={`h-full ${color}`} style={{ width: `${percent}%` }}></div>
            </div>
            <span className="w-6 text-right font-mono text-zinc-300">{count}</span>
            <span className="w-8 text-right font-mono text-zinc-500">{percent}%</span>
        </div>
    );
};

export default AnalysisModal;


==============================
File Path: components\BoardEditorModal.tsx
==============================

import React, { useState, useEffect, useRef } from 'react';
import { X, Copy, Check, RotateCw, RefreshCcw, Trash2, ArrowUpDown } from 'lucide-react';
import ChessBoard from './ChessBoard';
import { Piece, PieceColor, Point } from '../types';
import { INITIAL_BOARD_SETUP, PIECES } from '../constants';
import { getFen, fenToBoard, validatePiecePlacement } from '../lib/utils';

interface BoardEditorModalProps {
    isOpen: boolean;
    onClose: () => void;
    initialFen: string;
    onConfirm: (fen: string) => void;
    isFlippedInitial: boolean;
}

const PIECE_TYPES = ['king', 'advisor', 'elephant', 'horse', 'chariot', 'cannon', 'soldier'];
const PIECE_LIMITS: Record<string, number> = {
    king: 1, advisor: 2, elephant: 2, horse: 2, chariot: 2, cannon: 2, soldier: 5
};

const BoardEditorModal: React.FC<BoardEditorModalProps> = ({ isOpen, onClose, initialFen, onConfirm, isFlippedInitial }) => {
    // Editor State
    const [board, setBoard] = useState<(Piece | null)[][]>(INITIAL_BOARD_SETUP());
    const [turn, setTurn] = useState<PieceColor>('red');
    const [isFlipped, setIsFlipped] = useState(isFlippedInitial);
    
    // Selection State
    // Selected from Board: { type: 'board', r, c }
    // Selected from Box: { type: 'box', pieceType, color }
    const [selectedSource, setSelectedSource] = useState<{type: 'board', r: number, c: number} | {type: 'box', piece: Piece} | null>(null);
    
    // Mini Selector Popup State
    const [miniSelector, setMiniSelector] = useState<{r: number, c: number, x: number, y: number} | null>(null);
    
    // UI State
    const [fenInput, setFenInput] = useState('');
    const [copyFeedback, setCopyFeedback] = useState(false);
    
    // Double Click Detection
    const lastClickTimeRef = useRef<{time: number, r: number, c: number} | null>(null);
    // TextArea Ref for fallback focus
    const textareaRef = useRef<HTMLTextAreaElement>(null);

    // Init
    useEffect(() => {
        if (isOpen) {
            const { board: loadedBoard, turn: loadedTurn } = fenToBoard(initialFen);
            setBoard(loadedBoard);
            setTurn(loadedTurn);
            setFenInput(initialFen);
            setSelectedSource(null);
            setMiniSelector(null);
            setIsFlipped(isFlippedInitial);
        }
    }, [isOpen, initialFen, isFlippedInitial]);

    // Update FEN when board changes
    useEffect(() => {
        if (isOpen) {
            const newFen = getFen(board, turn);
            setFenInput(newFen);
        }
    }, [board, turn, isOpen]);

    if (!isOpen) return null;

    // --- Actions ---

    const handleSquareClick = (p: Point, rect: DOMRect) => {
        const now = Date.now();
        const last = lastClickTimeRef.current;
        const isDouble = last && (now - last.time < 300) && last.r === p.r && last.c === p.c;
        lastClickTimeRef.current = { time: now, r: p.r, c: p.c };

        // Hide Mini Selector if open
        if (miniSelector) setMiniSelector(null);

        const clickedPiece = board[p.r][p.c];

        // 1. Double Click -> Remove Piece (Clear)
        if (isDouble && clickedPiece) {
            const newBoard = board.map(row => [...row]);
            newBoard[p.r][p.c] = null;
            setBoard(newBoard);
            setSelectedSource(null);
            return;
        }

        // 2. Handle Placement (If we have a selection)
        if (selectedSource) {
            let pieceToPlace: Piece | null = null;
            
            if (selectedSource.type === 'box') {
                pieceToPlace = selectedSource.piece;
            } else {
                // From Board
                pieceToPlace = board[selectedSource.r][selectedSource.c];
            }

            if (pieceToPlace) {
                // Validate Placement
                if (!validatePiecePlacement(pieceToPlace.type, pieceToPlace.color, p.r, p.c)) {
                    // Invalid placement -> Shake or just select the target instead?
                    // If clicked on another piece, maybe select that instead
                    if (clickedPiece) {
                        setSelectedSource({ type: 'board', r: p.r, c: p.c });
                    } else {
                        // Clicking empty invalid spot -> Deselect
                        setSelectedSource(null);
                    }
                    return;
                }

                // Execute Move/Place
                const newBoard = board.map(row => [...row]);
                
                // If moving from board, clear source first
                if (selectedSource.type === 'board') {
                    // If source == target, just deselect
                    if (selectedSource.r === p.r && selectedSource.c === p.c) {
                        setSelectedSource(null);
                        return;
                    }
                    newBoard[selectedSource.r][selectedSource.c] = null;
                }

                // Place piece
                newBoard[p.r][p.c] = pieceToPlace;
                setBoard(newBoard);
                setSelectedSource(null);
            }
            return;
        }

        // 3. Handle Selection (No current selection)
        if (clickedPiece) {
            setSelectedSource({ type: 'board', r: p.r, c: p.c });
        } else {
            // Clicked Empty Spot -> Show Mini Selector
            setMiniSelector({ r: p.r, c: p.c, x: 0, y: 0 }); // Coords are logic, x/y unused if centered
        }
    };

    const handleBoxSelect = (piece: Piece) => {
        // If we select a piece from box, set it as source
        setSelectedSource({ type: 'box', piece });
        setMiniSelector(null);
    };

    const handleReset = () => {
        setBoard(INITIAL_BOARD_SETUP());
        setTurn('red');
    };

    const handleClear = () => {
        // Clear all except Kings
        const newBoard = Array(10).fill(null).map(() => Array(9).fill(null));
        // Find kings in current board to keep them? Or just place default kings?
        // Usually editors place kings at default spots if cleared.
        // Red King
        newBoard[9][4] = { type: 'king', color: 'red', text: PIECES.red.king };
        // Black King
        newBoard[0][4] = { type: 'king', color: 'black', text: PIECES.black.king };
        setBoard(newBoard);
    };

    const handleCopy = () => {
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(fenInput).then(() => {
                setCopyFeedback(true);
                setTimeout(() => setCopyFeedback(false), 2000);
            }).catch(err => {
                // If write fails, select text
                textareaRef.current?.select();
            });
        } else {
            textareaRef.current?.select();
            try {
                document.execCommand('copy');
                setCopyFeedback(true);
                setTimeout(() => setCopyFeedback(false), 2000);
            } catch (e) {}
        }
    };

    const handlePaste = async () => {
        try {
            // Check for API support
            if (!navigator.clipboard || !navigator.clipboard.readText) {
                throw new Error("Clipboard API not supported");
            }

            const text = await navigator.clipboard.readText();
            if (text) {
                if (text.indexOf('/') === -1) {
                    alert('剪貼簿內容似乎不是有效的 FEN (格式不符)');
                    return;
                }
                
                try {
                    const { board: newBoard, turn: newTurn } = fenToBoard(text);
                    setBoard(newBoard);
                    setTurn(newTurn);
                } catch (err) {
                    alert('FEN 解析失敗，請確認格式');
                }
            } else {
                 // Empty clipboard logic if needed
            }
        } catch (e) {
            // Suppress console error for known permission issues to avoid confusing users/developers
            // console.error("Paste failed", e);
            
            // Provide a gentle fallback instructions
            alert('無法自動讀取剪貼簿 (瀏覽器權限限制)。\n\n請手動將 FEN 貼上至下方的輸入框中 (Ctrl+V)。');
            
            // Focus the textarea to help the user
            if (textareaRef.current) {
                textareaRef.current.focus();
                textareaRef.current.select();
            }
        }
    };

    // Calculate Counts for Box Dimming
    const getPieceCounts = () => {
        const counts: Record<string, number> = {};
        board.flat().forEach(p => {
            if (p) {
                const key = `${p.color}-${p.type}`;
                counts[key] = (counts[key] || 0) + 1;
            }
        });
        return counts;
    };
    const pieceCounts = getPieceCounts();

    // Render helper for a piece button
    const renderPieceBtn = (type: string, color: 'red' | 'black', label: string) => {
        const count = pieceCounts[`${color}-${type}`] || 0;
        const max = PIECE_LIMITS[type];
        const isMaxed = count >= max;
        const p: Piece = { type: type as any, color, text: label };
        const isSelected = selectedSource?.type === 'box' && selectedSource.piece.color === color && selectedSource.piece.type === type;

        return (
            <button 
                key={`${color}-${type}`}
                onClick={() => handleBoxSelect(p)}
                className={`
                    w-9 h-9 md:w-10 md:h-10 rounded-full flex items-center justify-center font-bold font-serif text-lg shadow-sm border
                    ${isSelected ? 'ring-2 ring-blue-500 scale-110 z-10' : ''}
                    ${isMaxed ? 'opacity-30 cursor-not-allowed bg-zinc-800 border-zinc-700 grayscale' : 'cursor-pointer hover:brightness-110'}
                    ${color === 'red' 
                        ? (isMaxed ? 'text-zinc-500' : 'bg-[#f0d9b5] text-[#a61c1c] border-[#a61c1c]') 
                        : (isMaxed ? 'text-zinc-500' : 'bg-[#f0d9b5] text-black border-black')
                    }
                `}
            >
                {label}
            </button>
        );
    };

    return (
        <div className="fixed inset-0 z-[200] flex items-center justify-center bg-black/95 backdrop-blur-md animate-in fade-in duration-200">
            <div className="w-full h-full md:max-w-6xl flex flex-col md:flex-row overflow-hidden bg-zinc-900 md:rounded-xl md:h-[95vh] md:border border-zinc-800 shadow-2xl">
                
                {/* 1. Board Area (Top on mobile, Left on desktop) */}
                <div className="flex-1 relative bg-[#2a2a2e] flex items-center justify-center p-2 min-h-0">
                    <div className="w-full h-full max-w-[600px] flex flex-col justify-center">
                        <ChessBoard 
                            currentBoard={board}
                            isFlipped={isFlipped}
                            isMirrored={false}
                            mode="edit"
                            selectedCoord={selectedSource?.type === 'board' ? {r: selectedSource.r, c: selectedSource.c} : null}
                            onSquareClick={handleSquareClick}
                        />
                    </div>

                    {/* Mini Selector Overlay */}
                    {miniSelector && (
                        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/50" onClick={() => setMiniSelector(null)}>
                            <div className="bg-zinc-800 p-4 rounded-xl shadow-2xl border border-zinc-700 grid grid-cols-4 gap-3 animate-in zoom-in-95 duration-200" onClick={e => e.stopPropagation()}>
                                <div className="col-span-4 text-center text-zinc-400 text-xs mb-1 font-bold">
                                    選擇棋子放入 ({miniSelector.r}, {miniSelector.c})
                                </div>
                                {(['red', 'black'] as const).map(color => (
                                    PIECE_TYPES.map(type => {
                                        if (!validatePiecePlacement(type, color, miniSelector.r, miniSelector.c)) return null;
                                        const label = (PIECES as any)[color][type];
                                        return (
                                            <button 
                                                key={`mini-${color}-${type}`}
                                                onClick={() => {
                                                    const newBoard = board.map(row => [...row]);
                                                    newBoard[miniSelector.r][miniSelector.c] = { type: type as any, color, text: label };
                                                    setBoard(newBoard);
                                                    setMiniSelector(null);
                                                }}
                                                className="w-10 h-10 rounded-full bg-zinc-700 hover:bg-zinc-600 flex items-center justify-center border border-zinc-600 shadow-sm"
                                            >
                                                <span className={`font-bold font-serif text-lg ${color === 'red' ? 'text-red-500' : 'text-black bg-white/10 rounded-full w-8 h-8 flex items-center justify-center'}`}>
                                                    {label}
                                                </span>
                                            </button>
                                        );
                                    })
                                ))}
                            </div>
                        </div>
                    )}
                </div>

                {/* 2. Controls (Bottom on mobile, Right on desktop) */}
                <div className="w-full md:w-80 bg-zinc-900 border-t md:border-t-0 md:border-l border-zinc-800 flex flex-col shrink-0 h-auto max-h-[50vh] md:max-h-none">
                    
                    {/* Header (Desktop only) */}
                    <div className="hidden md:flex px-4 py-3 border-b border-zinc-800 justify-between items-center bg-zinc-900">
                        <h3 className="font-bold text-zinc-200">棋盤編輯器</h3>
                        <button onClick={onClose} className="p-1 hover:bg-zinc-800 rounded text-zinc-400 hover:text-white"><X size={20} /></button>
                    </div>

                    {/* Scrollable Body */}
                    <div className="flex-1 overflow-y-auto p-3 md:p-4 space-y-4 md:space-y-6 custom-scrollbar">
                        
                        {/* Piece Box Selector - Unified Container */}
                        <div className="bg-zinc-800/50 rounded-xl p-3 border border-zinc-700/50">
                            {/* Red Row */}
                            <div className="flex justify-between gap-1 mb-2">
                                {PIECE_TYPES.map(type => {
                                    if(type === 'king') return null;
                                    return renderPieceBtn(type, 'red', PIECES.red[type]);
                                })}
                            </div>
                            {/* Black Row */}
                            <div className="flex justify-between gap-1">
                                {PIECE_TYPES.map(type => {
                                    if(type === 'king') return null;
                                    return renderPieceBtn(type, 'black', PIECES.black[type]);
                                })}
                            </div>
                        </div>

                        {/* Actions Grid */}
                        <div className="grid grid-cols-4 gap-2">
                            <button onClick={handleReset} className="flex flex-col items-center justify-center p-2 bg-zinc-800 rounded-lg hover:bg-zinc-700 text-xs gap-1 text-zinc-300 border border-zinc-700">
                                <RotateCw size={16} /> <span className="scale-90">擺滿</span>
                            </button>
                            <button onClick={handleClear} className="flex flex-col items-center justify-center p-2 bg-zinc-800 rounded-lg hover:bg-zinc-700 text-xs gap-1 text-zinc-300 border border-zinc-700">
                                <Trash2 size={16} /> <span className="scale-90">清空</span>
                            </button>
                            <button onClick={() => setIsFlipped(!isFlipped)} className="flex flex-col items-center justify-center p-2 bg-zinc-800 rounded-lg hover:bg-zinc-700 text-xs gap-1 text-zinc-300 border border-zinc-700">
                                <ArrowUpDown size={16} /> <span className="scale-90">翻轉</span>
                            </button>
                            <button onClick={() => setTurn(turn === 'red' ? 'black' : 'red')} className={`flex flex-col items-center justify-center p-2 rounded-lg text-xs gap-1 font-bold border transition-colors ${turn === 'red' ? 'bg-red-900/20 text-red-400 border-red-900/50' : 'bg-zinc-800 text-zinc-300 border-zinc-700'}`}>
                                <RefreshCcw size={16} /> <span className="scale-90">{turn === 'red' ? '紅先' : '黑先'}</span>
                            </button>
                        </div>

                        {/* FEN IO - Compact */}
                        <div className="flex gap-2">
                            <button onClick={handleCopy} className="flex-1 py-2 bg-blue-600/20 hover:bg-blue-600/30 text-blue-300 border border-blue-600/30 rounded-lg text-sm flex items-center justify-center gap-1.5 font-medium transition-colors">
                                {copyFeedback ? <Check size={14} /> : <Copy size={14} />} 複製 FEN
                            </button>
                            <button onClick={handlePaste} className="flex-1 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 border border-zinc-700 rounded-lg text-sm font-medium transition-colors">
                                貼上 FEN
                            </button>
                        </div>
                        
                        {/* FEN Input (Desktop only or optional expand?) 
                            On mobile, users mostly use buttons. We can hide the textarea to save space or make it small.
                        */}
                        <textarea 
                            ref={textareaRef}
                            value={fenInput}
                            onChange={(e) => {
                                setFenInput(e.target.value);
                                try {
                                    const { board: b, turn: t } = fenToBoard(e.target.value);
                                    setBoard(b);
                                    setTurn(t);
                                } catch {}
                            }}
                            placeholder="FEN 串..."
                            className="w-full h-14 bg-black/20 border border-zinc-700 rounded px-3 py-2 text-xs font-mono text-zinc-300 focus:outline-none focus:border-amber-500 focus:bg-black/40 resize-none transition-colors"
                        />
                    </div>

                    {/* Footer Actions */}
                    <div className="p-3 bg-zinc-900 border-t border-zinc-800 flex gap-3 shrink-0 pb-6 md:pb-4">
                        <button onClick={onClose} className="flex-1 py-3 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 font-bold rounded-lg transition-colors text-sm">
                            取消
                        </button>
                        <button onClick={() => onConfirm(fenInput)} className="flex-1 py-3 bg-amber-600 hover:bg-amber-500 text-white font-bold rounded-lg transition-colors shadow-lg shadow-amber-900/20 text-sm">
                            確定
                        </button>
                    </div>

                </div>
            </div>
        </div>
    );
};

export default BoardEditorModal;


==============================
File Path: components\ChessBoard.tsx
==============================

import React, { useRef, useEffect, useState, useMemo } from 'react';
import { GameState, Piece, Point, PieceColor, MoveNode, AppSettings } from '../types';
import { INITIAL_BOARD_SETUP } from '../constants';
import { toChineseNum, getChineseNotation } from '../lib/utils';

interface ChessBoardProps {
  currentBoard?: (Piece | null)[][];
  currentTurn?: PieceColor;
  lastMove?: { from: Point; to: Point } | null;
  onMoveMade?: (move: { from: Point; to: Point; piece: Piece; captured: Piece | null; notation: string }, newBoard: (Piece|null)[][]) => boolean;
  isFlipped: boolean;
  isMirrored: boolean;
  redName?: string;
  blackName?: string;
  // Editor Props
  mode?: 'play' | 'edit';
  selectedCoord?: Point | null; // Override internal selection
  onSquareClick?: (point: Point, rect: DOMRect) => void;
  // Visual Effects
  flashCoord?: Point | null; // Coordinate to flash "X"
  hintMove?: { from: Point; to: Point } | null; // Hint Effect
  
  // New props for Arrows
  currentNode?: MoveNode;
  onNodeSelect?: (node: MoveNode) => void;

  // Settings
  settings?: AppSettings;
  shouldAnimate?: boolean;
}

// --- Logic helpers ---
const canMove = (board: (Piece|null)[][], fr: number, fc: number, tr: number, tc: number): boolean => {
    const p = board[fr][fc];
    if(!p) return false;
    const target = board[tr][tc];
    if (target && target.color === p.color) return false;
    const dr = tr - fr; const dc = tc - fc;
    const absDr = Math.abs(dr); const absDc = Math.abs(dc);

    switch (p.type) {
        case 'king':
            if (target && target.type === 'king' && fc === tc) {
                 let count = 0;
                 for (let i = Math.min(fr, tr) + 1; i < Math.max(fr, tr); i++) if (board[i][fc]) count++;
                 return count === 0;
            }
            return (absDr + absDc === 1) && tc >= 3 && tc <= 5 && (p.color === 'red' ? tr >= 7 : tr <= 2);
        case 'advisor': return absDr === 1 && absDc === 1 && tc >= 3 && tc <= 5 && (p.color === 'red' ? tr >= 7 : tr <= 2);
        case 'elephant': return absDr === 2 && absDc === 2 && !board[fr + dr/2][fc + dc/2] && (p.color === 'red' ? tr >= 5 : tr <= 4);
        case 'horse': return ((absDr === 2 && absDc === 1 && !board[fr + dr/2][fc]) || (absDr === 1 && absDc === 2 && !board[fr][fc + dc/2]));
        case 'chariot': 
            if (fr !== tr && fc !== tc) return false; 
            return countPiecesBetween(board, fr, fc, tr, tc) === 0;
        case 'cannon': 
            if (fr !== tr && fc !== tc) return false; 
            let count = countPiecesBetween(board, fr, fc, tr, tc); 
            return target ? count === 1 : count === 0;
        case 'soldier':
            if (p.color === 'red') {
                if (tr > fr) return false;
                return fr >= 5 ? (dr === -1 && dc === 0) : (dr === -1 && dc === 0 || dr === 0 && absDc === 1);
            } else {
                if (tr < fr) return false;
                return fr <= 4 ? (dr === 1 && dc === 0) : (dr === 1 && dc === 0 || dr === 0 && absDc === 1);
            }
    }
    return false;
};

const countPiecesBetween = (board: (Piece|null)[][], fr: number, fc: number, tr: number, tc: number) => {
    let count = 0;
    if (fr === tr) { for (let j = Math.min(fc, tc) + 1; j < Math.max(fc, tc); j++) if (board[fr][j]) count++; }
    else { for (let i = Math.min(fr, tr) + 1; i < Math.max(fr, tr); i++) if (board[i][fc]) count++; }
    return count;
};

// Helper to find the king and check if it's under attack
const isKingInCheck = (board: (Piece | null)[][], kingColor: PieceColor): boolean => {
    // 1. Find King
    let kingPos: Point | null = null;
    for(let r=0; r<10; r++) {
        for(let c=0; c<9; c++) {
            const p = board[r][c];
            if(p && p.type === 'king' && p.color === kingColor) {
                kingPos = { r, c };
                break;
            }
        }
        if(kingPos) break;
    }
    if(!kingPos) return false;

    // 2. Check if any enemy piece can move to King's position
    for(let r=0; r<10; r++) {
        for(let c=0; c<9; c++) {
            const p = board[r][c];
            if(p && p.color !== kingColor) {
                if(canMove(board, r, c, kingPos.r, kingPos.c)) {
                    return true;
                }
            }
        }
    }
    return false;
};

interface AnimationState {
    active: boolean;
    startTime: number;
    duration: number;
    from: Point;
    to: Point;
    piece: Piece;
    isCannonCapture: boolean;
}

interface ShakeState {
    active: boolean;
    startTime: number;
    duration: number;
    r: number;
    c: number;
}

const ChessBoard: React.FC<ChessBoardProps> = ({ 
    onMoveMade, 
    currentBoard, 
    currentTurn, 
    lastMove, 
    isFlipped, 
    isMirrored,
    redName,
    blackName,
    mode = 'play',
    selectedCoord,
    onSquareClick,
    flashCoord,
    hintMove,
    currentNode,
    onNodeSelect,
    settings,
    shouldAnimate = true
}) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const containerRef = useRef<HTMLDivElement>(null);
    // Fix: useRef requires an initial value to satisfy certain TypeScript configurations.
    const requestRef = useRef<number | undefined>(undefined);
    
    // Unique ID for SVG defs to prevent conflicts when multiple boards exist
    const uniqueId = useMemo(() => Math.random().toString(36).substring(2, 9), []);
    const maskId = `arrowFadeMask-${uniqueId}`;
    const patternId = `flowPattern-${uniqueId}`;
    const gradientId = `fadeGradient-${uniqueId}`;
    const markerBlueId = `arrowhead-blue-${uniqueId}`;
    const markerGreenId = `arrowhead-green-${uniqueId}`;
    
    // Internal State
    const [localState, setLocalState] = useState<GameState>({
        board: INITIAL_BOARD_SETUP(),
        turn: 'red',
        moves: [],
        selectedPiece: null,
        lastMove: null
    });

    // Refs for Animation
    const prevBoardRef = useRef<(Piece | null)[][]>(INITIAL_BOARD_SETUP());
    const animationRef = useRef<AnimationState | null>(null);
    const shakeRef = useRef<ShakeState | null>(null);
    const prevLastMoveRef = useRef<{ from: Point; to: Point } | null>(null);

    // Flash State for Wrong Moves
    const [activeFlashes, setActiveFlashes] = useState<{r: number, c: number, id: number}[]>([]);
    
    // Manual Arrow State
    const [manualArrows, setManualArrows] = useState<{from: Point, to: Point}[]>([]);
    const [dragArrow, setDragArrow] = useState<{start: Point, current: {x: number, y: number}} | null>(null);

    // Hover State for Variation Arrows (to bring to front)
    const [hoveredVariationId, setHoveredVariationId] = useState<string | null>(null);

    useEffect(() => {
        if (flashCoord) {
            const id = Date.now();
            setActiveFlashes(prev => [...prev, { ...flashCoord, id }]);
            setTimeout(() => {
                setActiveFlashes(prev => prev.filter(f => f.id !== id));
            }, 800);
        }
    }, [flashCoord]);

    // Clear manual arrows when board changes (FEN changes implies different board)
    useEffect(() => {
        setManualArrows([]);
        setHoveredVariationId(null);
    }, [currentBoard]);

    // Handle Props Update & Trigger Animations
    useEffect(() => {
        if (currentBoard) {
            // 1. Detect Move Animation
            const hasLastMoveChanged = lastMove && (!prevLastMoveRef.current || 
                lastMove.from.r !== prevLastMoveRef.current.from.r || 
                lastMove.from.c !== prevLastMoveRef.current.from.c ||
                lastMove.to.r !== prevLastMoveRef.current.to.r ||
                lastMove.to.c !== prevLastMoveRef.current.to.c
            );

            if (hasLastMoveChanged) {
                if (shouldAnimate) {
                    const prevBoard = prevBoardRef.current;
                    const movingPiece = currentBoard[lastMove.to.r][lastMove.to.c];
                    const animDuration = settings?.animationSpeed ?? 300;

                    if (movingPiece && animDuration > 0) {
                        let isCannonCapture = false;
                        if (movingPiece.type === 'cannon') {
                            const targetInPrev = prevBoard[lastMove.to.r][lastMove.to.c];
                            if (targetInPrev && targetInPrev.color !== movingPiece.color) {
                                isCannonCapture = true;
                            }
                        }
                        animationRef.current = {
                            active: true,
                            startTime: Date.now(),
                            duration: animDuration, 
                            from: lastMove.from,
                            to: lastMove.to,
                            piece: movingPiece,
                            isCannonCapture
                        };
                    }
                }
                prevLastMoveRef.current = lastMove;
            } else if (!lastMove) {
                animationRef.current = null;
                prevLastMoveRef.current = null;
            }

            // 2. Detect Check (Shake)
            const playerUnderAttack = currentTurn || 'black'; 
            if (isKingInCheck(currentBoard, playerUnderAttack)) {
                for(let r=0; r<10; r++) {
                    for(let c=0; c<9; c++) {
                        const p = currentBoard[r][c];
                        if(p && p.type === 'king' && p.color === playerUnderAttack) {
                            shakeRef.current = {
                                active: true,
                                startTime: Date.now() + (settings?.animationSpeed ?? 300), 
                                duration: 500,
                                r, c
                            };
                            break;
                        }
                    }
                }
            } else {
                shakeRef.current = null;
            }

            setLocalState(prev => ({
                ...prev,
                board: currentBoard,
                turn: currentTurn || 'red',
                selectedPiece: null,
                lastMove: lastMove || null
            }));

            prevBoardRef.current = currentBoard;
        }
    }, [currentBoard, currentTurn, lastMove, settings?.animationSpeed, shouldAnimate]);
    
    const [dimensions, setDimensions] = useState({ width: 500, height: 600, gridSize: 50, offsetX: 50, offsetY: 50 });

    useEffect(() => {
        if (!containerRef.current) return;
        
        const updateDimensions = () => {
             if (containerRef.current) {
                const { clientWidth, clientHeight } = containerRef.current;
                if (clientWidth === 0 || clientHeight === 0) return;

                let horizontalGridsNeeded = 12; 
                let verticalGridsNeeded = 13;
                let maxGridSize = 80;

                if (settings?.boardSize === 'large') {
                    // Mobile portrait optimization:
                    // The board is 9 lines wide (indices 0..8). Visual width is 8 * gridSize.
                    // Piece radius is ~0.45 gridSize. So edge pieces need 0.45 margin.
                    // Total width needed = 8 + 0.5*2 = 9 grids.
                    // Setting to 9.2 gives a tiny safe padding.
                    horizontalGridsNeeded = 9.2;
                    verticalGridsNeeded = 11;
                    maxGridSize = 999;
                } else if (settings?.boardSize === 'small') {
                    horizontalGridsNeeded = 14; 
                    verticalGridsNeeded = 15;
                    maxGridSize = 35; 
                }

                const maxGridW = clientWidth / horizontalGridsNeeded;
                const maxGridH = clientHeight / verticalGridsNeeded;
                
                let gridSize = Math.min(maxGridW, maxGridH);
                if (gridSize > maxGridSize) gridSize = maxGridSize; 
                
                const boardPixelW = 8 * gridSize;
                const boardPixelH = 9 * gridSize;
                
                const offsetX = (clientWidth - boardPixelW) / 2;
                const freeVerticalSpace = clientHeight - boardPixelH;
                const offsetY = (freeVerticalSpace / 2); 

                setDimensions({ 
                    width: clientWidth, 
                    height: clientHeight,
                    gridSize: gridSize, 
                    offsetX: offsetX, 
                    offsetY: offsetY 
                });
             }
        };

        const resizeObserver = new ResizeObserver(() => {
            requestAnimationFrame(updateDimensions);
        });
        
        resizeObserver.observe(containerRef.current);
        updateDimensions();

        return () => resizeObserver.disconnect();
    }, [settings?.boardSize]);

    // --- Transformation Logic ---
    const getVisualPos = (r: number, c: number) => {
        let vr = r;
        let vc = c;

        if (isFlipped) {
            vr = 9 - r;
            vc = 8 - c;
        }

        if (isMirrored) {
            vc = 8 - vc;
        }

        return { r: vr, c: vc };
    };

    const getLogicalPos = (vr: number, vc: number) => {
        let c = vc;
        let r = vr;
        if (isMirrored) {
            c = 8 - c;
        }
        if (isFlipped) {
            r = 9 - r;
            c = 8 - c;
        }
        return { r, c };
    };

    const getPixelPos = (r: number, c: number) => {
        const v = getVisualPos(r, c);
        const { gridSize, offsetX, offsetY } = dimensions;
        return {
            x: offsetX + v.c * gridSize,
            y: offsetY + v.r * gridSize
        };
    };

    const getLogicalFromPixel = (x: number, y: number): Point | null => {
        const { gridSize, offsetX, offsetY } = dimensions;
        const vc = Math.round((x - offsetX) / gridSize);
        const vr = Math.round((y - offsetY) / gridSize);
        
        if (vr < 0 || vr > 9 || vc < 0 || vc > 8) return null;
        return getLogicalPos(vr, vc);
    };

    const easeOutCubic = (x: number): number => {
        return 1 - Math.pow(1 - x, 3);
    };

    // --- Drawing Loop ---
    const renderFrame = () => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        const { width, height, gridSize, offsetX, offsetY } = dimensions;
        if (width === 0 || height === 0) return;

        const { board, selectedPiece } = localState;
        const activeSelection = (mode === 'edit' && selectedCoord !== undefined) ? selectedCoord : selectedPiece;

        const now = Date.now();
        let animMove = animationRef.current;
        let shake = shakeRef.current;

        if (animMove && now > animMove.startTime + animMove.duration) {
            animMove = null;
            animationRef.current = null;
        }
        if (shake && now > shake.startTime + shake.duration) {
            shake = null;
            shakeRef.current = null;
        }
        
        // 1. Board Background
        ctx.clearRect(0, 0, width, height);
        let grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, '#cbbfa0'); grad.addColorStop(0.2, '#eaddcf'); grad.addColorStop(0.5, '#dcc7aa'); grad.addColorStop(0.8, '#cbbfa0'); grad.addColorStop(1, '#bba98b');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, width, height);

        // 2. Draw Grid Lines
        ctx.strokeStyle = '#3d2b1f'; ctx.lineWidth = 1.5;
        for (let i = 0; i < 10; i++) {
            ctx.beginPath(); ctx.moveTo(offsetX, offsetY + i * gridSize); ctx.lineTo(offsetX + 8 * gridSize, offsetY + i * gridSize); ctx.stroke();
        }
        for (let j = 0; j < 9; j++) {
            if (j === 0 || j === 8) {
                ctx.beginPath(); ctx.moveTo(offsetX + j * gridSize, offsetY); ctx.lineTo(offsetX + j * gridSize, offsetY + 9 * gridSize); ctx.stroke();
            } else {
                ctx.beginPath(); ctx.moveTo(offsetX + j * gridSize, offsetY); ctx.lineTo(offsetX + j * gridSize, offsetY + 4 * gridSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(offsetX + j * gridSize, offsetY + 5 * gridSize); ctx.lineTo(offsetX + j * gridSize, offsetY + 9 * gridSize); ctx.stroke();
            }
        }
        ctx.strokeStyle = '#2a1a10'; ctx.lineWidth = 4; ctx.strokeRect(offsetX - 4, offsetY - 4, 8 * gridSize + 8, 9 * gridSize + 8);
        ctx.lineWidth = 1.5; ctx.strokeStyle = '#3d2b1f';
        
        // Palace
        const drawX = (baseR: number) => {
            const y1 = offsetY + baseR * gridSize;
            const y2 = offsetY + (baseR + 2) * gridSize;
            const x1 = offsetX + 3 * gridSize;
            const x2 = offsetX + 5 * gridSize;
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x2, y1); ctx.lineTo(x1, y2); ctx.stroke();
        };
        drawX(0); 
        drawX(7);

        // 3. Labels
        if (settings?.showCoords !== false) {
            ctx.font = `bold ${gridSize * 0.4}px sans-serif`; ctx.fillStyle = '#000000'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const drawCoords = (y: number, isTop: boolean) => {
                for (let c = 0; c < 9; c++) {
                    let text = '';
                    const logicalC = isMirrored ? (8 - c) : c;
                    let val = 0;
                    if (isFlipped) {
                        if (isTop) { val = logicalC + 1; text = toChineseNum(val); } else { val = logicalC + 1; text = val.toString(); }
                    } else {
                        if (isTop) { val = logicalC + 1; text = val.toString(); } else { val = 9 - logicalC; text = toChineseNum(val); }
                    }
                    ctx.fillText(text, offsetX + c * gridSize, y);
                }
            }
            drawCoords(offsetY - (gridSize * 0.8), true);
            drawCoords(offsetY + (gridSize * 9.8), false);
        }

        // River Text
        ctx.save();
        ctx.font = `bold ${gridSize * 0.6}px "KaiTi", "STKaiti", serif`;
        const riverY = offsetY + 4.5 * gridSize;
        let leftText = "楚 河";
        let rightText = "漢 界";
        if (isFlipped) { leftText = "漢 界"; rightText = "楚 河"; }
        if (isMirrored) { [leftText, rightText] = [rightText, leftText]; }
        ctx.fillText(leftText, offsetX + 2 * gridSize, riverY);
        ctx.fillText(rightText, offsetX + 6 * gridSize, riverY);
        ctx.restore();

        // 4. Markers
        const drawMark = (r: number, c: number) => {
            const v = getVisualPos(r, c);
            const x = offsetX + v.c * gridSize; const y = offsetY + v.r * gridSize; const gap = 4; const len = gridSize * 0.2; ctx.lineWidth = 2;
            const drawCorner = (dx: number, dy: number) => {
                ctx.beginPath(); ctx.moveTo(x + dx * gap, y + dy * (gap + len)); ctx.lineTo(x + dx * gap, y + dy * gap); ctx.lineTo(x + dx * (gap + len), y + dy * gap); ctx.stroke();
            };
            if (v.c > 0) { drawCorner(-1, -1); drawCorner(-1, 1); }
            if (v.c < 8) { drawCorner(1, -1); drawCorner(1, 1); }
        };
        [[2,1], [2,7], [7,1], [7,7], [3,0], [3,2], [3,4], [3,6], [3,8], [6,0], [6,2], [6,4], [6,6], [6,8]].forEach(p => drawMark(p[0], p[1]));

        // 5. Last Move
        if (localState.lastMove && mode === 'play') {
            const { from, to } = localState.lastMove;
            const drawIndicator = (p: Point) => {
                const v = getVisualPos(p.r, p.c);
                ctx.beginPath(); ctx.arc(offsetX + v.c * gridSize, offsetY + v.r * gridSize, gridSize * 0.45, 0, Math.PI * 2);
                ctx.strokeStyle = "rgba(0, 100, 255, 0.5)"; ctx.lineWidth = 4; ctx.stroke();
            };
            drawIndicator(from); drawIndicator(to);
        }

        // Draw Piece Helper
        const drawPiece = (piece: Piece, r: number, c: number, scale: number = 1, offsetXPx: number = 0, offsetYPx: number = 0) => {
            const v = getVisualPos(r, c);
            const centerX = offsetX + v.c * gridSize + offsetXPx;
            const centerY = offsetY + v.r * gridSize + offsetYPx;
            drawPieceAt(piece, centerX, centerY, scale);
        };

        const drawPieceAt = (piece: Piece, x: number, y: number, scale: number = 1) => {
            const PIECE_RADIUS = gridSize * 0.45;
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);
            ctx.shadowBlur = 6; ctx.shadowColor = "rgba(0,0,0,0.4)"; ctx.shadowOffsetY = 4; ctx.shadowOffsetX = 2;
            ctx.beginPath(); ctx.arc(0, 0, PIECE_RADIUS, 0, Math.PI * 2);
            if (piece.color === 'red') {
                ctx.fillStyle = '#fdfdfd'; ctx.fill(); ctx.shadowColor = "transparent";
                ctx.lineWidth = 4; ctx.strokeStyle = '#a61c1c'; ctx.stroke();
                ctx.beginPath(); ctx.arc(0, 0, PIECE_RADIUS - 6, 0, Math.PI * 2); ctx.lineWidth = 1; ctx.strokeStyle = '#e5e5e5'; ctx.stroke();
                ctx.fillStyle = '#a61c1c';
            } else {
                let pGrad = ctx.createRadialGradient(-10, -10, 5, 0, 0, PIECE_RADIUS);
                pGrad.addColorStop(0, '#2563eb'); pGrad.addColorStop(1, '#1e3a8a');
                ctx.fillStyle = pGrad; ctx.fill(); ctx.shadowColor = "transparent";
                ctx.lineWidth = 4; ctx.strokeStyle = '#000000'; ctx.stroke();
                ctx.fillStyle = '#ffffff';
            }
            ctx.font = `bold ${gridSize * 0.65}px 'KaiTi', 'Kaiti SC', 'STKaiti', 'Microsoft JhengHei', serif`;
            ctx.textAlign = "center"; ctx.textBaseline = "middle";
            ctx.fillText(piece.text, 0, (gridSize * 0.01));
            ctx.restore();
        }

        // 6. Draw Pieces
        for (let r = 0; r < 10; r++) {
            for (let c = 0; c < 9; c++) {
                const piece = board[r][c];
                if (!piece) continue;
                if (animMove && r === animMove.to.r && c === animMove.to.c) continue;

                let shakeOffsetX = 0;
                let shakeOffsetY = 0;
                if (shake && shake.r === r && shake.c === c) {
                     const shakeProgress = (now - shake.startTime) / shake.duration;
                     if (shakeProgress >= 0 && shakeProgress <= 1) {
                         const intensity = (1 - shakeProgress) * gridSize * 0.15;
                         shakeOffsetX = (Math.random() - 0.5) * intensity;
                         shakeOffsetY = (Math.random() - 0.5) * intensity;
                     }
                }
                drawPiece(piece, r, c, 1, shakeOffsetX, shakeOffsetY);
            }
        }

        // 7. Draw Moving Piece
        if (animMove) {
            const progress = Math.min(1, (now - animMove.startTime) / animMove.duration);
            const eased = easeOutCubic(progress);
            const vFrom = getVisualPos(animMove.from.r, animMove.from.c);
            const vTo = getVisualPos(animMove.to.r, animMove.to.c);
            const startX = offsetX + vFrom.c * gridSize;
            const startY = offsetY + vFrom.r * gridSize;
            const endX = offsetX + vTo.c * gridSize;
            const endY = offsetY + vTo.r * gridSize;
            const currentX = startX + (endX - startX) * eased;
            const currentY = startY + (endY - startY) * eased;
            let scale = 1;
            if (animMove.isCannonCapture) {
                scale = 1 + Math.sin(progress * Math.PI) * 0.5;
            }
            drawPieceAt(animMove.piece, currentX, currentY, scale);
        }
        
        // Active Selection
        if (activeSelection) {
            const v = getVisualPos(activeSelection.r, activeSelection.c);
            ctx.save();
            ctx.beginPath(); 
            ctx.arc(offsetX + v.c * gridSize, offsetY + v.r * gridSize, gridSize * 0.48, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(34, 197, 94, 0.9)"; 
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
        }

        // 8. Hints
        if (activeSelection && mode === 'play') {
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    if (canMove(board, activeSelection.r, activeSelection.c, r, c)) {
                         const v = getVisualPos(r, c);
                         const targetP = board[r][c];
                         ctx.beginPath();
                         if (targetP) {
                            ctx.arc(offsetX + v.c * gridSize, offsetY + v.r * gridSize, gridSize * 0.48, 0, Math.PI * 2);
                            ctx.strokeStyle = "rgba(168, 85, 247, 0.9)"; 
                            ctx.lineWidth = 4; 
                            ctx.stroke();
                         } else {
                            ctx.arc(offsetX + v.c * gridSize, offsetY + v.r * gridSize, gridSize * 0.12, 0, Math.PI * 2);
                            ctx.fillStyle = "rgba(22, 163, 74, 0.8)"; ctx.fill();
                         }
                    }
                }
            }
        }

        // 9. Hint Effect (Moved here to draw ON TOP of pieces)
        if (hintMove) {
            const { from } = hintMove; // Only use 'from'
            const pulse = (Math.sin(now / 150) + 1) / 2; // 0 to 1 oscillating
            const alphaFill = 0.3 + 0.2 * pulse;
            const alphaStroke = 0.6 + 0.4 * pulse;

            // Draw Source Highlight ONLY
            const vFrom = getVisualPos(from.r, from.c);
            const xF = offsetX + vFrom.c * gridSize;
            const yF = offsetY + vFrom.r * gridSize;
            
            ctx.save();
            ctx.beginPath();
            ctx.arc(xF, yF, gridSize * 0.48, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 215, 0, ${alphaFill})`; // Pulsing Gold
            ctx.fill();
            ctx.strokeStyle = `rgba(255, 215, 0, ${alphaStroke})`;
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
        }

        // 10. Player Names
        if (settings?.showPlayerNames !== false) {
            const drawVerticalText = (text: string, x: number, startY: number, size: number) => {
                 const lineHeight = size * 1.1;
                 for (let i = 0; i < text.length; i++) { ctx.fillText(text[i], x, startY + i * lineHeight); }
            };
            const drawPlayerName = (name: string, isTop: boolean, color: string) => {
                if (!name) return;
                ctx.save(); ctx.fillStyle = color; ctx.shadowColor = "rgba(255, 255, 255, 0.3)"; ctx.shadowBlur = 4; ctx.textBaseline = "middle";
                const isWideLayout = offsetX > gridSize * 1.2;
                if (isWideLayout) {
                    const x = width - (offsetX / 2);
                    const fontSize = gridSize * 0.55;
                    const topCenterY = offsetY + gridSize * 2.0;
                    const bottomCenterY = offsetY + gridSize * 7.0;
                    const textHeight = (name.length - 1) * (fontSize * 1.1);
                    const startYOffset = textHeight / 2;
                    const y = isTop ? topCenterY - startYOffset : bottomCenterY - startYOffset;
                    ctx.font = `bold ${fontSize}px "KaiTi", "STKaiti", serif`; ctx.textAlign = "center";
                    drawVerticalText(name, x, y, fontSize);
                } else {
                    const fontSize = gridSize * 0.5;
                    ctx.font = `bold ${fontSize}px "KaiTi", "STKaiti", serif`; ctx.textAlign = "center";
                    const x = width / 2;
                    const bottomMarginStart = offsetY + 9 * gridSize;
                    const bottomMarginHeight = height - bottomMarginStart;
                    let y = 0;
                    if (isTop) {
                        y = offsetY * 0.2; 
                    } else {
                        y = height - (bottomMarginHeight * 0.2);
                    }
                    ctx.fillText(name, x, y);
                }
                ctx.restore();
            };
            const topName = isFlipped ? redName : blackName;
            const bottomName = isFlipped ? blackName : redName;
            const topColor = isFlipped ? '#a61c1c' : '#000000';
            const bottomColor = isFlipped ? '#000000' : '#a61c1c';
            if (topName) drawPlayerName(topName, true, topColor);
            if (bottomName) drawPlayerName(bottomName, false, bottomColor);
        }
        requestRef.current = requestAnimationFrame(renderFrame);
    };

    useEffect(() => {
        requestRef.current = requestAnimationFrame(renderFrame);
        return () => {
            if (requestRef.current) cancelAnimationFrame(requestRef.current);
        };
    }, [localState, dimensions, isFlipped, isMirrored, redName, blackName, mode, selectedCoord, settings, hintMove]);

    const handleCanvasClick = (e: React.MouseEvent<HTMLCanvasElement>) => {
        if (e.button !== 0) return;
        const rect = canvasRef.current!.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const { gridSize, offsetX, offsetY } = dimensions;
        const vc = Math.round((x - offsetX) / gridSize);
        const vr = Math.round((y - offsetY) / gridSize);
        if (vr < 0 || vr > 9 || vc < 0 || vc > 8) return;
        const { r, c } = getLogicalPos(vr, vc);

        if (mode === 'edit') {
            if (onSquareClick) onSquareClick({ r, c }, rect); 
            return;
        }

        const { board, selectedPiece, turn } = localState;
        if (selectedPiece) {
            if (canMove(board, selectedPiece.r, selectedPiece.c, r, c)) {
                if (onMoveMade) {
                    const newBoard = board.map(row => [...row]);
                    const movedPiece = newBoard[selectedPiece.r][selectedPiece.c]!;
                    const targetPiece = newBoard[r][c];
                    const notation = getChineseNotation(board, { from: selectedPiece, to: {r,c}, piece: movedPiece, captured: targetPiece });
                    newBoard[r][c] = movedPiece;
                    newBoard[selectedPiece.r][selectedPiece.c] = null;
                    const accepted = onMoveMade({
                        from: selectedPiece,
                        to: {r,c},
                        piece: movedPiece,
                        captured: targetPiece,
                        notation: notation
                    }, newBoard);
                    if (accepted !== false) {
                        setLocalState(prev => ({
                            ...prev,
                            board: newBoard,
                            turn: turn === 'red' ? 'black' : 'red',
                            selectedPiece: null,
                            lastMove: { from: selectedPiece, to: {r, c} },
                        }));
                    }
                }
            } else {
                if (board[r][c] && board[r][c]?.color === turn) {
                    setLocalState(prev => ({ ...prev, selectedPiece: {r, c} }));
                } else {
                    setLocalState(prev => ({ ...prev, selectedPiece: null }));
                }
            }
        } else {
            if (board[r][c] && board[r][c]?.color === turn) {
                 setLocalState(prev => ({ ...prev, selectedPiece: {r, c} }));
            }
        }
    };

    const handleContainerContextMenu = (e: React.MouseEvent) => e.preventDefault();
    const handleContainerMouseDown = (e: React.MouseEvent) => {
        if (e.button !== 2) return;
        e.preventDefault();
        const rect = containerRef.current!.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const start = getLogicalFromPixel(x, y);
        if (start) setDragArrow({ start, current: {x, y} });
    };
    const handleContainerMouseMove = (e: React.MouseEvent) => {
        if (dragArrow) {
             const rect = containerRef.current!.getBoundingClientRect();
             const x = e.clientX - rect.left;
             const y = e.clientY - rect.top;
             setDragArrow(prev => prev ? { ...prev, current: {x, y} } : null);
        }
    };
    const handleContainerMouseUp = (e: React.MouseEvent) => {
        if (dragArrow) {
            const rect = containerRef.current!.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const end = getLogicalFromPixel(x, y);
            if (end && (end.r !== dragArrow.start.r || end.c !== dragArrow.start.c)) {
                setManualArrows(prev => {
                    const exists = prev.findIndex(a => 
                        a.from.r === dragArrow.start.r && a.from.c === dragArrow.start.c &&
                        a.to.r === end.r && a.to.c === end.c
                    );
                    if (exists !== -1) return prev.filter((_, i) => i !== exists);
                    else return [...prev, { from: dragArrow.start, to: end }];
                });
            }
            setDragArrow(null);
        }
    };

    const RenderVariationArrows = () => {
        if (settings?.showVariationArrows === false) return null;
        if (!currentNode || !currentNode.children || currentNode.children.length <= 1) return null;

        const arrowData = currentNode.children.map((child, idx) => {
            if (!child.move) return null;
            const fromPos = getPixelPos(child.move.from.r, child.move.from.c);
            const toPos = getPixelPos(child.move.to.r, child.move.to.c);
            const originalIdx = currentNode.children!.findIndex(c => c.id === child.id);
            const label = String.fromCharCode(65 + originalIdx); 
            const dx = toPos.x - fromPos.x;
            const dy = toPos.y - fromPos.y;
            const angle = Math.atan2(dy, dx); 
            const angleDeg = angle * (180 / Math.PI);
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // 更細緻的箭頭樣式
            const headLength = 20; // Reduced from 40
            const headWidth = 14;  // Reduced from 28
            const shaftWidth = 5;  // Reduced from 14
            const notchDepth = 4;  // Reduced from 8
            const overlap = 0.5;

            const shaftEnd = Math.max(0, dist - headLength + notchDepth + overlap);
            const shaftPath = `M 0,${-shaftWidth/2} L ${shaftEnd},${-shaftWidth/2} L ${shaftEnd},${shaftWidth/2} L 0,${shaftWidth/2} Z`;

            const headBackX = dist - headLength;
            const headTipX = dist;
            const headStartFillX = headBackX + notchDepth - overlap; 
            const headPath = `M ${headStartFillX},${-shaftWidth/2} L ${headBackX},${-headWidth/2} L ${headTipX},0 L ${headBackX},${headWidth/2} L ${headStartFillX},${shaftWidth/2} Z`;
            
            const outlinePath = `M 0,${-shaftWidth/2} L ${headBackX + notchDepth},${-shaftWidth/2} L ${headBackX},${-headWidth/2} L ${headTipX},0 L ${headBackX},${headWidth/2} L ${headBackX + notchDepth},${shaftWidth/2} L 0,${shaftWidth/2}`;

            const badgeOffsetFromTip = headLength * 0.8; 
            const badgeDist = dist - badgeOffsetFromTip;
            const badgeX = fromPos.x + Math.cos(angle) * badgeDist;
            const badgeY = fromPos.y + Math.sin(angle) * badgeDist;

            return {
                id: child.id,
                child,
                fromPos,
                angleDeg,
                shaftPath,
                headPath,
                outlinePath,
                badgeX,
                badgeY,
                label,
                isHovered: hoveredVariationId === child.id
            };
        }).filter(item => item !== null) as NonNullable<ReturnType<typeof arrowData[0]>>[];

        arrowData.sort((a, b) => (a.isHovered ? 1 : 0) - (b.isHovered ? 1 : 0));

        return (
            <>
                {arrowData.map((arrow) => {
                    const { id, child, fromPos, angleDeg, shaftPath, headPath, outlinePath, badgeX, badgeY, label, isHovered } = arrow;
                    const opacity = isHovered ? 1 : 0.7; // Slightly increased opacity for visibility since they are smaller
                    const headColor = "rgba(59, 130, 246, 0.9)";
                    const strokeColor = "rgba(59, 130, 246, 1)";
                    
                    return (
                        <g 
                            key={id} 
                            onClick={(e) => { 
                                e.stopPropagation(); 
                                e.preventDefault();
                                const isPieceSelected = localState.selectedPiece !== null || (mode === 'edit' && selectedCoord != null);
                                if (isPieceSelected) return;
                                if (onNodeSelect) onNodeSelect(child); 
                            }} 
                            onMouseEnter={() => setHoveredVariationId(id)}
                            onMouseLeave={() => setHoveredVariationId(null)}
                            className="cursor-pointer transition-all duration-200 variation-arrow-group"
                            style={{ opacity }}
                            pointerEvents="all"
                        >
                            <g transform={`translate(${fromPos.x}, ${fromPos.y}) rotate(${angleDeg})`}>
                                <g mask={`url(#${maskId})`}>
                                    <path d={shaftPath} fill={`url(#${patternId})`} stroke="none" />
                                    <path d={outlinePath} fill="none" stroke={strokeColor} strokeWidth="1.5" strokeLinejoin="round" strokeLinecap="round" />
                                </g>
                                <path d={headPath} fill={headColor} stroke="none" />
                            </g>
                            {/* Smaller badge */}
                            <circle cx={badgeX} cy={badgeY} r={8} fill="white" stroke="#3b82f6" strokeWidth="2" />
                            <text x={badgeX} y={badgeY} dy="0.35em" textAnchor="middle" fontSize="10" fontWeight="bold" fill="#3b82f6" style={{ pointerEvents: 'none' }}>
                                {label}
                            </text>
                        </g>
                    );
                })}
            </>
        );
    };

    const RenderManualArrows = () => {
        return (
            <>
                {manualArrows.map((arrow, idx) => {
                    const fromPos = getPixelPos(arrow.from.r, arrow.from.c);
                    const toPos = getPixelPos(arrow.to.r, arrow.to.c);
                    return (
                        <line 
                            key={idx}
                            x1={fromPos.x} y1={fromPos.y} 
                            x2={toPos.x} y2={toPos.y} 
                            stroke="#22c55e" 
                            strokeWidth="8" 
                            strokeOpacity="0.8"
                            strokeLinecap="round"
                            markerEnd={`url(#${markerGreenId})`}
                        />
                    );
                })}
                {dragArrow && (
                    <line 
                        x1={getPixelPos(dragArrow.start.r, dragArrow.start.c).x} 
                        y1={getPixelPos(dragArrow.start.r, dragArrow.start.c).y} 
                        x2={dragArrow.current.x} 
                        y2={dragArrow.current.y} 
                        stroke="#22c55e" 
                        strokeWidth="8" 
                        strokeOpacity="0.5"
                        strokeLinecap="round"
                        markerEnd={`url(#${markerGreenId})`}
                    />
                )}
            </>
        );
    };

    return (
        <div 
            ref={containerRef} 
            className="w-full h-full flex justify-center items-center overflow-hidden bg-[#2a2a2e] rounded-lg shadow-2xl border border-zinc-700 select-none relative"
            onContextMenu={handleContainerContextMenu}
            onMouseDown={handleContainerMouseDown}
            onMouseMove={handleContainerMouseMove}
            onMouseUp={handleContainerMouseUp}
            onMouseLeave={() => setDragArrow(null)}
        >
            <canvas 
                ref={canvasRef}
                width={dimensions.width}
                height={dimensions.height}
                onClick={handleCanvasClick}
                className="cursor-pointer touch-none z-10"
            />

            <svg 
                className="absolute inset-0 w-full h-full pointer-events-none z-20"
                viewBox={`0 0 ${dimensions.width} ${dimensions.height}`}
            >
                <defs>
                    <marker id={markerBlueId} markerWidth="4" markerHeight="4" refX="3.5" refY="2" orient="auto">
                        <polygon points="0 0, 4 2, 0 4" fill="#3b82f6" fillOpacity="0.7" />
                    </marker>
                    <marker id={markerGreenId} markerWidth="3" markerHeight="3" refX="2.5" refY="1.5" orient="auto">
                        <polygon points="0 0, 3 1.5, 0 3" fill="#22c55e" fillOpacity="0.8" />
                    </marker>

                    <linearGradient id={gradientId} gradientUnits="objectBoundingBox" x1="0" y1="0" x2="1" y2="0">
                        <stop offset="0" stopColor="white" stopOpacity="0" />
                        <stop offset="0.15" stopColor="white" stopOpacity="1" />
                    </linearGradient>

                    {/* CORRECT FIX: maskContentUnits="objectBoundingBox" to make rect 0..1 relative to target bbox */}
                    <mask id={maskId} maskUnits="objectBoundingBox" maskContentUnits="objectBoundingBox">
                        <rect x="0" y="0" width="1" height="1" fill={`url(#${gradientId})`} />
                    </mask>

                    <pattern id={patternId} x="0" y="0" width="20" height="20" patternUnits="userSpaceOnUse">
                         <path d="M 10 0 L 0 10 L 10 20" fill="none" stroke="rgba(255,255,255,0.8)" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                         <animateTransform attributeName="patternTransform" type="translate" from="0 0" to="20 0" dur="1.5s" repeatCount="indefinite" />
                         <rect width="20" height="20" fill="rgba(59, 130, 246, 0.4)" />
                    </pattern>
                </defs>
                
                <RenderManualArrows />
                <RenderVariationArrows />
            </svg>

            {activeFlashes.map(flash => {
                 const { gridSize, offsetX, offsetY } = dimensions;
                 if (dimensions.width === 0) return null;
                 const v = getVisualPos(flash.r, flash.c);
                 return (
                     <div 
                        key={flash.id}
                        className="absolute flex items-center justify-center text-red-600 font-bold z-30 pointer-events-none animate-ping-fade"
                        style={{
                            top: offsetY + v.r * gridSize,
                            left: offsetX + v.c * gridSize,
                            width: gridSize,
                            height: gridSize,
                            transform: 'translate(-50%, -50%)',
                            fontSize: gridSize * 0.8
                        }}
                     >
                        ✖
                     </div>
                 );
            })}
            
            <style>{`
                @keyframes ping-fade {
                    0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
                }
                .animate-ping-fade {
                    animation: ping-fade 0.8s ease-out forwards;
                }
                .variation-arrow-group:hover {
                    z-index: 100;
                }
            `}</style>
        </div>
    );
};

export default ChessBoard;


==============================
File Path: components\CloudPanel.tsx
==============================

import React, { useState, useEffect } from 'react';
import { Cloud, Activity, RefreshCw, WifiOff, BarChart2 } from 'lucide-react';
import { Point, Piece, CloudMove } from '../types';
import { getChineseNotation, ucciToCoords, fetchCloudBookData } from '../lib/utils';

interface CloudPanelProps {
    currentFen: string;
    currentBoard: (Piece | null)[][];
    onMoveClick: (move: { from: Point; to: Point }) => void;
    onOpenAnalysis: () => void;
    isEnabled: boolean; // 新增：由父組件控制
    onToggleEnabled: (enabled: boolean) => void; // 新增：切換回調
}

const CloudPanel: React.FC<CloudPanelProps> = ({ 
    currentFen, 
    currentBoard, 
    onMoveClick, 
    onOpenAnalysis,
    isEnabled,
    onToggleEnabled
}) => {
    // 移除內部的 isEnabled 狀態，改用 props
    const [loading, setLoading] = useState(false);
    const [moves, setMoves] = useState<CloudMove[]>([]);
    const [error, setError] = useState<string | null>(null);

    const getMoveDisplayName = (ucci: string) => {
        try {
            const coords = ucciToCoords(ucci);
            if (!coords) return ucci;
            const { from, to } = coords;
            if (from.r < 0 || from.r > 9 || from.c < 0 || from.c > 8) return ucci;
            const piece = currentBoard[from.r][from.c];
            if (!piece) return ucci; 
            const captured = currentBoard[to.r][to.c];
            return getChineseNotation(currentBoard, { from, to, piece, captured });
        } catch (e) { return ucci; }
    };

    const loadData = async (fen: string) => {
        if (!isEnabled) return;
        setLoading(true);
        setError(null);
        try {
            const data = await fetchCloudBookData(fen);
            setMoves(data);
        } catch (err) {
            setError('無法連接至雲庫 API');
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => { if (isEnabled) loadData(currentFen); }, [currentFen, isEnabled]);

    const getScoreColor = (score: number) => {
        if (score > 150) return 'text-red-400 font-bold';
        if (score < -150) return 'text-green-400 font-bold';
        return 'text-zinc-400';
    };

    return (
        <div className="flex flex-col h-full bg-zinc-900 border-zinc-800 w-full overflow-hidden">
             {/* Header */}
             <div className="px-4 py-3 border-b border-zinc-800 bg-zinc-900 flex justify-between items-center shrink-0">
                <h3 className="font-bold text-zinc-200 flex items-center gap-2">
                    <span className="w-1.5 h-5 bg-blue-600 rounded-full"></span>
                    雲庫分析
                </h3>
                <button 
                    onClick={onOpenAnalysis}
                    className="flex items-center gap-1 text-[10px] bg-indigo-900/40 hover:bg-indigo-800/60 text-indigo-200 border border-indigo-700/50 px-2 py-1 rounded transition-all"
                >
                    <BarChart2 size={12} /> 全盤分析
                </button>
            </div>

            <div className="p-4 border-b border-zinc-800 shrink-0">
                {!isEnabled ? (
                    <button 
                        onClick={() => onToggleEnabled(true)}
                        className="w-full py-3 bg-blue-600 hover:bg-blue-500 text-white rounded-lg flex items-center justify-center gap-2 font-bold shadow-lg transition-all active:scale-95"
                    >
                        <Activity size={18} /> 連線並分析
                    </button>
                ) : (
                    <div className="flex gap-2">
                         <button 
                            onClick={() => loadData(currentFen)}
                            disabled={loading}
                            className="flex-1 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded-lg flex items-center justify-center gap-2 text-sm border border-zinc-700 transition-colors"
                        >
                            <RefreshCw size={14} className={loading ? 'animate-spin' : ''} /> 刷新
                        </button>
                        <button 
                            onClick={() => onToggleEnabled(false)}
                            className="px-3 py-2 bg-zinc-800 hover:bg-red-900/40 text-zinc-400 hover:text-red-400 rounded-lg border border-zinc-700 transition-colors"
                        >
                            <WifiOff size={16} />
                        </button>
                    </div>
                )}
            </div>

            <div className="flex-1 overflow-y-auto bg-zinc-950 relative min-h-0">
                {!isEnabled ? (
                    <div className="h-full flex flex-col items-center justify-center p-8 text-center gap-4 opacity-50">
                        <Cloud size={48} className="text-zinc-700" />
                        <p className="text-zinc-500 text-sm leading-relaxed">點擊「連線並分析」<br/>從 ChessDB 獲取即時大數據</p>
                    </div>
                ) : loading ? (
                    <div className="flex flex-col items-center justify-center h-40 gap-3 text-zinc-500">
                        <RefreshCw size={24} className="animate-spin text-blue-500" />
                        <span className="text-xs font-medium">查詢中...</span>
                    </div>
                ) : moves.length === 0 ? (
                    <div className="p-10 text-center text-zinc-600 italic text-sm">此局面無雲庫紀錄</div>
                ) : (
                    <table className="w-full text-left border-collapse text-sm">
                        <thead className="bg-zinc-900 text-zinc-500 font-bold sticky top-0 z-10 text-[10px] uppercase tracking-wider">
                            <tr>
                                <th className="px-4 py-2 border-b border-zinc-800">招法</th>
                                <th className="px-2 py-2 border-b border-zinc-800 text-right">分數</th>
                                <th className="px-2 py-2 border-b border-zinc-800 text-right">勝率</th>
                                <th className="px-4 py-2 border-b border-zinc-800">備註</th>
                            </tr>
                        </thead>
                        <tbody className="divide-y divide-zinc-800/30">
                            {moves.map((m, idx) => (
                                <tr 
                                    key={idx} 
                                    onClick={() => onMoveClick(ucciToCoords(m.move)!)}
                                    className="hover:bg-blue-900/10 cursor-pointer transition-colors"
                                >
                                    <td className="px-4 py-2.5 font-bold text-zinc-300">{getMoveDisplayName(m.move)}</td>
                                    <td className={`px-2 py-2.5 text-right font-mono ${getScoreColor(m.score)}`}>{m.score}</td>
                                    <td className="px-2 py-2.5 text-right text-zinc-500 text-xs">{m.winrate}%</td>
                                    <td className="px-4 py-2.5 text-[10px] text-zinc-600 max-w-[80px] truncate">{m.note}</td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                )}
            </div>
        </div>
    );
};

export default CloudPanel;


==============================
File Path: components\ControlBar.tsx
==============================

import React, { useState, useEffect, useRef } from 'react';
import { 
  SkipBack, 
  ChevronLeft, 
  Play, 
  Pause,
  ChevronRight, 
  Crosshair, 
  ArrowUpDown, 
  ArrowLeftRight,
  CornerUpLeft,
  CornerUpRight,
  FastForward,
  Rewind,
  X
} from 'lucide-react';

interface ControlBarProps {
  onNavigate: (dir: 'prev' | 'next' | 'start' | 'end') => void;
  onNavigateVariation: (dir: 'prev' | 'next') => void;
  onJumpToStep: (index: number) => void;
  onFlip: () => void;
  onMirror: () => void;
  currentIndex: number;
  totalSteps: number;
  disabled?: boolean;
}

const ControlBar: React.FC<ControlBarProps> = ({ 
  onNavigate, 
  onNavigateVariation,
  onJumpToStep,
  onFlip, 
  onMirror,
  currentIndex,
  totalSteps,
  disabled = false
}) => {
  const [showJumpMenu, setShowJumpMenu] = useState(false);
  const [showSeekOverlay, setShowSeekOverlay] = useState(false);
  const [isPlaying, setIsPlaying] = useState(false);
  const [seekValue, setSeekValue] = useState(currentIndex);
  
  // Refs for click outside
  const jumpMenuRef = useRef<HTMLDivElement>(null);

  // Sync seek value
  useEffect(() => {
    setSeekValue(currentIndex);
  }, [currentIndex]);

  // Playback Logic
  useEffect(() => {
    let interval: number;
    if (isPlaying) {
      interval = window.setInterval(() => {
        if (currentIndex < totalSteps - 1) {
          onNavigate('next');
        } else {
          setIsPlaying(false);
        }
      }, 1500); 
    }
    return () => clearInterval(interval);
  }, [isPlaying, currentIndex, totalSteps, onNavigate]);

  // Click Outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (jumpMenuRef.current && !jumpMenuRef.current.contains(event.target as Node)) {
        setShowJumpMenu(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const btnClass = `relative flex flex-col items-center justify-center p-1 md:p-2 rounded-lg bg-zinc-800 border border-zinc-700 shadow-md group transition-all 
      ${disabled ? 'opacity-30 cursor-not-allowed text-zinc-500' : 'hover:bg-zinc-700 active:scale-95 text-zinc-300 hover:text-white'}`;
  
  const labelClass = "text-[9px] md:text-[10px] mt-0.5 md:mt-1 font-medium opacity-70 group-hover:opacity-100 whitespace-nowrap";
  const iconSize = 18;

  const handleAction = (action: () => void) => {
      if (!disabled) action();
  };

  // Custom Slider Rendering Logic
  const maxVal = Math.max(1, totalSteps - 1);
  const progressPercent = (seekValue / maxVal) * 100;

  return (
    <div className="w-full relative z-30">
        
        {/* Jump Menu Popover (Upwards) */}
        {showJumpMenu && !disabled && (
            <div ref={jumpMenuRef} className="absolute bottom-full left-0 mb-3 bg-zinc-900 border border-zinc-700 rounded-lg shadow-2xl p-2 w-48 flex flex-col gap-1 z-50 animate-in fade-in slide-in-from-bottom-2">
                <button onClick={() => { onNavigate('start'); setShowJumpMenu(false); }} className="flex items-center gap-2 px-3 py-2 hover:bg-zinc-800 rounded text-sm text-zinc-300">
                    <Rewind size={16} /> 初始局面 (0)
                </button>
                <button onClick={() => { onNavigate('end'); setShowJumpMenu(false); }} className="flex items-center gap-2 px-3 py-2 hover:bg-zinc-800 rounded text-sm text-zinc-300">
                    <FastForward size={16} /> 最後局面
                </button>
                <div className="h-px bg-zinc-800 my-1"></div>
                <button onClick={() => { onNavigateVariation('prev'); setShowJumpMenu(false); }} className="flex items-center gap-2 px-3 py-2 hover:bg-zinc-800 rounded text-sm text-zinc-300">
                    <CornerUpLeft size={16} /> 上個變著
                </button>
                <button onClick={() => { onNavigateVariation('next'); setShowJumpMenu(false); }} className="flex items-center gap-2 px-3 py-2 hover:bg-zinc-800 rounded text-sm text-zinc-300">
                    <CornerUpRight size={16} /> 下個變著
                </button>
            </div>
        )}

        <div className="relative bg-zinc-900 border-t md:border-t-0 md:border md:rounded-xl border-zinc-700 shadow-lg overflow-hidden min-h-[64px]">
            
            {/* 1. Main Control Buttons Grid */}
            <div className={`grid grid-cols-7 gap-1 md:gap-2 px-2 py-2 md:py-3 transition-opacity duration-300 ${showSeekOverlay ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}>
                {/* 1. Jump (Menu) */}
                <button 
                    className={`${btnClass} ${showJumpMenu ? 'bg-zinc-700 text-white border-zinc-500' : ''}`} 
                    onClick={(e) => { e.stopPropagation(); if (!disabled) setShowJumpMenu(!showJumpMenu); }}
                    title="跳轉選單"
                    disabled={disabled}
                >
                    <SkipBack size={iconSize} />
                    <span className={labelClass}>跳轉</span>
                </button>

                {/* 2. Prev */}
                <button 
                    className={btnClass} 
                    onClick={() => handleAction(() => onNavigate('prev'))}
                    disabled={disabled || currentIndex <= 0}
                    title="上一步"
                >
                    <ChevronLeft size={iconSize} />
                    <span className={labelClass}>上一步</span>
                </button>

                {/* 3. Play/Pause */}
                <button 
                    className={`${btnClass} ${isPlaying ? 'bg-indigo-900/50 border-indigo-700 text-indigo-200' : ''}`} 
                    onClick={() => handleAction(() => setIsPlaying(!isPlaying))}
                    title={isPlaying ? "暫停" : "播放"}
                    disabled={disabled}
                >
                    {isPlaying ? <Pause size={iconSize} fill="currentColor" /> : <Play size={iconSize} fill="currentColor" />}
                    <span className={labelClass}>{isPlaying ? "暫停" : "播放"}</span>
                </button>

                {/* 4. Next */}
                <button 
                    className={btnClass} 
                    onClick={() => handleAction(() => onNavigate('next'))}
                    disabled={disabled || currentIndex >= totalSteps - 1}
                    title="下一步"
                >
                    <ChevronRight size={iconSize} />
                    <span className={labelClass}>下一步</span>
                </button>

                {/* 5. Locate (Slider) - Opens Overlay */}
                <button 
                    className={btnClass}
                    onClick={(e) => { e.stopPropagation(); if (!disabled) setShowSeekOverlay(true); }}
                    title="定位回合"
                    disabled={disabled}
                >
                    <Crosshair size={iconSize} />
                    <span className={labelClass}>定位</span>
                </button>

                {/* 6. Flip V */}
                <button className={btnClass} onClick={onFlip} title="上下翻轉">
                    <ArrowUpDown size={iconSize} />
                    <span className={labelClass}>翻轉</span>
                </button>

                {/* 7. Flip H */}
                <button className={btnClass} onClick={onMirror} title="左右翻轉 (鏡像)">
                    <ArrowLeftRight size={iconSize} />
                    <span className={labelClass}>鏡像</span>
                </button>
            </div>

            {/* 2. Seek Bar Overlay (Covers Buttons) */}
            {showSeekOverlay && !disabled && (
                 <div className="absolute inset-0 z-10 bg-zinc-900/95 backdrop-blur-md flex items-center px-4 gap-4 animate-in fade-in slide-in-from-bottom-2">
                    
                    {/* Current Step Display */}
                    <div className="flex flex-col items-center justify-center min-w-[3rem]">
                        <span className="text-[10px] text-zinc-500 font-bold uppercase tracking-wider">Turn</span>
                        <span className="text-xl font-black text-blue-400 font-mono leading-none drop-shadow-lg">{seekValue}</span>
                    </div>

                    {/* Custom Fancy Slider */}
                    <div className="flex-1 relative h-8 flex items-center group">
                        {/* Native Input (Invisible but interactive) */}
                        <input 
                            type="range" 
                            min="0" 
                            max={maxVal} 
                            value={seekValue}
                            onChange={(e) => {
                                const val = parseInt(e.target.value);
                                setSeekValue(val);
                                onJumpToStep(val);
                            }}
                            className="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-20"
                        />
                        
                        {/* Visual Track Background */}
                        <div className="w-full h-1.5 bg-zinc-800 rounded-full overflow-hidden relative">
                            {/* Filled Part (Left) - Gradient */}
                            <div 
                                className="h-full bg-gradient-to-r from-blue-600 via-cyan-500 to-blue-400 shadow-[0_0_10px_rgba(59,130,246,0.5)]"
                                style={{ width: `${progressPercent}%` }}
                            ></div>
                        </div>

                        {/* Visual Thumb */}
                        <div 
                            className="absolute h-4 w-4 bg-white rounded-full shadow-[0_0_15px_rgba(255,255,255,0.8)] border-2 border-blue-500 pointer-events-none transition-transform duration-75 ease-out z-10"
                            style={{ left: `calc(${progressPercent}% - 8px)` }}
                        >
                            <div className="absolute inset-0 bg-blue-400 rounded-full opacity-20 animate-ping"></div>
                        </div>
                    </div>

                    {/* Max Step */}
                    <div className="text-[10px] text-zinc-500 font-mono font-bold min-w-[2rem] text-right">
                        /{maxVal}
                    </div>

                    {/* Close Button */}
                    <button 
                        onClick={() => setShowSeekOverlay(false)} 
                        className="p-2 -mr-2 text-zinc-500 hover:text-white hover:bg-zinc-800 rounded-full transition-colors"
                    >
                        <X size={20} />
                    </button>
                 </div>
            )}
        </div>
    </div>
  );
};

export default ControlBar;


==============================
File Path: components\ExportModal.tsx
==============================

import React, { useState, useEffect } from 'react';
import { X, Copy, Download, Check } from 'lucide-react';
import { MoveNode, GameMetadata } from '../types';
import { Exporter } from '../lib/exporter';

interface ExportModalProps {
    isOpen: boolean;
    onClose: () => void;
    rootNode: MoveNode;
    metadata: GameMetadata;
}

type ExportFormat = 'DhtmlXQ' | 'Text' | 'FenMove' | 'PGN';

const ExportModal: React.FC<ExportModalProps> = ({ isOpen, onClose, rootNode, metadata }) => {
    const [format, setFormat] = useState<ExportFormat>('DhtmlXQ');
    const [content, setContent] = useState('');
    const [copied, setCopied] = useState(false);

    useEffect(() => {
        if (!isOpen) return;
        let generated = '';
        try {
            switch (format) {
                case 'DhtmlXQ': generated = Exporter.generateDhtmlXQ(rootNode, metadata); break;
                case 'Text': generated = Exporter.generateText(rootNode, metadata); break;
                case 'FenMove': generated = Exporter.generateFenMove(rootNode); break;
                case 'PGN': generated = Exporter.generatePGN(rootNode, metadata); break;
            }
        } catch (e) {
            console.error("Export generation failed:", e);
            generated = "Error generating export.";
        }
        setContent(generated);
        setCopied(false);
    }, [isOpen, format, rootNode, metadata]);

    if (!isOpen) return null;

    const handleCopy = (text: string) => {
        navigator.clipboard.writeText(text);
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
    };

    const handleDownload = () => {
        const blob = new Blob([content], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const filename = (metadata.title || 'chess_game').replace(/\s+/g, '_');
        a.download = `${filename}.pgn`; 
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-full max-w-xl mx-4 flex flex-col max-h-[90vh]">
                <div className="px-6 py-4 border-b border-zinc-800 flex justify-between items-center bg-zinc-900">
                    <h2 className="text-lg font-bold text-white flex items-center gap-2">
                        <UploadIcon className="text-blue-500" /> 分享棋譜
                    </h2>
                    <button onClick={onClose} className="text-zinc-500 hover:text-white"><X size={20} /></button>
                </div>

                <div className="p-6 space-y-6 overflow-y-auto">
                    <div className="space-y-2">
                        <label className="text-sm font-bold text-zinc-400">當前局面 FEN</label>
                        <div className="flex gap-2">
                            <input 
                                type="text" 
                                readOnly 
                                value={rootNode.fen} 
                                className="flex-1 bg-zinc-950 border border-zinc-700 rounded px-3 py-2 text-xs font-mono text-zinc-300 focus:outline-none"
                            />
                            <button 
                                onClick={() => handleCopy(rootNode.fen)}
                                className="px-3 bg-blue-600 hover:bg-blue-500 text-white rounded flex items-center justify-center"
                            >
                                <Copy size={16} />
                            </button>
                        </div>
                    </div>

                    <div className="border-t border-zinc-800 my-2"></div>

                    <div className="flex justify-between items-center">
                        <label className="text-sm font-bold text-zinc-400">導出格式</label>
                        <div className="relative">
                            <select 
                                value={format}
                                onChange={(e) => setFormat(e.target.value as ExportFormat)}
                                className="bg-zinc-800 border border-zinc-700 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-40 p-2 appearance-none cursor-pointer"
                            >
                                <option value="DhtmlXQ">東萍UBB</option>
                                <option value="Text">文本TXT</option>
                                <option value="FenMove">Fen&Move</option>
                                <option value="PGN">PGN</option>
                            </select>
                        </div>
                    </div>

                    <div className="relative group">
                        <textarea 
                            readOnly
                            value={content}
                            className="w-full h-48 bg-zinc-950 border border-zinc-700 rounded-lg p-3 text-xs font-mono text-zinc-300 focus:outline-none resize-none custom-scrollbar"
                        />
                        <button 
                            onClick={() => handleCopy(content)}
                            className="absolute top-2 right-2 p-2 bg-zinc-800 hover:bg-blue-600 text-zinc-400 hover:text-white rounded border border-zinc-700 transition-colors shadow-lg"
                            title="複製內容"
                        >
                            {copied ? <Check size={16} /> : <Copy size={16} />}
                        </button>
                    </div>

                    {format === 'PGN' && (
                        <div className="flex justify-center">
                            <button 
                                onClick={handleDownload}
                                className="w-full py-3 bg-green-600 hover:bg-green-500 text-white font-bold rounded-lg shadow-lg flex items-center justify-center gap-2 transition-colors"
                            >
                                <Download size={18} /> 下載 PGN 檔案
                            </button>
                        </div>
                    )}
                </div>
            </div>
        </div>
    );
};

const UploadIcon = ({ className }: { className?: string }) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
        <path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"></path>
        <path d="M12 12v9"></path>
        <path d="m16 16-4-4-4 4"></path>
    </svg>
);

export default ExportModal;


==============================
File Path: components\GifExportModal.tsx
==============================

import React, { useState, useEffect } from 'react';
import { X, Film, Download, Check, Settings2, Image } from 'lucide-react';
import { MoveNode, GameMetadata } from '../types';
import { generateGif } from '../lib/gifGenerator';

interface GifExportModalProps {
    isOpen: boolean;
    onClose: () => void;
    activePath: MoveNode[]; 
    rootNode: MoveNode;
    metadata: GameMetadata;
}

const GifExportModal: React.FC<GifExportModalProps> = ({ isOpen, onClose, activePath, rootNode, metadata }) => {
    const totalMoves = activePath.length - 1; 
    
    const [startRound, setStartRound] = useState(0);
    const [endRound, setEndRound] = useState(totalMoves);
    const [interval, setInterval] = useState(1.0);
    const [quality, setQuality] = useState(5); 
    const [width, setWidth] = useState(480);
    
    const [isProcessing, setIsProcessing] = useState(false);
    const [progress, setProgress] = useState(0);
    const [statusText, setStatusText] = useState('');
    const [resultBlob, setResultBlob] = useState<Blob | null>(null);

    useEffect(() => {
        if (isOpen) {
            setEndRound(activePath.length - 1);
            setStartRound(0);
            setResultBlob(null);
            setProgress(0);
            setIsProcessing(false);
        }
    }, [isOpen, activePath.length]);

    if (!isOpen) return null;

    const handleGenerate = async () => {
        if (startRound > endRound) {
            alert("結束回合必須大於開始回合");
            return;
        }

        setIsProcessing(true);
        setResultBlob(null);
        
        try {
            const blob = await generateGif(
                rootNode,
                activePath,
                metadata,
                {
                    startRound,
                    endRound,
                    interval,
                    quality,
                    width
                },
                (pct, text) => {
                    setProgress(pct);
                    setStatusText(text);
                }
            );
            setResultBlob(blob);
        } catch (e) {
            console.error(e);
            setStatusText("生成失敗，請重試");
        } finally {
            setIsProcessing(false);
        }
    };

    const handleDownload = () => {
        if (!resultBlob) return;
        const url = URL.createObjectURL(resultBlob);
        const a = document.createElement('a');
        a.href = url;
        const filename = (metadata.title || 'chess_game').replace(/\s+/g, '_') + '.gif';
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        onClose();
    };

    const qualityOptions = [
        { label: '高畫質 (慢)', val: 1 },
        { label: '標準', val: 5 },
        { label: '低畫質 (快)', val: 10 },
    ];

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-full max-w-md mx-4 flex flex-col overflow-hidden">
                <div className="px-6 py-4 border-b border-zinc-800 flex justify-between items-center bg-zinc-900">
                    <h2 className="text-lg font-bold text-white flex items-center gap-2">
                        <Film className="text-pink-500" /> 匯出動態 GIF
                    </h2>
                    {!isProcessing && (
                        <button onClick={onClose} className="text-zinc-500 hover:text-white"><X size={20} /></button>
                    )}
                </div>

                <div className="p-6 space-y-6">
                    {!resultBlob && !isProcessing ? (
                        <>
                            <div className="space-y-3">
                                <div className="flex justify-between text-sm font-bold text-zinc-400">
                                    <span>回合範圍</span>
                                    <span className="text-pink-400">{startRound} - {endRound}</span>
                                </div>
                                <div className="flex gap-4 items-center">
                                    <input 
                                        type="number" min="0" max={endRound} 
                                        value={startRound}
                                        onChange={(e) => setStartRound(Math.min(parseInt(e.target.value) || 0, endRound))}
                                        className="w-16 bg-zinc-950 border border-zinc-700 rounded p-1 text-center text-sm"
                                    />
                                    <div className="flex-1 relative h-2 bg-zinc-800 rounded-full">
                                        <div 
                                            className="absolute h-full bg-pink-600/50 rounded-full"
                                            style={{
                                                left: `${(startRound / totalMoves) * 100}%`,
                                                width: `${((endRound - startRound) / totalMoves) * 100}%`
                                            }}
                                        ></div>
                                    </div>
                                    <input 
                                        type="number" min={startRound} max={totalMoves} 
                                        value={endRound}
                                        onChange={(e) => setEndRound(Math.min(parseInt(e.target.value) || 0, totalMoves))}
                                        className="w-16 bg-zinc-950 border border-zinc-700 rounded p-1 text-center text-sm"
                                    />
                                </div>
                            </div>
                            <hr className="border-zinc-800" />
                            <div className="grid grid-cols-2 gap-4">
                                <div className="space-y-2">
                                    <label className="text-xs font-bold text-zinc-500 flex items-center gap-1">
                                        <Settings2 size={12} /> 播放速度 (每步秒數)
                                    </label>
                                    <select 
                                        value={interval.toString()} 
                                        onChange={(e) => setInterval(parseFloat(e.target.value))}
                                        className="w-full bg-zinc-800 border border-zinc-700 rounded px-2 py-1.5 text-sm text-zinc-200 cursor-pointer"
                                    >
                                        <option value="0.5">0.5 秒 (極快)</option>
                                        <option value="1">1.0 秒 (標準)</option>
                                        <option value="1.5">1.5 秒 (舒適)</option>
                                        <option value="2">2.0 秒 (慢速)</option>
                                        <option value="3">3.0 秒 (教學)</option>
                                    </select>
                                </div>

                                <div className="space-y-2">
                                    <label className="text-xs font-bold text-zinc-500 flex items-center gap-1">
                                        <Image size={12} /> 圖片畫質
                                    </label>
                                    <select 
                                        value={quality} 
                                        onChange={(e) => setQuality(parseInt(e.target.value))}
                                        className="w-full bg-zinc-800 border border-zinc-700 rounded px-2 py-1.5 text-sm text-zinc-200 cursor-pointer"
                                    >
                                        {qualityOptions.map(q => <option key={q.val} value={q.val}>{q.label}</option>)}
                                    </select>
                                </div>
                            </div>
                            <div className="flex items-center gap-2 p-3 bg-zinc-800/50 rounded-lg text-xs text-zinc-400 border border-zinc-800">
                                <Check size={14} className="text-green-500" />
                                <span>將自動在圖片頂部疊加標題與棋手資訊</span>
                            </div>
                        </>
                    ) : isProcessing ? (
                        <div className="py-8 flex flex-col items-center gap-4">
                            <div className="w-12 h-12 border-4 border-zinc-800 border-t-pink-500 rounded-full animate-spin"></div>
                            <div className="space-y-1 text-center">
                                <div className="text-lg font-bold text-white">{Math.round(progress)}%</div>
                                <div className="text-sm text-zinc-500">{statusText}</div>
                            </div>
                            <div className="w-full h-1.5 bg-zinc-800 rounded-full overflow-hidden mt-4">
                                <div className="h-full bg-pink-500 transition-all duration-300" style={{ width: `${progress}%` }}></div>
                            </div>
                        </div>
                    ) : (
                        <div className="py-6 flex flex-col items-center gap-4 text-center animate-in zoom-in-95">
                            <div className="w-16 h-16 bg-green-500/20 text-green-500 rounded-full flex items-center justify-center mb-2">
                                <Check size={32} />
                            </div>
                            <div>
                                <h3 className="text-xl font-bold text-white">GIF 生成完成！</h3>
                                <p className="text-sm text-zinc-500 mt-1">檔案已準備好下載</p>
                            </div>
                        </div>
                    )}
                </div>

                <div className="p-4 border-t border-zinc-800 bg-zinc-900/50 flex justify-end gap-3">
                    {!isProcessing && !resultBlob && (
                        <>
                            <button onClick={onClose} className="px-4 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded font-medium text-sm transition-colors">取消</button>
                            <button 
                                onClick={handleGenerate}
                                className="px-6 py-2 bg-pink-600 hover:bg-pink-500 text-white rounded font-bold text-sm shadow-lg shadow-pink-900/20 transition-all active:scale-95 flex items-center gap-2"
                            >
                                <Film size={16} /> 開始生成
                            </button>
                        </>
                    )}
                    
                    {resultBlob && (
                        <>
                            <button onClick={() => setResultBlob(null)} className="px-4 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded font-medium text-sm transition-colors">重新設定</button>
                            <button 
                                onClick={handleDownload}
                                className="px-6 py-2 bg-green-600 hover:bg-green-500 text-white rounded font-bold text-sm shadow-lg transition-all active:scale-95 flex items-center gap-2"
                            >
                                <Download size={16} /> 下載 GIF
                            </button>
                        </>
                    )}
                </div>
            </div>
        </div>
    );
};

export default GifExportModal;


==============================
File Path: components\Header.tsx
==============================

import React, { useState, useRef, useEffect } from 'react';
import { Menu, Settings, Edit, BookOpen, Info, FileText, Upload, Download, Cloud, Image as ImageIcon, ChevronDown } from 'lucide-react';

interface HeaderProps {
    title?: string;
    onOpenInfo?: () => void;
    onOpenEdit?: () => void;
    onOpenMemorize?: () => void;
    onOpenSettings?: () => void;
    onOpenImport?: () => void;
    onOpenExport?: () => void;
    onOpenGif?: () => void;
    isMemorizing?: boolean;
}

const Header: React.FC<HeaderProps> = ({ 
    title,
    onOpenInfo, onOpenEdit, onOpenMemorize, onOpenSettings, 
    onOpenImport, onOpenExport, onOpenGif,
    isMemorizing 
}) => {
    const [isMenuOpen, setIsMenuOpen] = useState(false);
    const [isFileMenuOpen, setIsFileMenuOpen] = useState(false);
    const menuRef = useRef<HTMLDivElement>(null);
    const fileMenuRef = useRef<HTMLDivElement>(null);

    // Close menus when clicking outside
    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
                setIsMenuOpen(false);
            }
            if (fileMenuRef.current && !fileMenuRef.current.contains(event.target as Node)) {
                setIsFileMenuOpen(false);
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => document.removeEventListener('mousedown', handleClickOutside);
    }, []);

    const itemClass = "flex items-center gap-2 px-3 py-2 text-sm font-medium text-zinc-300 hover:bg-zinc-800 hover:text-white rounded-md cursor-pointer transition-colors";
    const activeItemClass = "flex items-center gap-2 px-3 py-2 text-sm font-medium bg-amber-600 text-white rounded-md cursor-pointer transition-colors shadow-lg shadow-amber-900/30";

    const handleMobileClick = (action?: () => void) => {
        if (action) action();
        setIsMenuOpen(false);
    };

    return (
        <header className="w-full bg-zinc-900 border-b border-zinc-800 px-4 h-14 flex items-center justify-between shrink-0 z-50 relative">
            <div className="flex items-center gap-2 z-10">
                <div className="w-8 h-8 bg-gradient-to-br from-amber-600 to-amber-800 rounded-lg flex items-center justify-center font-bold text-white shadow-inner">
                    弈
                </div>
                <span className="text-lg font-bold bg-clip-text text-transparent bg-gradient-to-r from-amber-200 to-amber-500 hidden xl:block">
                    Cloud Chess Note
                </span>
            </div>

            {/* Center Title - Absolute positioned to be always perfectly centered */}
            {title && (
                <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 pointer-events-none w-full flex justify-center px-20">
                    <span 
                        className="text-xl md:text-2xl font-bold text-amber-100/90 tracking-widest shadow-black drop-shadow-md truncate max-w-full" 
                        style={{ fontFamily: '"KaiTi", "STKaiti", "Microsoft JhengHei", serif' }}
                    >
                        {title}
                    </span>
                </div>
            )}

            {/* Desktop Menu */}
            <nav className="hidden md:flex items-center gap-1 z-10 bg-zinc-900/80 backdrop-blur-sm rounded-lg">
                {/* File Dropdown */}
                <div className="relative" ref={fileMenuRef}>
                    <button 
                        onClick={() => setIsFileMenuOpen(!isFileMenuOpen)} 
                        className={itemClass}
                        disabled={isMemorizing}
                    >
                        <FileText size={16}/> 檔案 <ChevronDown size={14} className={`transition-transform ${isFileMenuOpen ? 'rotate-180' : ''}`} />
                    </button>
                    {isFileMenuOpen && (
                        <div className="absolute top-full right-0 mt-1 w-44 bg-zinc-900 border border-zinc-700 rounded-lg shadow-xl py-1 z-50 flex flex-col">
                            <button onClick={() => { onOpenImport?.(); setIsFileMenuOpen(false); }} className="flex items-center gap-2 px-4 py-2 text-sm text-zinc-300 hover:bg-zinc-800 hover:text-white text-left">
                                <Upload size={14} /> 導入
                            </button>
                            <button onClick={() => { onOpenExport?.(); setIsFileMenuOpen(false); }} className="flex items-center gap-2 px-4 py-2 text-sm text-zinc-300 hover:bg-zinc-800 hover:text-white text-left">
                                <Download size={14} /> 導出
                            </button>
                            <button onClick={() => { onOpenGif?.(); setIsFileMenuOpen(false); }} className="flex items-center gap-2 px-4 py-2 text-sm text-zinc-300 hover:bg-zinc-800 hover:text-white text-left">
                                <ImageIcon size={14} /> 匯出 GIF
                            </button>
                            <button className="flex items-center gap-2 px-4 py-2 text-sm text-zinc-500 cursor-not-allowed text-left">
                                <Cloud size={14} /> 上傳雲端
                            </button>
                        </div>
                    )}
                </div>

                <button onClick={onOpenInfo} className={itemClass} disabled={isMemorizing}><Info size={16}/> 資訊</button>
                <button onClick={onOpenEdit} className={itemClass} disabled={isMemorizing}><Edit size={16}/> 編輯</button>
                <button 
                    onClick={onOpenMemorize} 
                    className={isMemorizing ? activeItemClass : itemClass}
                    title={isMemorizing ? "停止背譜" : "開始背譜"}
                >
                    <BookOpen size={16}/> {isMemorizing ? "停止背譜" : "背譜"}
                </button>
                <button onClick={onOpenSettings} className={itemClass}><Settings size={16}/> 設定</button>
            </nav>

            {/* Mobile Menu Icon */}
            <button 
                onClick={() => setIsMenuOpen(!isMenuOpen)}
                className="md:hidden p-2 text-zinc-400 hover:text-white active:bg-zinc-800 rounded-lg transition-colors z-10"
            >
                <Menu size={24} />
            </button>

            {/* Mobile Dropdown Menu */}
            {isMenuOpen && (
                <div ref={menuRef} className="absolute top-14 right-2 w-48 bg-zinc-900 border border-zinc-700 rounded-xl shadow-2xl py-2 flex flex-col gap-1 z-[60] animate-in fade-in slide-in-from-top-2 md:hidden">
                    <div className="px-4 py-1 text-xs font-bold text-zinc-500 uppercase tracking-wider">檔案</div>
                    <button onClick={() => handleMobileClick(onOpenImport)} className="flex items-center gap-3 px-4 py-2 text-zinc-300 hover:bg-zinc-800 hover:text-white transition-colors text-left" disabled={isMemorizing}>
                        <Upload size={18} /> <span>導入棋譜</span>
                    </button>
                    <button onClick={() => handleMobileClick(onOpenExport)} className="flex items-center gap-3 px-4 py-2 text-zinc-300 hover:bg-zinc-800 hover:text-white transition-colors text-left" disabled={isMemorizing}>
                        <Download size={18} /> <span>導出棋譜</span>
                    </button>
                    <button onClick={() => handleMobileClick(onOpenGif)} className="flex items-center gap-3 px-4 py-2 text-zinc-300 hover:bg-zinc-800 hover:text-white transition-colors text-left" disabled={isMemorizing}>
                        <ImageIcon size={18} /> <span>匯出 GIF</span>
                    </button>
                    
                    <div className="h-px bg-zinc-800 my-1 mx-2"></div>
                    
                    <button onClick={() => handleMobileClick(onOpenInfo)} className="flex items-center gap-3 px-4 py-3 text-zinc-300 hover:bg-zinc-800 hover:text-white transition-colors text-left" disabled={isMemorizing}>
                        <Info size={18} /> <span>資訊</span>
                    </button>
                    <button onClick={() => handleMobileClick(onOpenEdit)} className="flex items-center gap-3 px-4 py-3 text-zinc-300 hover:bg-zinc-800 hover:text-white transition-colors text-left" disabled={isMemorizing}>
                        <Edit size={18} /> <span>編輯</span>
                    </button>
                    <button onClick={() => handleMobileClick(onOpenMemorize)} className={`flex items-center gap-3 px-4 py-3 transition-colors text-left ${isMemorizing ? 'text-amber-500 bg-amber-900/20' : 'text-zinc-300 hover:bg-zinc-800 hover:text-white'}`}>
                        <BookOpen size={18} /> <span>{isMemorizing ? "停止背譜" : "背譜模式"}</span>
                    </button>
                    <div className="h-px bg-zinc-800 my-1 mx-2"></div>
                    <button onClick={() => handleMobileClick(onOpenSettings)} className="flex items-center gap-3 px-4 py-3 text-zinc-300 hover:bg-zinc-800 hover:text-white transition-colors text-left">
                        <Settings size={18} /> <span>系統設定</span>
                    </button>
                </div>
            )}
        </header>
    );
};

export default Header;


==============================
File Path: components\ImportModal.tsx
==============================

import React, { useState, useRef, DragEvent } from 'react';
import { X, Upload, FileText, AlertTriangle } from 'lucide-react';
import { Importer } from '../lib/importer';

interface ImportModalProps {
    isOpen: boolean;
    onClose: () => void;
    onImport: (data: any) => void;
}

const ImportModal: React.FC<ImportModalProps> = ({ isOpen, onClose, onImport }) => {
    const [dragActive, setDragActive] = useState(false);
    const [inputText, setInputText] = useState('');
    const [error, setError] = useState<string | null>(null);
    const inputRef = useRef<HTMLInputElement>(null);

    if (!isOpen) return null;

    const handleDrag = (e: DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        if (e.type === "dragenter" || e.type === "dragover") {
            setDragActive(true);
        } else if (e.type === "dragleave") {
            setDragActive(false);
        }
    };

    const processFile = (file: File) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const text = e.target?.result as string;
            if (text) {
                try {
                    const parsed = Importer.parseInput(text);
                    if (parsed.moves.length === 0 && !parsed.fen) throw new Error("無效的棋譜內容");
                    onImport(parsed);
                    onClose();
                } catch (err) {
                    setError("解析失敗：格式不支援或檔案損毀");
                }
            }
        };
        reader.readAsText(file);
    };

    const handleDrop = (e: DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setDragActive(false);
        if (e.dataTransfer.files && e.dataTransfer.files[0]) {
            processFile(e.dataTransfer.files[0]);
        }
    };

    const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0]) {
            processFile(e.target.files[0]);
        }
    };

    const handleTextImport = () => {
        if (!inputText.trim()) return;
        try {
            const parsed = Importer.parseInput(inputText);
            if (parsed.moves.length === 0 && !parsed.fen) throw new Error("無效的棋譜內容");
            onImport(parsed);
            onClose();
        } catch (err) {
            setError("解析失敗：請檢查文字格式");
        }
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-full max-w-lg mx-4 flex flex-col max-h-[90vh]">
                <div className="px-6 py-4 border-b border-zinc-800 flex justify-between items-center">
                    <h2 className="text-lg font-bold text-white">導入棋譜</h2>
                    <button onClick={onClose} className="text-zinc-500 hover:text-white"><X size={20} /></button>
                </div>

                <div className="p-6 space-y-6 overflow-y-auto">
                    <div className="text-sm text-zinc-400 mb-2">
                        支援格式：PGN (中文/ICCS/WXF), 東萍 DhtmlXQ (含變招)
                    </div>

                    <div 
                        className={`
                            relative h-40 rounded-xl border-2 border-dashed flex flex-col items-center justify-center gap-3 transition-all
                            ${dragActive ? 'border-amber-500 bg-amber-900/10' : 'border-zinc-700 bg-zinc-950/50 hover:bg-zinc-900 hover:border-zinc-500'}
                        `}
                        onDragEnter={handleDrag}
                        onDragLeave={handleDrag}
                        onDragOver={handleDrag}
                        onDrop={handleDrop}
                    >
                        <Upload size={32} className={dragActive ? 'text-amber-500' : 'text-zinc-500'} />
                        <div className="text-center">
                            <p className="text-sm font-medium text-zinc-300">拖曳檔案到此處，或</p>
                            <button 
                                onClick={() => inputRef.current?.click()}
                                className="mt-2 px-4 py-1.5 bg-blue-600 hover:bg-blue-500 text-white text-xs font-bold rounded shadow-lg transition-colors"
                            >
                                選擇檔案
                            </button>
                        </div>
                        <p className="text-[10px] text-zinc-500">支援 .pgn, .txt, .dhtmlxq 檔案</p>
                        <input 
                            ref={inputRef} 
                            type="file" 
                            className="hidden" 
                            accept=".pgn,.txt,.dhtmlxq" 
                            onChange={handleFileSelect} 
                        />
                    </div>

                    <div className="relative flex items-center py-2">
                        <div className="grow border-t border-zinc-800"></div>
                        <span className="shrink-0 mx-4 text-xs text-zinc-500">或 貼上文字</span>
                        <div className="grow border-t border-zinc-800"></div>
                    </div>

                    <div className="space-y-2">
                        <textarea 
                            value={inputText}
                            onChange={(e) => { setInputText(e.target.value); setError(null); }}
                            className="w-full h-32 bg-zinc-950 border border-zinc-700 rounded-lg p-3 text-xs font-mono text-zinc-300 focus:border-amber-500 focus:outline-none resize-none placeholder-zinc-600"
                            placeholder="在此貼上 PGN 或 DhtmlXQ 代碼..."
                        />
                        {error && (
                            <div className="text-red-400 text-xs flex items-center gap-1">
                                <AlertTriangle size={12} /> {error}
                            </div>
                        )}
                    </div>
                </div>

                <div className="p-4 border-t border-zinc-800 bg-zinc-900/50 flex justify-end gap-3">
                    <button onClick={onClose} className="px-4 py-2 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded font-medium text-sm">取消</button>
                    <button 
                        onClick={handleTextImport}
                        disabled={!inputText.trim()}
                        className="px-6 py-2 bg-green-600 hover:bg-green-500 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded font-bold text-sm shadow-lg"
                    >
                        確定
                    </button>
                </div>
            </div>
        </div>
    );
};

export default ImportModal;


==============================
File Path: components\InfoModal.tsx
==============================
import React, { useState } from 'react';
import { X, Edit2, Calendar, Trophy, User } from 'lucide-react';
import { GameMetadata } from '../types';

interface InfoModalProps {
    isOpen: boolean;
    onClose: () => void;
    metadata: GameMetadata;
    onSave: (data: GameMetadata) => void;
}

const InfoModal: React.FC<InfoModalProps> = ({ isOpen, onClose, metadata, onSave }) => {
    const [formData, setFormData] = useState<GameMetadata>(metadata);

    if (!isOpen) return null;

    const handleChange = (field: keyof GameMetadata, value: string) => {
        setFormData(prev => ({ ...prev, [field]: value }));
    };

    const handleSave = () => {
        onSave(formData);
        onClose();
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/70 backdrop-blur-sm animate-in fade-in duration-200">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-full max-w-md mx-4 overflow-hidden flex flex-col max-h-[90vh]">
                {/* Header */}
                <div className="px-6 py-4 border-b border-zinc-800 flex justify-between items-center bg-zinc-900">
                    <h2 className="text-xl font-bold text-white flex items-center gap-2">
                        <Edit2 className="text-amber-500" size={20} />
                        編輯棋譜資訊
                    </h2>
                    <button onClick={onClose} className="p-1 hover:bg-zinc-800 rounded text-zinc-400 hover:text-white transition-colors">
                        <X size={24} />
                    </button>
                </div>

                {/* Form Body */}
                <div className="p-6 space-y-4 overflow-y-auto custom-scrollbar">
                    
                    {/* Title */}
                    <div className="space-y-1">
                        <label className="text-sm font-bold text-zinc-400 block">標題 :</label>
                        <input 
                            type="text" 
                            value={formData.title}
                            onChange={(e) => handleChange('title', e.target.value)}
                            placeholder="棋局標題"
                            className="w-full bg-zinc-950 border border-zinc-700 rounded-lg px-3 py-2 text-zinc-200 focus:outline-none focus:border-amber-500 transition-colors"
                        />
                    </div>

                    {/* Event */}
                    <div className="space-y-1">
                        <label className="text-sm font-bold text-zinc-400 block">賽事 :</label>
                        <div className="relative">
                            <Trophy size={16} className="absolute left-3 top-3 text-zinc-500" />
                            <input 
                                type="text" 
                                value={formData.event}
                                onChange={(e) => handleChange('event', e.target.value)}
                                placeholder="比賽名稱"
                                className="w-full bg-zinc-950 border border-zinc-700 rounded-lg pl-9 pr-3 py-2 text-zinc-200 focus:outline-none focus:border-amber-500 transition-colors"
                            />
                        </div>
                    </div>

                    {/* Date */}
                    <div className="space-y-1">
                        <label className="text-sm font-bold text-zinc-400 block">日期 :</label>
                        <div className="relative">
                            <Calendar size={16} className="absolute left-3 top-3 text-zinc-500" />
                            <input 
                                type="text" 
                                value={formData.date}
                                onChange={(e) => handleChange('date', e.target.value)}
                                placeholder="YYYY-MM-DD"
                                className="w-full bg-zinc-950 border border-zinc-700 rounded-lg pl-9 pr-3 py-2 text-zinc-200 focus:outline-none focus:border-amber-500 transition-colors"
                            />
                        </div>
                    </div>

                    {/* Result */}
                    <div className="space-y-1">
                        <label className="text-sm font-bold text-zinc-400 block">結果 :</label>
                        <select 
                            value={formData.result}
                            onChange={(e) => handleChange('result', e.target.value as any)}
                            className="w-full bg-zinc-950 border border-zinc-700 rounded-lg px-3 py-2 text-zinc-200 focus:outline-none focus:border-amber-500 transition-colors appearance-none cursor-pointer"
                        >
                            <option value="unknown">未知</option>
                            <option value="red">紅勝</option>
                            <option value="black">黑勝</option>
                            <option value="draw">和棋</option>
                        </select>
                    </div>

                    {/* Players */}
                    <div className="grid grid-cols-1 gap-4 pt-2 border-t border-zinc-800">
                        <div className="space-y-1">
                            <label className="text-sm font-bold text-red-400 block">紅方 :</label>
                            <div className="relative">
                                <User size={16} className="absolute left-3 top-3 text-red-900" />
                                <input 
                                    type="text" 
                                    value={formData.redName}
                                    onChange={(e) => handleChange('redName', e.target.value)}
                                    placeholder="紅方棋手"
                                    className="w-full bg-zinc-950 border border-zinc-700 rounded-lg pl-9 pr-3 py-2 text-zinc-200 focus:outline-none focus:border-red-500 transition-colors"
                                />
                            </div>
                        </div>

                        <div className="space-y-1">
                            <label className="text-sm font-bold text-zinc-400 block">黑方 :</label>
                            <div className="relative">
                                <User size={16} className="absolute left-3 top-3 text-zinc-600" />
                                <input 
                                    type="text" 
                                    value={formData.blackName}
                                    onChange={(e) => handleChange('blackName', e.target.value)}
                                    placeholder="黑方棋手"
                                    className="w-full bg-zinc-950 border border-zinc-700 rounded-lg pl-9 pr-3 py-2 text-zinc-200 focus:outline-none focus:border-zinc-500 transition-colors"
                                />
                            </div>
                        </div>
                    </div>
                </div>

                {/* Footer */}
                <div className="p-4 border-t border-zinc-800 bg-zinc-900/50 flex justify-end gap-3">
                    <button 
                        onClick={onClose}
                        className="px-5 py-2 bg-zinc-800 hover:bg-zinc-700 text-white rounded-lg font-medium transition-colors"
                    >
                        取消
                    </button>
                    <button 
                        onClick={handleSave}
                        className="px-5 py-2 bg-green-600 hover:bg-green-500 text-white rounded-lg font-bold shadow-lg shadow-green-900/20 transition-colors"
                    >
                        確定
                    </button>
                </div>
            </div>
        </div>
    );
};

export default InfoModal;

==============================
File Path: components\MainLayout.tsx
==============================

import React from 'react';

interface MainLayoutProps {
  header: React.ReactNode;
  leftSidebar: React.ReactNode;
  rightSidebar: React.ReactNode;
  board: React.ReactNode;
  controls: React.ReactNode;
  mobileTabs: React.ReactNode;
  mobileOverlay: React.ReactNode;
}

/**
 * 獨立的佈局組件，確保 RWD 體驗穩定
 * 使用 Flexbox 確保底部指令列在任何螢幕尺寸下都不會消失
 */
const MainLayout: React.FC<MainLayoutProps> = ({
  header,
  leftSidebar,
  rightSidebar,
  board,
  controls,
  mobileTabs,
  mobileOverlay
}) => {
  return (
    <div className="flex flex-col h-screen w-full bg-zinc-950 text-zinc-100 overflow-hidden">
      {/* 頂部導航欄 (固定高度) */}
      <div className="shrink-0 z-50">
        {header}
      </div>

      <div className="flex flex-1 overflow-hidden relative">
        {/* 左側雲庫 (桌面端顯示) */}
        <aside className="hidden xl:flex w-80 2xl:w-96 flex-col border-r border-zinc-800 bg-zinc-900/50">
          {leftSidebar}
        </aside>

        {/* 中央主區域 */}
        <main className="flex-1 flex flex-col bg-zinc-950 min-w-0 relative">
          <div className="flex-1 flex flex-col p-1 md:p-4 overflow-hidden">
            <div className="flex-1 flex flex-col max-w-[800px] mx-auto w-full min-h-0">
              
              {/* 棋盤區域 - flex-1 與 min-h-0 是防止擠壓的關鍵 */}
              <div className="flex-1 flex items-center justify-center relative min-h-0 overflow-hidden">
                {board}
              </div>
              
              {/* 下方指令區域 - shrink-0 確保寬度不足時也不會消失 */}
              <div className="flex flex-col shrink-0 mt-2 gap-2">
                <div className="w-full">
                  {controls}
                </div>

                {/* 移動端專屬分頁切換按鈕 */}
                <div className="xl:hidden shrink-0 h-12 pb-1">
                  {mobileTabs}
                </div>
              </div>
            </div>
          </div>
        </main>

        {/* 右側招法 (桌面端顯示) */}
        <aside className="hidden xl:flex w-80 2xl:w-96 flex-col border-l border-zinc-800 bg-zinc-900/50">
          {rightSidebar}
        </aside>

        {/* 移動端全屏覆蓋層 (招法/雲庫) */}
        {mobileOverlay}
      </div>
    </div>
  );
};

export default MainLayout;


==============================
File Path: components\MemorizationModals.tsx
==============================

import React, { useState } from 'react';
import { BookOpen, Play, CheckCircle, AlertTriangle, X, Copy, Check } from 'lucide-react';
import { MemorizationConfig, MemorizationError, MoveNode } from '../types';

// --- Setup Modal ---

interface MemSetupProps {
    isOpen: boolean;
    onClose: () => void;
    onStart: (config: Omit<MemorizationConfig, 'active'>) => void;
}

export const MemorizationSetupModal: React.FC<MemSetupProps> = ({ isOpen, onClose, onStart }) => {
    const [side, setSide] = useState<MemorizationConfig['side']>('red');
    const [mode, setMode] = useState<MemorizationConfig['mode']>('main');
    const [range, setRange] = useState<string>(''); // Empty = All

    if (!isOpen) return null;

    const handleStart = () => {
        onStart({ side, mode, randomRange: range });
        onClose();
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in zoom-in-95 duration-200">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-full max-w-sm mx-4 overflow-hidden">
                <div className="px-5 py-4 border-b border-zinc-800 bg-zinc-900 flex justify-between items-center">
                    <h2 className="text-lg font-bold text-white flex items-center gap-2">
                        <BookOpen className="text-amber-500" size={20} />
                        背譜模式設定
                    </h2>
                    <button onClick={onClose} className="text-zinc-500 hover:text-white"><X size={20} /></button>
                </div>
                
                <div className="p-5 space-y-6">
                    {/* Side Selection */}
                    <div className="space-y-2">
                        <label className="text-sm font-bold text-zinc-400">選擇執方</label>
                        <div className="grid grid-cols-3 gap-2">
                            {(['red', 'black', 'both'] as const).map(s => (
                                <button
                                    key={s}
                                    onClick={() => setSide(s)}
                                    className={`py-2 px-1 rounded-lg text-sm font-bold border transition-all ${side === s ? 'bg-amber-600/20 border-amber-500 text-amber-400' : 'bg-zinc-950 border-zinc-700 text-zinc-400 hover:border-zinc-500'}`}
                                >
                                    {s === 'red' ? '執紅' : s === 'black' ? '執黑' : '雙方'}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Mode Selection */}
                    <div className="space-y-2">
                        <label className="text-sm font-bold text-zinc-400">電腦回應模式</label>
                        <div className="grid grid-cols-2 gap-2">
                            <button
                                onClick={() => setMode('main')}
                                className={`py-2 rounded-lg text-sm font-bold border transition-all ${mode === 'main' ? 'bg-blue-600/20 border-blue-500 text-blue-400' : 'bg-zinc-950 border-zinc-700 text-zinc-400 hover:border-zinc-500'}`}
                            >
                                強制主變
                            </button>
                            <button
                                onClick={() => setMode('random')}
                                className={`py-2 rounded-lg text-sm font-bold border transition-all ${mode === 'random' ? 'bg-purple-600/20 border-purple-500 text-purple-400' : 'bg-zinc-950 border-zinc-700 text-zinc-400 hover:border-zinc-500'}`}
                            >
                                隨機變著
                            </button>
                        </div>
                    </div>

                    {/* Random Range (Only if Random) */}
                    {mode === 'random' && (
                        <div className="space-y-2 animate-in slide-in-from-top-2">
                            <label className="text-sm font-bold text-zinc-400 flex justify-between">
                                隨機範圍 (變著順序)
                                <span className="text-xs font-normal text-zinc-500">留空代表全部</span>
                            </label>
                            <input 
                                type="text"
                                value={range}
                                onChange={(e) => setRange(e.target.value.toUpperCase())}
                                placeholder="例如: A-C 或 A,B,D"
                                className="w-full bg-zinc-950 border border-zinc-700 rounded-lg px-3 py-2 text-zinc-200 focus:outline-none focus:border-purple-500 uppercase font-mono placeholder:normal-case"
                            />
                            <p className="text-xs text-zinc-500">
                                * 將從棋譜樹中標記為 A, B, C... 的變著中隨機選擇
                            </p>
                        </div>
                    )}
                </div>

                <div className="p-4 border-t border-zinc-800 bg-zinc-900/50 flex justify-end gap-3">
                    <button onClick={onClose} className="px-4 py-2 text-sm font-medium text-zinc-400 hover:text-white">取消</button>
                    <button onClick={handleStart} className="px-6 py-2 bg-amber-600 hover:bg-amber-500 text-white rounded-lg font-bold shadow-lg shadow-amber-900/20 flex items-center gap-2">
                        <Play size={16} fill="currentColor" /> 開始
                    </button>
                </div>
            </div>
        </div>
    );
};

// --- Report Modal ---

interface MemReportProps {
    isOpen: boolean;
    onClose: () => void;
    errors: MemorizationError[];
    totalSteps: number;
    activePath: MoveNode[]; // Full path played
    startNodeId: string;    // ID where memorization started
    endNodeId: string;      // ID where memorization ended
}

export const MemorizationReportModal: React.FC<MemReportProps> = ({ 
    isOpen, 
    onClose, 
    errors, 
    totalSteps,
    activePath,
    startNodeId,
    endNodeId
}) => {
    const [copied, setCopied] = useState(false);

    if (!isOpen) return null;

    const totalErrors = errors.reduce((acc, curr) => acc + curr.count, 0);
    const successRate = Math.max(0, Math.round(((totalSteps - totalErrors) / Math.max(totalSteps, 1)) * 100));
    
    // Determine grade
    let grade = 'S';
    let color = 'text-yellow-400';
    if (successRate < 60) { grade = 'C'; color = 'text-zinc-500'; }
    else if (successRate < 80) { grade = 'B'; color = 'text-blue-400'; }
    else if (successRate < 100) { grade = 'A'; color = 'text-green-400'; }

    // Indices for context calculation
    const startIndex = activePath.findIndex(n => n.id === startNodeId);
    const endIndex = activePath.findIndex(n => n.id === endNodeId);
    
    // Filter moves (ignore root)
    const movesOnly = activePath.filter(n => n.move !== null);
    
    // Generate text for clipboard
    const generateText = () => {
        let text = `【背譜報告】評級:${grade} 步數:${totalSteps} 錯誤:${totalErrors}\n\n`;
        if (errors.length > 0) {
            text += "【錯誤詳情】\n";
            errors.forEach(e => {
                text += `第 ${e.round} 回合: 錯誤 ${e.count} 次\n`;
            });
            text += "\n";
        }
        let round = 1;
        for (let i = 0; i < movesOnly.length; i+=2) {
            const red = movesOnly[i];
            const black = movesOnly[i+1];
            
            // Re-calculate visual index relative to full path to check against startIndex
            const redRealIndex = activePath.findIndex(n => n.id === red.id);
            const blackRealIndex = black ? activePath.findIndex(n => n.id === black.id) : -1;
            
            const getMark = (node: MoveNode, realIdx: number) => {
                if (realIdx < startIndex || realIdx > endIndex) return ""; // Context
                // IMPORTANT: Check error by PARENT ID, because error is recorded at the state BEFORE the move
                const err = errors.find(e => e.nodeId === node.parentId);
                return err ? "(錯)" : "(正)";
            };
            
            const redMark = getMark(red, redRealIndex);
            const blackMark = black ? getMark(black, blackRealIndex) : "";
            
            text += `${round}. ${red.move?.notation}${redMark}  ${black ? black.move?.notation + blackMark : ""}\n`;
            round++;
        }
        return text;
    };

    const handleCopy = () => {
        navigator.clipboard.writeText(generateText());
        setCopied(true);
        setTimeout(() => setCopied(false), 2000);
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/80 backdrop-blur-sm animate-in fade-in zoom-in-95 duration-300">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-full max-w-lg mx-4 overflow-hidden flex flex-col max-h-[85vh]">
                <div className="px-6 py-5 border-b border-zinc-800 bg-zinc-900 text-center relative shrink-0">
                    <h2 className="text-2xl font-bold text-white mb-1">背譜結算報告</h2>
                    <div className="text-zinc-500 text-sm">本次練習共走了 {totalSteps} 步 (不含電腦回應)</div>
                </div>

                <div className="p-6 overflow-y-auto custom-scrollbar flex-1 bg-zinc-950/50">
                    {/* Score Card */}
                    <div className="flex justify-center items-center gap-6 mb-8">
                        <div className="text-center">
                            <div className={`text-5xl font-black ${color} drop-shadow-lg mb-1`}>{grade}</div>
                            <div className="text-xs text-zinc-500 font-bold tracking-widest uppercase">等級</div>
                        </div>
                        <div className="w-px h-12 bg-zinc-800"></div>
                        <div className="text-center">
                            <div className="text-3xl font-bold text-white mb-1">{totalErrors}</div>
                            <div className="text-xs text-zinc-500 font-bold">錯誤次數</div>
                        </div>
                    </div>

                    {/* Error Details (Restored) */}
                    {errors.length > 0 && (
                        <div className="mb-4 bg-red-950/20 border border-red-900/30 rounded-lg p-3">
                            <h4 className="text-xs font-bold text-red-400 mb-2 flex items-center gap-1">
                                <AlertTriangle size={12} /> 錯誤詳情
                            </h4>
                            <div className="max-h-24 overflow-y-auto custom-scrollbar space-y-1">
                                {errors.map((e, idx) => (
                                    <div key={idx} className="text-xs text-red-300 flex justify-between">
                                        <span>第 {e.round} 回合</span>
                                        <span>錯誤 {e.count} 次</span>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Move List */}
                    <div className="space-y-3">
                         <div className="flex justify-between items-center mb-2">
                             <h3 className="font-bold text-zinc-400 text-sm">完整棋譜回顧</h3>
                             <div className="flex gap-2 text-[10px]">
                                 <span className="flex items-center gap-1 text-zinc-500"><span className="w-2 h-2 bg-zinc-500 rounded-full"></span>上下文</span>
                                 <span className="flex items-center gap-1 text-green-500"><span className="w-2 h-2 bg-green-500 rounded-full"></span>正確</span>
                                 <span className="flex items-center gap-1 text-red-500"><span className="w-2 h-2 bg-red-500 rounded-full"></span>錯誤</span>
                             </div>
                         </div>
                         
                         <div className="bg-zinc-900 border border-zinc-800 rounded-lg p-4 font-mono text-sm leading-relaxed max-h-64 overflow-y-auto custom-scrollbar">
                            {movesOnly.length === 0 ? <div className="text-zinc-600 italic text-center">無走棋記錄</div> : (
                                <div className="grid grid-cols-[3rem_1fr_1fr] gap-y-1">
                                    {Array.from({ length: Math.ceil(movesOnly.length / 2) }).map((_, i) => {
                                        const red = movesOnly[i*2];
                                        const black = movesOnly[i*2+1];
                                        const round = i + 1;
                                        
                                        // Helper to determine style
                                        const getStyle = (node: MoveNode) => {
                                            const realIdx = activePath.findIndex(n => n.id === node.id);
                                            // 1. Before Start or After End -> Context (White/Gray)
                                            if (realIdx < startIndex || realIdx > endIndex) return "text-zinc-500"; 
                                            
                                            // 2. Inside range -> Check error
                                            // IMPORTANT: Check error by PARENT ID, because error is recorded at the state BEFORE the move
                                            const err = errors.find(e => e.nodeId === node.parentId);
                                            if (err) return "text-red-400 font-bold"; // Red for error
                                            
                                            // 3. Correct
                                            return "text-green-400"; // Green for correct
                                        };

                                        return (
                                            <React.Fragment key={i}>
                                                <div className="text-zinc-600 text-right pr-3">{round}.</div>
                                                <div className={getStyle(red)}>{red.move?.notation}</div>
                                                <div className={black ? getStyle(black) : ""}>{black?.move?.notation}</div>
                                            </React.Fragment>
                                        );
                                    })}
                                </div>
                            )}
                         </div>
                    </div>
                </div>

                <div className="p-4 border-t border-zinc-800 bg-zinc-900 flex gap-3 shrink-0">
                    <button 
                        onClick={handleCopy}
                        className="flex-1 py-3 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded-lg font-bold transition-colors flex items-center justify-center gap-2 border border-zinc-700"
                    >
                        {copied ? <Check size={18} className="text-green-500"/> : <Copy size={18}/>} 複製棋譜
                    </button>
                    <button onClick={onClose} className="flex-1 py-3 bg-amber-600 hover:bg-amber-500 text-white rounded-lg font-bold transition-colors">
                        關閉並返回
                    </button>
                </div>
            </div>
        </div>
    );
};


==============================
File Path: components\MoveListPanel.tsx
==============================

import React, { useEffect, useRef } from 'react';
import { Split, Trash2, AtSign, MessageSquare, ChevronUp, ChevronDown, Link as LinkIcon } from 'lucide-react';
import { MoveNode } from '../types';

interface MoveListPanelProps {
    movePath: MoveNode[];
    currentNode: MoveNode;
    rootNode: MoveNode;
    onJumpToMove: (node: MoveNode) => void;
    onUpdateComment: (id: string, comment: string) => void;
    onRequestDelete: (message: string) => void;
    onRequestDeleteNode: (nodeId: string, message: string) => void; // 新增：刪除特定節點的回調
    onReorder: (childId: string, direction: 'up' | 'down') => void;
    onLinkFen: () => void;
}

const MoveListPanel: React.FC<MoveListPanelProps> = ({ 
    movePath, 
    currentNode, 
    rootNode,
    onJumpToMove, 
    onUpdateComment,
    onRequestDelete,
    onRequestDeleteNode,
    onReorder,
    onLinkFen
}) => {
    
    const activeRowRef = useRef<HTMLTableRowElement>(null);
    const tableContainerRef = useRef<HTMLDivElement>(null);

    // Ensure we only depend on the ID string
    const currentId = currentNode ? currentNode.id : null;

    useEffect(() => {
        if (tableContainerRef.current) {
            if (currentId && currentId !== 'root' && activeRowRef.current) {
                try {
                    activeRowRef.current.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                } catch (e) {
                    // Ignore scroll errors
                }
            } else {
                 tableContainerRef.current.scrollTop = 0;
            }
        }
    }, [currentId]);

    const safeMovePath = movePath || [];
    const movesOnly = safeMovePath.filter(n => n && n.parentId !== null);
    const isRoot = currentNode && rootNode && currentNode.id === rootNode.id;

    // Variation Logic: Siblings of the current node (or children if at root)
    let variationNodes: MoveNode[] = [];
    if (currentNode && !currentNode.parentId) {
        variationNodes = currentNode.children || [];
    } else if (currentNode) {
        const parent = safeMovePath.find(n => n.id === currentNode.parentId);
        if (parent) {
            variationNodes = parent.children || [];
        }
    }

    const handleDelete = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();
        
        let message = '確定要刪除當前棋步及之後的所有著法嗎？\n\n';
        message += `當前棋步：${currentNode.move?.notation || "開始局面"} \n`;

        if (variationNodes.length > 1) {
             message += `\n注意：此步驟為變著之一，刪除後將自動切換至其他變化。`;
        } else {
             message += `\n此操作無法復原。`;
        }

        // Trigger parent modal, do NOT use window.confirm
        onRequestDelete(message);
    };

    const handleDeleteVariation = (e: React.MouseEvent, node: MoveNode) => {
        e.preventDefault();
        e.stopPropagation();
        
        let message = `確定要刪除變著 [${node.move?.notation}] 及其後續所有招法嗎？\n\n此操作無法復原。`;
        onRequestDeleteNode(node.id, message);
    };

    if (!currentNode) return <div className="p-4 text-zinc-500">載入中...</div>;

    return (
        <div className="flex flex-col h-full w-full bg-zinc-900 shadow-xl text-sm overflow-hidden">
            {/* 1. Header */}
            <div className="px-4 py-3 border-b border-zinc-800 bg-zinc-900/50 backdrop-blur-sm shrink-0 flex justify-between items-center">
                <h3 className="font-bold text-zinc-200 flex items-center gap-2">
                    <span className="w-2 h-6 bg-amber-600 rounded-sm"></span>
                    招法 & 變著
                </h3>
                {movesOnly.length > 0 && !isRoot && (
                    <button 
                        onClick={handleDelete} 
                        className="text-zinc-500 hover:text-red-400 p-1.5 rounded hover:bg-zinc-800 transition-colors" 
                        title="刪除當前招法"
                    >
                        <Trash2 size={16} />
                    </button>
                )}
            </div>

            {/* 2. Moves Table (Scrollable) */}
            <div ref={tableContainerRef} className="flex-1 overflow-y-auto custom-scrollbar bg-zinc-950/30 min-h-0 relative">
                <table className="w-full text-left border-collapse">
                    <thead className="bg-zinc-900 text-zinc-500 font-medium sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th className="px-4 py-2 w-12 text-center border-b border-zinc-800">#</th>
                            <th className="px-2 py-2 border-b border-zinc-800 w-1/2">紅方</th>
                            <th className="px-2 py-2 border-b border-zinc-800 w-1/2">黑方</th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-zinc-800/50">
                        {/* Root Node Row */}
                        <tr 
                            onClick={() => onJumpToMove(rootNode)}
                            className={`cursor-pointer group transition-colors ${isRoot ? 'bg-blue-900/30' : 'hover:bg-zinc-800/30'}`}
                        >
                            <td className="px-2 py-2 text-center text-zinc-600 font-mono text-xs">0</td>
                            <td colSpan={2} className="px-2 py-2">
                                <div className={`flex items-center justify-center font-bold text-xs border border-dashed rounded py-1 ${isRoot ? 'border-blue-500 text-blue-300 bg-blue-500/10' : 'border-zinc-700 text-zinc-500 group-hover:border-zinc-500 group-hover:text-zinc-300'}`}>
                                    == 開始局面 ==
                                    {rootNode.comment && <AtSign size={12} className="ml-2 text-amber-500" />}
                                </div>
                            </td>
                        </tr>

                        {movesOnly.length === 0 && isRoot ? (
                            <tr><td colSpan={3} className="px-4 py-8 text-center text-zinc-600 italic text-xs">請開始走棋...</td></tr>
                        ) : (
                            Array.from({ length: Math.ceil(movesOnly.length / 2) }).map((_, i) => {
                                const index = i * 2;
                                const redNode = movesOnly[index];
                                const blackNode = movesOnly[index + 1];
                                const isRedCurrent = redNode?.id === currentNode.id;
                                const isBlackCurrent = blackNode?.id === currentNode.id;

                                const renderCell = (node: MoveNode | undefined, isCurrent: boolean) => {
                                    if (!node || !node.move) return null;
                                    let varBadge = null;
                                    const parent = safeMovePath.find(p => p.id === node.parentId);
                                    if (parent && parent.children && parent.children.length > 1) {
                                        const varIndex = parent.children.findIndex(c => c.id === node.id);
                                        if (varIndex !== -1) varBadge = `${parent.children.length}${String.fromCharCode(65 + varIndex)}`;
                                    }

                                    return (
                                        <div 
                                            className={`cursor-pointer px-2 py-1.5 rounded flex items-center justify-between group ${isCurrent ? 'bg-blue-600 text-white shadow-md' : 'hover:bg-zinc-800/50'}`}
                                            onClick={() => onJumpToMove(node)}
                                        >
                                            <span className="font-medium truncate">{node.move.notation}</span>
                                            <div className="flex items-center gap-1.5 shrink-0">
                                                {node.comment && <AtSign size={12} className={isCurrent ? "text-blue-200" : "text-amber-500"} />}
                                                {varBadge && (
                                                    <span className={`text-[10px] px-1 rounded font-mono font-bold leading-none py-0.5 ${isCurrent ? 'bg-blue-500 text-white' : 'bg-zinc-700 text-zinc-400 group-hover:bg-zinc-600'}`}>
                                                        {varBadge}
                                                    </span>
                                                )}
                                            </div>
                                        </div>
                                    );
                                };

                                return (
                                    <tr key={i} ref={isRedCurrent || isBlackCurrent ? activeRowRef : null} className="text-zinc-300">
                                        <td className="px-2 py-1.5 text-center text-zinc-600 font-mono text-xs bg-zinc-900/20">{i + 1}</td>
                                        <td className={`px-1 py-1 w-[45%] ${isRedCurrent ? 'bg-blue-900/20' : ''}`}>{renderCell(redNode, isRedCurrent)}</td>
                                        <td className={`px-1 py-1 w-[45%] ${isBlackCurrent ? 'bg-blue-900/20' : ''}`}>{renderCell(blackNode, isBlackCurrent)}</td>
                                    </tr>
                                );
                            })
                        )}
                    </tbody>
                </table>
            </div>

            {/* 3. Bottom Controls (Variations + Comments) */}
            <div className="shrink-0 bg-zinc-900 z-10 border-t border-zinc-800">
                
                {/* Variation List */}
                {variationNodes.length > 0 && (
                     <div className="p-3 border-b border-zinc-800/50">
                        <div className="flex items-center justify-between mb-2">
                            <div className="flex items-center gap-2">
                                <Split size={14} className="text-zinc-500" />
                                <h4 className="text-xs font-bold text-zinc-400">變著 ({variationNodes.length})</h4>
                            </div>
                            <button 
                                onClick={onLinkFen}
                                className="flex items-center gap-1.5 px-2 py-1 bg-zinc-800 hover:bg-blue-900/30 text-zinc-400 hover:text-blue-400 rounded text-[10px] border border-zinc-700 hover:border-blue-700/50 transition-colors"
                                title="遍歷並串聯所有相同局面"
                            >
                                <LinkIcon size={12} />
                                串聯局面
                            </button>
                        </div>
                        
                        <div className="bg-zinc-950 border border-zinc-800 rounded p-1 flex flex-col gap-1 max-h-36 overflow-y-auto custom-scrollbar">
                            {variationNodes.map((sibling, idx) => {
                                const isSelected = sibling.id === currentNode.id;
                                return (
                                    <div key={sibling.id} 
                                        className={`flex items-center gap-2 px-2 py-1.5 rounded text-sm border transition-colors group
                                            ${isSelected ? 'bg-blue-900/20 border-blue-800/50' : 'bg-zinc-900/50 border-zinc-800/50 hover:bg-zinc-800 hover:border-zinc-700'}
                                        `}>
                                        
                                        {/* Row Content (Clickable) */}
                                        <div className="flex items-center gap-2 flex-1 cursor-pointer min-w-0" onClick={() => onJumpToMove(sibling)}>
                                            <span className={`font-mono text-xs font-bold px-1.5 py-0.5 rounded shrink-0 ${isSelected ? 'bg-blue-600 text-white' : 'bg-zinc-800 text-zinc-500'}`}>
                                                {String.fromCharCode(65 + idx)}
                                            </span>
                                            <span className={`truncate font-medium ${isSelected ? 'text-blue-200' : 'text-zinc-400 hover:text-zinc-200'}`}>
                                                {sibling.move?.notation || "開始"}
                                            </span>
                                        </div>
                                        
                                        {/* Right Controls */}
                                        <div className="flex items-center gap-1 pl-2 border-l border-zinc-800/50 shrink-0">
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); onReorder(sibling.id, 'up'); }}
                                                className="p-1 hover:bg-zinc-700 rounded text-zinc-600 hover:text-zinc-300 disabled:opacity-20 disabled:cursor-not-allowed transition-colors"
                                                disabled={idx === 0}
                                                title="上移"
                                            >
                                                <ChevronUp size={14} />
                                            </button>
                                            <button 
                                                onClick={(e) => { e.stopPropagation(); onReorder(sibling.id, 'down'); }}
                                                className="p-1 hover:bg-zinc-700 rounded text-zinc-600 hover:text-zinc-300 disabled:opacity-20 disabled:cursor-not-allowed transition-colors"
                                                disabled={idx === variationNodes.length - 1}
                                                title="下移"
                                            >
                                                <ChevronDown size={14} />
                                            </button>
                                            {/* 新增：刪除變著按鈕 */}
                                            <button 
                                                onClick={(e) => handleDeleteVariation(e, sibling)}
                                                className="p-1 hover:bg-red-900/50 rounded text-zinc-600 hover:text-red-400 transition-colors ml-1"
                                                title="刪除此變著"
                                            >
                                                <Trash2 size={14} />
                                            </button>
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}

                {/* Comments */}
                <div className="p-3">
                    <div className="relative group">
                        <MessageSquare size={14} className="absolute top-3 left-3 text-zinc-500 group-focus-within:text-amber-500 transition-colors" />
                        <textarea 
                            className="w-full bg-zinc-950 border border-zinc-800 rounded-lg py-2 pl-9 pr-3 text-sm text-zinc-300 placeholder-zinc-600 focus:outline-none focus:ring-1 focus:ring-amber-500 resize-none h-16 transition-all custom-scrollbar"
                            placeholder={isRoot ? "添加開始局面注釋..." : "添加當前局面注釋..."}
                            value={currentNode.comment || ""}
                            onChange={(e) => onUpdateComment(currentNode.id, e.target.value)}
                        ></textarea>
                    </div>
                    <div className="flex gap-2 mt-2 overflow-x-auto pb-1 no-scrollbar">
                        {['正著', '劣著', '失子', '飛刀', '妙手'].map(tag => (
                            <button key={tag} onClick={() => onUpdateComment(currentNode.id, ((currentNode.comment || "") + " " + tag).trim())}
                                className="text-xs px-2 py-1 bg-zinc-800 hover:bg-zinc-700 border border-zinc-700 rounded text-zinc-400 whitespace-nowrap transition-colors">
                                {tag}
                            </button>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};

export default MoveListPanel;


==============================
File Path: components\SettingsModal.tsx
==============================
import React from 'react';
import { X, Volume2, VolumeX, Eye, EyeOff, Wind, Monitor, Grid } from 'lucide-react';
import { AppSettings } from '../types';

interface SettingsModalProps {
    isOpen: boolean;
    onClose: () => void;
    settings: AppSettings;
    onUpdate: (newSettings: AppSettings) => void;
}

const SettingsModal: React.FC<SettingsModalProps> = ({ isOpen, onClose, settings, onUpdate }) => {
    if (!isOpen) return null;

    const toggle = (key: keyof AppSettings) => {
        onUpdate({ ...settings, [key]: !settings[key] });
    };

    const handleChange = (key: keyof AppSettings, value: any) => {
        onUpdate({ ...settings, [key]: value });
    };

    return (
        <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/70 backdrop-blur-sm animate-in fade-in zoom-in-95 duration-200">
            <div className="bg-zinc-900 border border-zinc-800 rounded-xl shadow-2xl w-full max-w-sm mx-4 overflow-hidden flex flex-col">
                {/* Header */}
                <div className="px-5 py-4 border-b border-zinc-800 bg-zinc-900 flex justify-between items-center">
                    <h2 className="text-lg font-bold text-white">系統設定</h2>
                    <button onClick={onClose} className="text-zinc-500 hover:text-white transition-colors">
                        <X size={24} />
                    </button>
                </div>

                {/* Body */}
                <div className="p-5 space-y-6 overflow-y-auto custom-scrollbar max-h-[70vh]">
                    
                    {/* 1. Sound */}
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-3">
                            <div className={`p-2 rounded-lg ${settings.enableSound ? 'bg-green-500/20 text-green-400' : 'bg-zinc-800 text-zinc-500'}`}>
                                {settings.enableSound ? <Volume2 size={20} /> : <VolumeX size={20} />}
                            </div>
                            <div>
                                <div className="font-bold text-zinc-200">遊戲音效</div>
                                <div className="text-xs text-zinc-500">落子聲與吃子聲</div>
                            </div>
                        </div>
                        <label className="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" checked={settings.enableSound} onChange={() => toggle('enableSound')} className="sr-only peer" />
                            <div className="w-11 h-6 bg-zinc-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div>
                        </label>
                    </div>

                    <hr className="border-zinc-800" />

                    {/* 2. Player Names */}
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-3">
                            <div className={`p-2 rounded-lg ${settings.showPlayerNames ? 'bg-blue-500/20 text-blue-400' : 'bg-zinc-800 text-zinc-500'}`}>
                                {settings.showPlayerNames ? <Eye size={20} /> : <EyeOff size={20} />}
                            </div>
                            <div>
                                <div className="font-bold text-zinc-200">顯示棋手姓名</div>
                                <div className="text-xs text-zinc-500">在棋盤上下方顯示名稱</div>
                            </div>
                        </div>
                        <label className="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" checked={settings.showPlayerNames} onChange={() => toggle('showPlayerNames')} className="sr-only peer" />
                            <div className="w-11 h-6 bg-zinc-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>

                    {/* 3. Variation Arrows */}
                    <div className="flex items-center justify-between">
                        <div className="flex items-center gap-3">
                            <div className={`p-2 rounded-lg ${settings.showVariationArrows ? 'bg-blue-500/20 text-blue-400' : 'bg-zinc-800 text-zinc-500'}`}>
                                <Wind size={20} />
                            </div>
                            <div>
                                <div className="font-bold text-zinc-200">顯示變著導引</div>
                                <div className="text-xs text-zinc-500">顯示藍色分支箭頭 (A/B)</div>
                            </div>
                        </div>
                        <label className="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" checked={settings.showVariationArrows} onChange={() => toggle('showVariationArrows')} className="sr-only peer" />
                            <div className="w-11 h-6 bg-zinc-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>

                     {/* 3.5 Show Coords (Extra) */}
                     <div className="flex items-center justify-between">
                        <div className="flex items-center gap-3">
                            <div className={`p-2 rounded-lg ${settings.showCoords ? 'bg-blue-500/20 text-blue-400' : 'bg-zinc-800 text-zinc-500'}`}>
                                <Grid size={20} />
                            </div>
                            <div>
                                <div className="font-bold text-zinc-200">顯示棋盤座標</div>
                                <div className="text-xs text-zinc-500">顯示邊緣的 1-9 數字</div>
                            </div>
                        </div>
                        <label className="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" checked={settings.showCoords} onChange={() => toggle('showCoords')} className="sr-only peer" />
                            <div className="w-11 h-6 bg-zinc-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>

                    <hr className="border-zinc-800" />

                    {/* 4. Animation Speed */}
                    <div className="space-y-3">
                        <div className="flex items-center justify-between">
                             <div className="flex items-center gap-3">
                                <div className="p-2 rounded-lg bg-zinc-800 text-zinc-400">
                                    <Monitor size={20} />
                                </div>
                                <div>
                                    <div className="font-bold text-zinc-200">走棋速度</div>
                                    <div className="text-xs text-zinc-500">{settings.animationSpeed} ms</div>
                                </div>
                            </div>
                        </div>
                        <div className="px-1">
                            <input 
                                type="range" 
                                min="0" 
                                max="1000" 
                                step="100"
                                value={settings.animationSpeed}
                                onChange={(e) => handleChange('animationSpeed', parseInt(e.target.value))}
                                className="w-full h-2 bg-zinc-700 rounded-lg appearance-none cursor-pointer accent-amber-600"
                            />
                            <div className="flex justify-between text-[10px] text-zinc-600 mt-1">
                                <span>瞬間 (0ms)</span>
                                <span>慢速 (1s)</span>
                            </div>
                        </div>
                    </div>

                    {/* 5. Board Size */}
                    <div className="space-y-2">
                        <div className="font-bold text-zinc-200">棋盤大小</div>
                        <div className="grid grid-cols-3 gap-2">
                            {(['small', 'medium', 'large'] as const).map(size => {
                                let label = '';
                                if(size === 'small') label = '小 (緊湊)';
                                if(size === 'medium') label = '中 (標準)';
                                if(size === 'large') label = '大 (舒適)';
                                
                                return (
                                    <button
                                        key={size}
                                        onClick={() => handleChange('boardSize', size)}
                                        className={`py-2 px-1 rounded-lg text-sm font-bold border transition-all ${settings.boardSize === size ? 'bg-amber-600/20 border-amber-500 text-amber-400' : 'bg-zinc-950 border-zinc-700 text-zinc-400 hover:border-zinc-500'}`}
                                    >
                                        {label}
                                    </button>
                                );
                            })}
                        </div>
                    </div>

                </div>

                {/* Footer */}
                <div className="p-4 border-t border-zinc-800 bg-zinc-900/50 flex justify-end">
                    <button onClick={onClose} className="px-6 py-2 bg-zinc-800 hover:bg-zinc-700 text-white rounded-lg font-bold transition-colors">
                        關閉
                    </button>
                </div>
            </div>
        </div>
    );
};

export default SettingsModal;

==============================
File Path: components\SidePanel.tsx
==============================
import React, { useEffect, useRef } from 'react';
import { Cloud, Activity, MessageSquare, Split, Trash2, AtSign } from 'lucide-react';
import { MoveNode } from '../types';

// --- Move List Panel ---

interface MoveListPanelProps {
    movePath: MoveNode[]; // The active path from Root to Current (+ Future)
    currentNode: MoveNode;
    onJumpToMove: (node: MoveNode) => void;
    onUpdateComment: (id: string, comment: string) => void;
    onDeleteAfter: (id: string) => void;
}

export const MoveListPanel: React.FC<MoveListPanelProps> = ({ 
    movePath, 
    currentNode, 
    onJumpToMove, 
    onUpdateComment,
    onDeleteAfter
}) => {
    
    // Auto scroll to current move
    const activeRowRef = useRef<HTMLTableRowElement>(null);
    const tableContainerRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        if (activeRowRef.current && tableContainerRef.current) {
            activeRowRef.current.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    }, [currentNode.id]);

    const handleDelete = () => {
        if (window.confirm("確定要刪除當前棋步之後的所有招法嗎？此操作無法撤銷。")) {
            onDeleteAfter(currentNode.id);
        }
    };

    // Filter out root node for the table (Root has no move)
    const movesOnly = movePath.filter(n => n.parentId !== null);

    // --- Logic for Variation List (Bottom Panel) ---
    // We want to show alternatives to the *current move*.
    // If currentNode is Root, we show its children (Moves for turn 1).
    // If currentNode is a Move, we show ITS SIBLINGS (Moves for the same turn).
    let variationNodes: MoveNode[] = [];
    let variationParent: MoveNode | undefined;
    
    if (!currentNode.parentId) {
        // Current is Root
        variationNodes = currentNode.children;
        variationParent = currentNode;
    } else {
        // Current is a Move, find its parent in the path
        const parent = movePath.find(n => n.id === currentNode.parentId);
        if (parent) {
            variationNodes = parent.children;
            variationParent = parent;
        }
    }

    return (
        <div className="flex flex-col h-full bg-zinc-900 border-x border-zinc-800 shadow-xl text-sm">
            {/* Header */}
            <div className="px-4 py-3 border-b border-zinc-800 bg-zinc-900/50 backdrop-blur-sm shrink-0 flex justify-between items-center">
                <h3 className="font-bold text-zinc-200 flex items-center gap-2">
                    <span className="w-2 h-6 bg-amber-600 rounded-sm"></span>
                    招法 & 變著
                </h3>
                {movesOnly.length > 0 && (
                    <button 
                        onClick={handleDelete}
                        className="text-zinc-500 hover:text-red-400 p-1 rounded hover:bg-zinc-800 transition-colors"
                        title="刪除當前之後的招法"
                    >
                        <Trash2 size={16} />
                    </button>
                )}
            </div>

            {/* Scrollable Content Area: Moves Table */}
            <div ref={tableContainerRef} className="flex-1 overflow-y-auto custom-scrollbar bg-zinc-950/30">
                <table className="w-full text-left border-collapse">
                    <thead className="bg-zinc-900 text-zinc-500 font-medium sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th className="px-4 py-2 w-12 text-center border-b border-zinc-800">#</th>
                            <th className="px-2 py-2 border-b border-zinc-800 w-1/2">紅方</th>
                            <th className="px-2 py-2 border-b border-zinc-800 w-1/2">黑方</th>
                        </tr>
                    </thead>
                    <tbody className="divide-y divide-zinc-800/50">
                        {movesOnly.length === 0 ? (
                            <tr>
                                <td colSpan={3} className="px-4 py-8 text-center text-zinc-600 italic text-xs">
                                    請開始走棋...
                                </td>
                            </tr>
                        ) : (
                            // Group into Red/Black pairs
                            Array.from({ length: Math.ceil(movesOnly.length / 2) }).map((_, i) => {
                                const index = i * 2;
                                const redNode = movesOnly[index];
                                const blackNode = movesOnly[index + 1];
                                
                                const isRedCurrent = redNode?.id === currentNode.id;
                                const isBlackCurrent = blackNode?.id === currentNode.id;

                                // Helper to render a cell
                                const renderCell = (node: MoveNode | undefined, isCurrent: boolean) => {
                                    if (!node || !node.move) return null;
                                    
                                    // Calculate Variation Badge (e.g., 2A)
                                    // We need to look up this node's parent in the path to determine siblings index
                                    let varBadge = null;
                                    const parent = movePath.find(p => p.id === node.parentId);
                                    
                                    if (parent && parent.children.length > 1) {
                                        const totalVars = parent.children.length;
                                        // Find index of this node among siblings
                                        const varIndex = parent.children.findIndex(c => c.id === node.id);
                                        if (varIndex !== -1) {
                                            const letter = String.fromCharCode(65 + varIndex);
                                            varBadge = `${totalVars}${letter}`;
                                        }
                                    }

                                    return (
                                        <div 
                                            className={`
                                                cursor-pointer px-2 py-1.5 rounded flex items-center justify-between group
                                                ${isCurrent ? 'bg-blue-600 text-white shadow-md' : 'hover:bg-zinc-800/50'}
                                            `}
                                            onClick={() => onJumpToMove(node)}
                                        >
                                            <span className="font-medium">{node.move.notation}</span>
                                            
                                            <div className="flex items-center gap-1.5">
                                                {/* Comment Indicator (@) - Left side of badge */}
                                                {node.comment && (
                                                    <AtSign size={12} className={isCurrent ? "text-blue-200" : "text-amber-500"} />
                                                )}
                                                
                                                {/* Variation Badge (e.g. 2A) - Right side */}
                                                {varBadge && (
                                                    <span className={`text-[10px] px-1 rounded font-mono font-bold leading-none py-0.5 ${isCurrent ? 'bg-blue-500 text-white' : 'bg-zinc-700 text-zinc-400 group-hover:bg-zinc-600'}`}>
                                                        {varBadge}
                                                    </span>
                                                )}
                                            </div>
                                        </div>
                                    );
                                };

                                return (
                                    <tr key={i} ref={isRedCurrent || isBlackCurrent ? activeRowRef : null} className="text-zinc-300">
                                        <td className="px-2 py-1.5 text-center text-zinc-600 font-mono text-xs bg-zinc-900/20">{i + 1}</td>
                                        <td className={`px-1 py-1 ${isRedCurrent ? 'bg-blue-900/20' : ''}`}>
                                            {renderCell(redNode, isRedCurrent)}
                                        </td>
                                        <td className={`px-1 py-1 ${isBlackCurrent ? 'bg-blue-900/20' : ''}`}>
                                            {renderCell(blackNode, isBlackCurrent)}
                                        </td>
                                    </tr>
                                );
                            })
                        )}
                    </tbody>
                </table>
            </div>

            {/* Bottom Section: Variations & Comments (Fixed at bottom) */}
            <div className="shrink-0 bg-zinc-900 z-10 border-t border-zinc-800">
                
                {/* 2. Variations List (Siblings of Current) */}
                {variationNodes.length > 0 && (
                     <div className="p-3 border-b border-zinc-800/50">
                        <div className="flex items-center gap-2 mb-2">
                            <Split size={14} className="text-zinc-500" />
                            <h4 className="text-xs font-bold text-zinc-400">
                                變著 ({variationNodes.length}) - 點擊切換分支
                            </h4>
                        </div>
                        <div className="bg-zinc-950 border border-zinc-800 rounded p-2 grid grid-cols-2 gap-2 max-h-32 overflow-y-auto custom-scrollbar">
                            {variationNodes.map((sibling, idx) => {
                                const label = String.fromCharCode(65 + idx); // A, B, C...
                                // Is this the node currently selected/active in the view?
                                const isSelected = sibling.id === currentNode.id;
                                
                                return (
                                    <div 
                                        key={sibling.id} 
                                        onClick={() => onJumpToMove(sibling)}
                                        className={`
                                            flex items-center gap-2 px-2 py-1.5 rounded cursor-pointer text-sm transition-all border
                                            ${isSelected 
                                                ? 'bg-blue-900/30 border-blue-600' 
                                                : 'bg-zinc-800 hover:bg-zinc-700 border-zinc-700 hover:border-zinc-600'}
                                        `}
                                    >
                                        <span className={`
                                            font-mono text-xs font-bold px-1.5 py-0.5 rounded shadow-sm
                                            ${isSelected ? 'bg-blue-600 text-white' : 'bg-amber-900/30 text-amber-500'}
                                        `}>
                                            {label}
                                        </span>
                                        <span className={`flex-1 ${isSelected ? 'text-white font-medium' : 'text-zinc-300'}`}>
                                            {sibling.move?.notation || "開始"}
                                        </span>
                                        {isSelected && <div className="w-1.5 h-1.5 rounded-full bg-blue-500 animate-pulse"></div>}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                )}

                {/* 3. Comments Section */}
                <div className="p-3">
                    <div className="relative group">
                        <MessageSquare size={14} className="absolute top-3 left-3 text-zinc-500 group-focus-within:text-amber-500 transition-colors" />
                        <textarea 
                            className="w-full bg-zinc-950 border border-zinc-800 rounded-lg py-2 pl-9 pr-3 text-sm text-zinc-300 placeholder-zinc-600 focus:outline-none focus:ring-1 focus:ring-amber-500 resize-none h-16 transition-all custom-scrollbar"
                            placeholder="添加當前局面注釋..."
                            value={currentNode.comment}
                            onChange={(e) => onUpdateComment(currentNode.id, e.target.value)}
                        ></textarea>
                    </div>
                    {/* Fast Input Buttons */}
                    <div className="flex gap-2 mt-2 overflow-x-auto pb-1 no-scrollbar">
                        {['正著', '劣著', '失子', '飛刀', '妙手'].map(tag => (
                            <button 
                                key={tag}
                                onClick={() => onUpdateComment(currentNode.id, (currentNode.comment + " " + tag).trim())}
                                className="text-xs px-2 py-1 bg-zinc-800 hover:bg-zinc-700 border border-zinc-700 rounded text-zinc-400 whitespace-nowrap transition-colors"
                            >
                                {tag}
                            </button>
                        ))}
                    </div>
                </div>
            </div>
        </div>
    );
};


export const CloudPanel: React.FC = () => {
    return (
        <div className="flex flex-col h-full bg-zinc-900 border-x border-zinc-800 shadow-xl">
             {/* Header */}
             <div className="px-4 py-3 border-b border-zinc-800 bg-zinc-900/50 backdrop-blur-sm">
                <h3 className="font-bold text-zinc-200 flex items-center gap-2">
                    <span className="w-2 h-6 bg-blue-600 rounded-sm"></span>
                    雲庫分析
                </h3>
            </div>

            <div className="flex-1 overflow-y-auto p-4 custom-scrollbar flex flex-col gap-4">
                <button className="w-full py-3 bg-gradient-to-r from-blue-700 to-indigo-700 hover:from-blue-600 hover:to-indigo-600 text-white rounded-lg flex items-center justify-center gap-2 font-bold shadow-lg shadow-blue-900/30 transition-all active:scale-95 border border-blue-500/30">
                    <Activity size={18} />
                    立即分析當前局面
                </button>
                <div className="bg-zinc-950/50 rounded-lg p-6 border border-zinc-800 flex flex-col items-center text-center gap-3">
                    <div className="w-16 h-16 rounded-full bg-zinc-900 flex items-center justify-center border border-zinc-800">
                         <Cloud size={32} className="text-zinc-600" />
                    </div>
                    <div className="text-zinc-400 text-sm">
                        <span className="block font-medium text-zinc-300 text-lg mb-1">未連接雲庫</span>
                        <span className="text-xs text-zinc-500">請點擊上方按鈕連接引擎進行分析</span>
                    </div>
                </div>
            </div>
        </div>
    );
};

==============================
File Path: hooks\useMoveTree.ts
==============================

import { useState, useMemo, useCallback, useRef, useEffect } from 'react';
import { MoveNode, Piece, Point, MemorizationConfig, MemorizationError, PieceColor } from '../types';
import { INITIAL_BOARD_SETUP } from '../constants';
import { getFen, getChineseNotation, fenToBoard, validatePiecePlacement } from '../lib/utils';

export interface NotificationState {
    show: boolean;
    title: string;
    message: string;
    type: 'success' | 'error' | 'info';
}

export interface ConfirmState {
    show: boolean;
    title: string;
    message: string;
    onConfirm: () => void;
}

// Sound Helper
const playSound = (pieceType: string, isCapture: boolean, enabled: boolean) => {
    if (!enabled) return;
    try {
        const soundFile = isCapture 
            ? (pieceType === 'cannon' ? 'bomb' : 'eat') 
            : 'move';
        const audio = new Audio(`/sounds/${soundFile}.mp3`);
        audio.play().catch(() => {});
    } catch (e) {
        // Ignore audio errors
    }
};

export const useMoveTree = (enableSound: boolean = true) => {
    // 1. State
    const initialBoard = INITIAL_BOARD_SETUP();
    const initialFen = getFen(initialBoard, 'red');

    const [rootNode, setRootNode] = useState<MoveNode>({
        id: 'root',
        parentId: null,
        move: null,
        boardState: initialBoard,
        children: [],
        comment: '',
        turn: 'red',
        selectedChildId: null,
        fen: initialFen
    });

    const [currentNodeId, setCurrentNodeId] = useState<string>('root');
    const [notification, setNotification] = useState<NotificationState>({ show: false, title: '', message: '', type: 'info' });
    const [confirmState, setConfirmState] = useState<ConfirmState>({ show: false, title: '', message: '', onConfirm: () => {} });
    
    // Memorization State
    const [memConfig, setMemConfig] = useState<MemorizationConfig>({ active: false, side: 'red', mode: 'main', randomRange: '' });
    const [memErrors, setMemErrors] = useState<MemorizationError[]>([]);
    const [memTotalSteps, setMemTotalSteps] = useState(0);
    const [memStartNodeId, setMemStartNodeId] = useState<string>('root'); // Track where we started
    const [showReport, setShowReport] = useState(false);
    const computerTimeoutRef = useRef<number | null>(null);

    const closeNotification = () => setNotification(prev => ({ ...prev, show: false }));
    
    const showConfirm = (title: string, message: string, onConfirm: () => void) => {
        setConfirmState({ show: true, title, message, onConfirm });
    };

    const closeConfirm = () => {
        setConfirmState(prev => ({ ...prev, show: false }));
    };

    // 2. Helpers
    const findNodeById = (id: string, startNode: MoveNode): MoveNode | null => {
        if (startNode.id === id) return startNode;
        for (const child of startNode.children) {
            const found = findNodeById(id, child);
            if (found) return found;
        }
        return null;
    };

    const findNodeContext = (root: MoveNode, targetId: string) => {
        const search = (node: MoveNode, parent: MoveNode | null, index: number): { node: MoveNode, parent: MoveNode | null, index: number } | null => {
            if (node.id === targetId) return { node, parent, index };
            for (let i = 0; i < node.children.length; i++) {
                const result = search(node.children[i], node, i);
                if (result) return result;
            }
            return null;
        };
        return search(root, null, -1);
    };

    const getPathToNode = (targetId: string, startNode: MoveNode): MoveNode[] | null => {
        if (startNode.id === targetId) return [startNode];
        for (const child of startNode.children) {
            const path = getPathToNode(targetId, child);
            if (path) return [startNode, ...path];
        }
        return null;
    };

    // Fix: Round number calculation.
    // Length 1 (Root only) -> Round 1 (0/2 + 1)
    // Length 2 (Root + Red) -> Round 1 (1/2 + 1 = 1.5 -> 1)
    // Length 3 (Root + Red + Black) -> Round 2 (2/2 + 1 = 2)
    const getRoundNumber = (nodeId: string): number => {
        const path = getPathToNode(nodeId, rootNode);
        if (!path) return 1;
        return Math.floor((path.length - 1) / 2) + 1;
    };

    // 3. Computed Properties
    const currentNode = useMemo(() => {
        return findNodeById(currentNodeId, rootNode) || rootNode;
    }, [rootNode, currentNodeId]);

    const activePath = useMemo(() => {
        const pastPath = getPathToNode(currentNode.id, rootNode);
        if (!pastPath) return [rootNode];

        const futurePath: MoveNode[] = [];
        let curr = currentNode;
        let depth = 0;
        while (curr.children.length > 0 && depth < 200) {
            let nextChild = curr.selectedChildId 
                ? curr.children.find(c => c.id === curr.selectedChildId)
                : curr.children[0];
            if (!nextChild) nextChild = curr.children[0];
            futurePath.push(nextChild);
            curr = nextChild;
            depth++;
        }
        return [...pastPath, ...futurePath];
    }, [currentNode, rootNode]); 

    // --- Memorization: Computer Logic ---
    useEffect(() => {
        if (!memConfig.active) {
            if (computerTimeoutRef.current) clearTimeout(computerTimeoutRef.current);
            return;
        }
        
        // Find current node fresh
        const curr = findNodeById(currentNodeId, rootNode);
        if (!curr) return;

        // Check if game ended (leaf node)
        if (curr.children.length === 0) {
            computerTimeoutRef.current = window.setTimeout(() => {
                setMemConfig(prev => ({ ...prev, active: false }));
                setShowReport(true);
            }, 1000);
            return;
        }

        // Determine if it is Computer's turn
        const isPlayerTurn = memConfig.side === 'both' || curr.turn === memConfig.side;

        if (!isPlayerTurn) {
            // Computer moves
            computerTimeoutRef.current = window.setTimeout(() => {
                const candidates = curr.children;
                let nextNode: MoveNode | undefined;

                if (memConfig.mode === 'random') {
                    // Filter candidates based on randomRange (e.g., "A-C" or "A,B")
                    let allowedIndices = candidates.map((_, i) => i);
                    if (memConfig.randomRange) {
                        try {
                            const range = memConfig.randomRange.toUpperCase();
                            const parts = range.split(/[,\s]+/);
                            const whitelist: number[] = [];
                            parts.forEach(p => {
                                if (p.includes('-')) {
                                    const [start, end] = p.split('-');
                                    const s = start.charCodeAt(0) - 65;
                                    const e = end.charCodeAt(0) - 65;
                                    if (!isNaN(s) && !isNaN(e)) {
                                        for(let k=Math.min(s,e); k<=Math.max(s,e); k++) whitelist.push(k);
                                    }
                                } else {
                                    const idx = p.charCodeAt(0) - 65;
                                    if (!isNaN(idx)) whitelist.push(idx);
                                }
                            });
                            if (whitelist.length > 0) {
                                allowedIndices = allowedIndices.filter(i => whitelist.includes(i));
                            }
                        } catch (e) {
                            // ignore parse errors
                        }
                    }

                    if (allowedIndices.length === 0) allowedIndices = candidates.map((_, i) => i);
                    
                    const randIndex = allowedIndices[Math.floor(Math.random() * allowedIndices.length)];
                    nextNode = candidates[randIndex];
                } else {
                    // Main line (first child)
                    nextNode = candidates[0];
                }

                if (nextNode) {
                    setCurrentNodeId(nextNode.id);
                    if (nextNode.move) {
                        playSound(nextNode.move.piece.type, !!nextNode.move.captured, enableSound);
                    }
                }
            }, 800);
        }

        return () => {
            if (computerTimeoutRef.current) clearTimeout(computerTimeoutRef.current);
        };
    }, [memConfig, currentNodeId, rootNode, enableSound]);


    // 4. Actions

    // Import Game Logic
    const importGame = (fen: string, moves: { moveStr: string, notation: string, comment?: string }[], treeRoot?: MoveNode) => {
        if (treeRoot) {
            if (!treeRoot.comment) treeRoot.comment = '';
            setRootNode(treeRoot);
            setCurrentNodeId(treeRoot.id);
            return;
        }

        const { board, turn } = fenToBoard(fen);
        const newRoot: MoveNode = {
            id: 'root-' + Date.now(),
            parentId: null,
            move: null,
            boardState: board,
            children: [],
            comment: '',
            turn: turn,
            selectedChildId: null,
            fen: fen
        };

        let currentNode = newRoot;
        let currentBoard = board;
        let currentTurn = turn;

        for (const m of moves) {
            const [fromIdx, toIdx] = m.moveStr.split('-').map(Number);
            const from = { r: Math.floor(fromIdx / 9), c: fromIdx % 9 };
            const to = { r: Math.floor(toIdx / 9), c: toIdx % 9 };
            
            const piece = currentBoard[from.r][from.c];
            if (!piece) break;

            const captured = currentBoard[to.r][to.c];
            
            const newBoard = currentBoard.map(row => [...row]);
            newBoard[to.r][to.c] = piece;
            newBoard[from.r][from.c] = null;
            
            const nextTurn = currentTurn === 'red' ? 'black' : 'red';
            const newFen = getFen(newBoard, nextTurn);

            const newNode: MoveNode = {
                id: 'node-' + Date.now() + Math.random().toString().slice(2, 6),
                parentId: currentNode.id,
                move: { from, to, piece, captured, notation: m.notation },
                boardState: newBoard,
                children: [],
                comment: m.comment || '',
                turn: nextTurn,
                selectedChildId: null,
                fen: newFen
            };

            currentNode.children.push(newNode);
            currentNode.selectedChildId = newNode.id;
            
            currentNode = newNode;
            currentBoard = newBoard;
            currentTurn = nextTurn;
        }

        setRootNode(newRoot);
        setCurrentNodeId(newRoot.id);
    };

    const addMove = (moveData: { from: Point; to: Point; piece: Piece; captured: Piece | null; notation: string }, newBoard: (Piece|null)[][]) => {
        // --- Memorization Mode Handling ---
        if (memConfig.active) {
            const curr = findNodeById(currentNodeId, rootNode);
            if (!curr) return false;

            const isPlayerTurn = memConfig.side === 'both' || curr.turn === memConfig.side;
            if (!isPlayerTurn) return false; // Prevent moving during computer turn

            // Check if the move matches any child
            const matchedChild = curr.children.find(child => {
                if (!child.move) return false;
                const m = child.move;
                return m.from.r === moveData.from.r && m.from.c === moveData.from.c &&
                       m.to.r === moveData.to.r && m.to.c === moveData.to.c;
            });

            if (matchedChild) {
                // Correct Move
                setCurrentNodeId(matchedChild.id);
                playSound(moveData.piece.type, !!moveData.captured, enableSound);
                setMemTotalSteps(n => n + 1);
                return true;
            } else {
                // Wrong Move
                const round = getRoundNumber(curr.id);
                setMemErrors(prev => {
                    const idx = prev.findIndex(e => e.nodeId === curr.id);
                    if (idx >= 0) {
                        const newArr = [...prev];
                        newArr[idx] = { ...newArr[idx], count: newArr[idx].count + 1 };
                        return newArr;
                    } else {
                        const corrects = curr.children.map(c => c.move?.notation || '未知');
                        return [...prev, { round, nodeId: curr.id, correctNotations: corrects, count: 1 }];
                    }
                });
                return false; // Triggers flash
            }
        }

        // --- Standard Edit/Play Mode ---
        playSound(moveData.piece.type, !!moveData.captured, enableSound);

        const newRoot = JSON.parse(JSON.stringify(rootNode));
        const ctx = findNodeContext(newRoot, currentNodeId);
        if (!ctx) return false; 
        const nodeInNewTree = ctx.node;

        const existingChild = nodeInNewTree.children.find((child: MoveNode) => child.move?.notation === moveData.notation);

        if (existingChild) {
            nodeInNewTree.selectedChildId = existingChild.id;
            setRootNode(newRoot);
            setCurrentNodeId(existingChild.id);
        } else {
            const nextTurn = nodeInNewTree.turn === 'red' ? 'black' : 'red';
            const newFen = getFen(newBoard, nextTurn);

            const newNode: MoveNode = {
                id: Date.now().toString() + Math.random().toString().slice(2,6),
                parentId: nodeInNewTree.id,
                move: moveData,
                boardState: newBoard,
                children: [],
                comment: '',
                turn: nextTurn,
                selectedChildId: null,
                fen: newFen
            };
            
            nodeInNewTree.children.push(newNode);
            nodeInNewTree.selectedChildId = newNode.id;
            setRootNode(newRoot);
            setCurrentNodeId(newNode.id);
        }
        return true;
    };

    const getHint = useCallback(() => {
        const curr = findNodeById(currentNodeId, rootNode);
        if (!curr || curr.children.length === 0) return null;
        // Basic hint: show the move of the selected child or first child
        // In random mode, this is a bit ambiguous as there are multiple correct answers, 
        // but showing *a* correct answer is usually enough.
        const target = curr.selectedChildId 
            ? curr.children.find(c => c.id === curr.selectedChildId) 
            : curr.children[0];
        
        return target?.move ? { from: target.move.from, to: target.move.to } : null;
    }, [currentNodeId, rootNode]);

    const jumpToMove = (targetNode: MoveNode) => {
        if (memConfig.active) return; 
        const newRoot = JSON.parse(JSON.stringify(rootNode));
        const getPath = (r: MoveNode, tId: string): MoveNode[] | null => {
            if (r.id === tId) return [r];
            for (const c of r.children) {
                const res = getPath(c, tId);
                if (res) return [r, ...res];
            }
            return null;
        };
        const path = getPath(newRoot, targetNode.id);
        if (path) {
            for (let i = 0; i < path.length - 1; i++) {
                path[i].selectedChildId = path[i+1].id;
            }
        }
        setRootNode(newRoot);
        setCurrentNodeId(targetNode.id);
    };

    const updateComment = (id: string, text: string) => {
        const newRoot = JSON.parse(JSON.stringify(rootNode));
        const ctx = findNodeContext(newRoot, id);
        if (ctx) {
            ctx.node.comment = text;
            setRootNode(newRoot);
        }
    };

    const batchUpdateComments = (updates: {id: string, text: string}[]) => {
        const newRoot = JSON.parse(JSON.stringify(rootNode));
        let updatedCount = 0;
        updates.forEach(({id, text}) => {
             const ctx = findNodeContext(newRoot, id);
             if (ctx) {
                 ctx.node.comment = text;
                 updatedCount++;
             }
        });
        if (updatedCount > 0) setRootNode(newRoot);
    };

    const deleteCurrentMove = () => {
        if (currentNodeId === 'root') {
             setNotification({ show: true, title: '操作無效', message: '無法刪除起始局面。', type: 'error' });
             return;
        }
        // Use general deleteNode logic
        deleteNode(currentNodeId);
    };

    // 新增：通用節點刪除邏輯
    const deleteNode = (nodeId: string) => {
        if (nodeId === 'root') return;
        
        const newRoot = JSON.parse(JSON.stringify(rootNode));
        const ctx = findNodeContext(newRoot, nodeId);
        
        if (!ctx || !ctx.parent) return;
        const { parent, index } = ctx;
        
        // Remove from parent
        parent.children.splice(index, 1);
        
        // Determine fallback node (stay on parent, or switch to sibling)
        let nextNodeId = parent.id; 
        
        // If the deleted node was the 'selected' one, we need to update selection
        if (parent.selectedChildId === nodeId) {
            if (parent.children.length > 0) {
                // Select previous or first sibling
                const newIndex = Math.min(index, parent.children.length - 1);
                const sibling = parent.children[newIndex];
                parent.selectedChildId = sibling.id;
            } else {
                parent.selectedChildId = null;
            }
        }
        
        // Check if the current view (currentNodeId) is inside the deleted branch
        const exists = findNodeById(currentNodeId, newRoot);
        
        if (!exists) {
            if (parent.selectedChildId) {
                nextNodeId = parent.selectedChildId;
            } else {
                nextNodeId = parent.id;
            }
            setCurrentNodeId(nextNodeId);
        }

        setRootNode(newRoot);
        setNotification({ show: true, title: '刪除成功', message: '已刪除該著法。', type: 'success' });
    };

    const reorderChildren = (childId: string, direction: 'up' | 'down') => {
        const newRoot = JSON.parse(JSON.stringify(rootNode));
        const ctx = findNodeContext(newRoot, childId);
        if (ctx && ctx.parent) {
            const { parent, index } = ctx;
            const siblings = parent.children;
            if (direction === 'up' && index > 0) {
                [siblings[index], siblings[index - 1]] = [siblings[index - 1], siblings[index]];
                setRootNode(newRoot);
            } else if (direction === 'down' && index < siblings.length - 1) {
                [siblings[index], siblings[index + 1]] = [siblings[index + 1], siblings[index]];
                setRootNode(newRoot);
            }
        }
    };

    const linkMovesByFen = () => {
        const newRoot = JSON.parse(JSON.stringify(rootNode));
        const targetFen = currentNode.fen;
        const targetFenBase = targetFen.split(' ').slice(0, 2).join(' ');
        const matchingNodes: MoveNode[] = [];
        const traverse = (n: MoveNode) => {
            const nFenBase = n.fen.split(' ').slice(0, 2).join(' ');
            if (nFenBase === targetFenBase) matchingNodes.push(n);
            n.children.forEach(traverse);
        };
        traverse(newRoot);
        if (matchingNodes.length < 2) {
            setNotification({ show: true, title: '無需串聯', message: '此局面在當前棋譜中是唯一的。', type: 'info' });
            return;
        }
        setNotification({ show: true, title: '串聯完成', message: '相同局面已同步。', type: 'success' });
    };

    const navigate = useCallback((direction: 'prev' | 'next' | 'start' | 'end') => {
        if (memConfig.active) return;
        if (direction === 'start') { setCurrentNodeId(rootNode.id); return; }
        const curr = findNodeById(currentNodeId, rootNode);
        if (!curr) return;
        if (direction === 'prev') {
            if (curr.parentId) setCurrentNodeId(curr.parentId);
        } else if (direction === 'next') {
            if (curr.children.length > 0) {
                const nextId = curr.selectedChildId || curr.children[0].id;
                setCurrentNodeId(nextId);
            }
        } else if (direction === 'end') {
            let temp = curr;
            while(temp.children.length > 0) {
                const nextChild = temp.selectedChildId ? temp.children.find(c => c.id === temp.selectedChildId) : temp.children[0];
                if (nextChild) temp = nextChild; else temp = temp.children[0];
            }
            setCurrentNodeId(temp.id);
        }
    }, [currentNodeId, rootNode, memConfig.active]);

    // Enhanced navigateVariation: Search for next/prev variation node (The node that IS a variation)
    const navigateVariation = useCallback((direction: 'prev' | 'next') => {
        if (memConfig.active) return;
        
        let curr = findNodeById(currentNodeId, rootNode);
        if (!curr) return;

        if (direction === 'prev') {
            // Step 1: Move up from current node first to avoid staying on current if it is already a variation
            if (curr.parentId) {
                curr = findNodeById(curr.parentId, rootNode);
            } else {
                setNotification({ show: true, title: '提示', message: '無上一個變著節點', type: 'info' });
                return;
            }

            // Step 2: Walk up the tree
            while (curr && curr.parentId) {
                const parent = findNodeById(curr.parentId, rootNode);
                if (!parent) break;
                
                // Check if PARENT has multiple children. 
                // If yes, then CURR is a "Variation Node" (one of the choices).
                if (parent.children.length > 1) {
                    setCurrentNodeId(curr.id); // Jump to CURR (the child)
                    return;
                }
                
                curr = parent; // Move up
            }
            setNotification({ show: true, title: '提示', message: '無上一個變著節點', type: 'info' });
        } else {
            // Walk down
            // Search strictly AFTER the current node
            while (curr.children.length > 0) {
                // Check if CURRENT node is a branching point.
                // If yes, the CHILD (next node in path) is the "Variation Node".
                if (curr.children.length > 1) {
                    const nextId = curr.selectedChildId || curr.children[0].id;
                    setCurrentNodeId(nextId); // Jump to the child
                    return;
                }
                
                // Advance to next node
                const nextId = curr.selectedChildId || curr.children[0].id;
                curr = curr.children.find(c => c.id === nextId) || curr.children[0];
            }
            setNotification({ show: true, title: '提示', message: '無下一個變著節點', type: 'info' });
        }
    }, [currentNodeId, rootNode, memConfig.active]);

    const jumpToStep = useCallback((stepIndex: number) => {
        if (memConfig.active) return;
        const getPath = (n: MoveNode): MoveNode[] => {
            let path = [n];
            let curr = n;
            while (curr.children.length > 0) {
                 let next = curr.selectedChildId ? curr.children.find(c => c.id === curr.selectedChildId) : curr.children[0];
                 if (!next) next = curr.children[0];
                 path.push(next);
                 curr = next;
            }
            return path;
        };
        const fullPath = getPath(rootNode);
        if (stepIndex >= 0 && stepIndex < fullPath.length) {
            setCurrentNodeId(fullPath[stepIndex].id);
        }
    }, [rootNode, memConfig.active]);

    const startMemorization = (config: any) => { 
        setMemConfig({ ...config, active: true }); 
        setMemErrors([]);
        setMemTotalSteps(0);
        setMemStartNodeId(currentNodeId); // Track where we started
    };
    
    // Updated: stopMemorization now shows the report
    const stopMemorization = () => { 
        setMemConfig(prev => ({ ...prev, active: false }));
        setShowReport(true);
    };

    const setRootNodePublic = (node: MoveNode) => {
        setRootNode(node);
        setCurrentNodeId(node.id);
    };

    return {
        currentNode,
        rootNode,
        activePath,
        addMove,
        importGame, 
        jumpToMove,
        updateComment,
        batchUpdateComments,
        deleteCurrentMove,
        deleteNode,
        reorderChildren,
        linkMovesByFen,
        navigate,
        navigateVariation,
        jumpToStep,
        notification,
        closeNotification,
        confirmState,
        showConfirm,
        closeConfirm,
        setRootNode: setRootNodePublic,
        memConfig,
        memErrors,
        memTotalSteps,
        memStartNodeId,
        getHint,
        showReport,
        startMemorization,
        stopMemorization,
        setShowReport
    };
};


==============================
File Path: lib\exporter.ts
==============================

import { MoveNode, GameMetadata } from '../types';

const toPgnCoord = (r: number, c: number): string => {
    const files = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
    const rank = 9 - r;
    return `${files[c]}${rank}`;
};

const toDhtmlXQCoord = (r: number, c: number): string => {
    return `${c}${9 - r}`;
};

export const Exporter = {

    generateDhtmlXQ(root: MoveNode, meta: GameMetadata): string {
        let out = '[DhtmlXQ]\n';
        out += `[DhtmlXQ_ver]www_dpxq_com[/DhtmlXQ_ver]\n`;
        out += `[DhtmlXQ_init]500,350[/DhtmlXQ_init]\n`;
        out += `[DhtmlXQ_pver]1300700002[/DhtmlXQ_pver]\n`;

        if (meta.title) out += `[DhtmlXQ_title]${meta.title}[/DhtmlXQ_title]\n`;
        if (meta.event) out += `[DhtmlXQ_event]${meta.event}[/DhtmlXQ_event]\n`;
        if (meta.date) out += `[DhtmlXQ_date]${meta.date}[/DhtmlXQ_date]\n`;
        if (meta.redName) out += `[DhtmlXQ_red]${meta.redName}[/DhtmlXQ_red]\n`;
        if (meta.blackName) out += `[DhtmlXQ_black]${meta.blackName}[/DhtmlXQ_black]\n`;
        if (meta.result !== 'unknown') {
            const resMap = { red: '紅勝', black: '黑勝', draw: '和局' };
            out += `[DhtmlXQ_result]${resMap[meta.result] || ''}[/DhtmlXQ_result]\n`;
        }

        if (root.boardState) {
            const binit = this.generateBinit(root.boardState);
            out += `[DhtmlXQ_binit]${binit}[/DhtmlXQ_binit]\n`;
        }

        if (root.fen) {
            out += `[DhtmlXQ_fen]${root.fen}[/DhtmlXQ_fen]\n`;
        }

        const firstNum = root.turn === 'black' ? 1 : 0;
        out += `[DhtmlXQ_firstnum]${firstNum}[/DhtmlXQ_firstnum]\n`;

        const resultList: string[] = [];
        const commentResult: string[] = [];
        let branchCounter = 0; 

        if (root.comment) {
            commentResult.push(`[DhtmlXQ_comment0]${root.comment.replace(/\n/g, '||')}[/DhtmlXQ_comment0]`);
        }

        const variationQueue: { node: MoveNode, parentIdx: number, parentSteps: number, branchIdx: number }[] = [];

        const processBranch = (startNode: MoveNode, parentIdx: number, parentSteps: number, branchIdx: number) => {
            let movesStr = '';
            let current: MoveNode | null = startNode;
            let step = 0;

            while (current) {
                if (current.move) {
                    const f = current.move.from;
                    const t = current.move.to;
                    movesStr += `${toDhtmlXQCoord(f.r, f.c)}${toDhtmlXQCoord(t.r, t.c)}`;
                }

                if (current.comment) {
                    const currentTotalStep = parentSteps + step;
                    const tag = branchIdx === 0 ? `[DhtmlXQ_comment${currentTotalStep}]` : `[DhtmlXQ_comment${branchIdx}_${currentTotalStep}]`;
                    commentResult.push(`${tag}${current.comment.replace(/\n/g, '||')}${tag.replace('[', '[/')}`);
                }

                if (current.children.length > 1) {
                    for (let i = 1; i < current.children.length; i++) {
                        const child = current.children[i];
                        branchCounter++;
                        variationQueue.push({
                            node: child,
                            parentIdx: branchIdx,
                            parentSteps: parentSteps + step + 1,
                            branchIdx: branchCounter
                        });
                    }
                }

                current = (current.children && current.children.length > 0) ? current.children[0] : null;
                if (current) step++;
            }

            if (branchIdx === 0) {
                resultList.push(`[DhtmlXQ_movelist]${movesStr}[/DhtmlXQ_movelist]`);
            } else {
                resultList.push(`[DhtmlXQ_move_${parentIdx}_${parentSteps}_${branchIdx}]${movesStr}[/DhtmlXQ_move_${parentIdx}_${parentSteps}_${branchIdx}]`);
            }
        };

        if (root.children && root.children.length > 0) {
            processBranch(root.children[0], 0, 1, 0);
            for (let i = 1; i < root.children.length; i++) {
                branchCounter++;
                variationQueue.push({
                    node: root.children[i],
                    parentIdx: 0,
                    parentSteps: 1,
                    branchIdx: branchCounter
                });
            }
        } else {
            resultList.push(`[DhtmlXQ_movelist][/DhtmlXQ_movelist]`);
        }

        while (variationQueue.length > 0) {
            const varData = variationQueue.shift()!;
            processBranch(varData.node, varData.parentIdx, varData.parentSteps, varData.branchIdx);
        }

        out += resultList.join('\n') + '\n';
        out += commentResult.join('\n') + '\n';
        out += `[DhtmlXQ_generator]AI_Studio_CloudNote[/DhtmlXQ_generator]\n`;
        out += '[/DhtmlXQ]';

        return out;
    },

    generateBinit(board: any[][]): string {
        const slots: string[] = Array(32).fill("99");
        const findPieces = (color: 'red' | 'black', type: string): { r: number, c: number }[] => {
            const points: { r: number, c: number }[] = [];
            for (let r = 0; r < 10; r++) {
                for (let c = 0; c < 9; c++) {
                    const p = board[r][c];
                    if (p && p.color === color && p.type === type) { points.push({ r, c }); }
                }
            }
            return points.sort((a, b) => (a.r - b.r) || (a.c - b.c));
        };
        const fillSlots = (color: 'red' | 'black', offset: number) => {
            const assign = (type: string, indices: number[]) => {
                const pieces = findPieces(color, type);
                indices.forEach((slotIdx, i) => {
                    if (pieces[i]) { slots[offset + slotIdx] = `${pieces[i].c}${9 - pieces[i].r}`; }
                });
            };
            assign('chariot', [0, 8]); assign('horse', [1, 7]); assign('elephant', [2, 6]); assign('advisor', [3, 5]); assign('king', [4]); assign('cannon', [9, 10]); assign('soldier', [11, 12, 13, 14, 15]);
        };
        fillSlots('black', 0); fillSlots('red', 16);
        return slots.join("");
    },

    generatePGN(root: MoveNode, meta: GameMetadata): string {
        let resLabel = '對局';
        if (meta.result === 'red') resLabel = '先勝';
        else if (meta.result === 'black') resLabel = '後勝';
        else if (meta.result === 'draw') resLabel = '和局';
        const dynamicTitle = `${meta.redName || '紅方'} ${resLabel} ${meta.blackName || '黑方'}`;

        let out = '';
        out += `[Game "Chinese Chess"]\n`;
        out += `[Title "${meta.title || dynamicTitle}"]\n`;
        out += `[Event "${meta.event || ''}"]\n`;
        out += `[Red "${meta.redName || 'Unknown'}"]\n`;
        out += `[RedTeam ""]\n`;
        out += `[Black "${meta.blackName || 'Unknown'}"]\n`;
        out += `[BlackName ""]\n`;
        out += `[Opening "${meta.title || ''}"]\n`;
        out += `[Date "${meta.date?.replace(/-/g, '.') || ''}"]\n`;
        out += `[Site ""]\n`;
        out += `[Round ""]\n`;
        out += `[Format "ICCS"]\n`;

        let resStr = '*';
        if (meta.result === 'red') resStr = '1-0';
        else if (meta.result === 'black') resStr = '0-1';
        else if (meta.result === 'draw') resStr = '1/2-1/2';
        out += `[Result "${resStr}"]\n`;

        const standardFen = "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1";
        if (root.fen && root.fen.split(' ')[0] !== standardFen.split(' ')[0]) {
            out += `[FEN "${root.fen}"]\n`;
        }

        out += '\n';

        const mainLineMoves: string[] = [];
        let curr: MoveNode | null = root;
        if (root.children.length > 0) {
            curr = root.selectedChildId ? root.children.find(c => c.id === root.selectedChildId)! : root.children[0];
            while (curr) {
                if (curr.move) {
                    mainLineMoves.push(this.getPgnMoveString(curr));
                }
                if (curr.children.length > 0) {
                    curr = curr.selectedChildId ? curr.children.find(c => c.id === curr.selectedChildId)! : curr.children[0];
                } else {
                    curr = null;
                }
            }
        }

        for (let i = 0; i < mainLineMoves.length; i += 2) {
            const roundNum = Math.floor(i / 2) + 1;
            const redMove = mainLineMoves[i];
            const blackMove = mainLineMoves[i + 1] || "";
            
            out += `${roundNum}. ${redMove} ${blackMove}`;
            if (i + 2 >= mainLineMoves.length) {
                out += ` ${resStr}\n`;
            } else {
                out += `\n`;
            }
        }

        if (mainLineMoves.length === 0) {
            out += resStr + "\n";
        }

        return out;
    },

    getPgnMoveString(node: MoveNode): string {
        if (!node.move) return '00-00';
        const { from, to } = node.move;
        return `${toPgnCoord(from.r, from.c)}-${toPgnCoord(to.r, to.c)}`;
    },

    generateText(root: MoveNode, meta: GameMetadata): string {
        let out = '';
        if (meta.title) out += `標題：${meta.title}\n`;
        if (meta.redName) out += `紅方：${meta.redName}\n`;
        if (meta.blackName) out += `黑方：${meta.blackName}\n`;
        if (meta.result !== 'unknown') out += `結果：${meta.result === 'red' ? '紅勝' : meta.result === 'black' ? '黑勝' : '和局'}\n`;
        out += '\n';

        let curr = root;
        const moves: string[] = [];

        while (curr.children.length > 0) {
            const next = curr.selectedChildId ? curr.children.find(c => c.id === curr.selectedChildId) : curr.children[0];
            if (!next || !next.move) break;
            moves.push(next.move.notation);
            curr = next;
        }

        for (let i = 0; i < moves.length; i += 2) {
            const redM = moves[i];
            const blackM = moves[i + 1] || '';
            out += `${Math.floor(i / 2) + 1}. ${redM}  ${blackM}\n`;
        }

        return out;
    },

    generateFenMove(root: MoveNode): string {
        let fen = root.fen;
        let out = `${fen} moves`;
        let curr = root;
        while (curr.children.length > 0) {
            const next = curr.selectedChildId ? curr.children.find(c => c.id === curr.selectedChildId) : curr.children[0];
            if (!next || !next.move) break;
            const f = next.move.from;
            const t = next.move.to;
            const iccsSimple = `${toPgnCoord(f.r, f.c).toLowerCase()}${toPgnCoord(t.r, t.c).toLowerCase()}`;
            out += ` ${iccsSimple}`;
            curr = next;
        }
        return out;
    }
};


==============================
File Path: lib\gifGenerator.ts
==============================

import { MoveNode, Piece, GameMetadata } from '../types';
import { GIF_WORKER_SOURCE } from './gifWorkerSource';

interface GifConfig {
    startRound: number;
    endRound: number;
    interval: number;
    quality: number;
    width: number;
}

export const generateGif = async (
    rootNode: MoveNode,
    activePath: MoveNode[],
    metadata: GameMetadata,
    config: GifConfig,
    onProgress: (progress: number, status: string) => void
): Promise<Blob> => {

    // @ts-ignore
    if (!window.GIF) {
        throw new Error("GIF Library not loaded. Please refresh the page.");
    }

    // --- 嚴格尺寸鎖定 (8 的倍數) ---
    const MARGIN = 40;
    const RAW_WIDTH = config.width;
    const GRID_SIZE = Math.floor((RAW_WIDTH - MARGIN * 2) / 8);

    // 固定寬度為 8 的倍數
    const ACTUAL_WIDTH = Math.floor((GRID_SIZE * 8 + MARGIN * 2) / 8) * 8;
    const ACTUAL_BOARD_HEIGHT = GRID_SIZE * 9 + MARGIN * 2;

    // 計算標題高度
    const paddingY = 24;
    // 使用較大的行高，因為字體變大了
    const lineHeight = Math.floor(GRID_SIZE * 0.9); 
    const titleLines = metadata.title ? 1 : 0;
    const playerLines = (metadata.redName || metadata.blackName) ? 1 : 0;

    let headerHeight = 0;
    if (titleLines + playerLines > 0) {
        headerHeight = paddingY + (titleLines * Math.floor(lineHeight * 1.3)) + (playerLines * lineHeight) + paddingY;
    }

    // 固定總高度為 8 的倍數
    const TOTAL_HEIGHT = Math.ceil((headerHeight + ACTUAL_BOARD_HEIGHT) / 8) * 8;

    // --- Create Worker Blob URL to bypass CORS ---
    const workerBlob = new Blob([GIF_WORKER_SOURCE], { type: 'application/javascript' });
    const workerScriptUrl = URL.createObjectURL(workerBlob);

    // --- 使用 CDN 的官方 Worker 腳本 ---
    // @ts-ignore
    const gif = new window.GIF({
        workers: 2,
        quality: 10,
        // 使用 Blob URL
        workerScript: workerScriptUrl,
        width: ACTUAL_WIDTH,
        height: TOTAL_HEIGHT,
        transparent: null
    });

    // --- 繪圖邏輯 ---
    const canvas = document.createElement('canvas');
    canvas.width = ACTUAL_WIDTH;
    canvas.height = TOTAL_HEIGHT;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    if (!ctx) throw new Error("Could not create canvas");

    const drawBoard = (board: (Piece | null)[][]) => {
        ctx.save();

        // A. 背景
        ctx.fillStyle = '#18181b';
        ctx.fillRect(0, 0, ACTUAL_WIDTH, headerHeight);

        const boardY = headerHeight;
        const grad = ctx.createLinearGradient(0, boardY, 0, TOTAL_HEIGHT);
        grad.addColorStop(0, '#cbbfa0');
        grad.addColorStop(1, '#bba98b');
        ctx.fillStyle = grad;
        ctx.fillRect(0, boardY, ACTUAL_WIDTH, ACTUAL_BOARD_HEIGHT);

        // B. 文字
        let textY = paddingY;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';

        // 字體大小設定：與楚河漢界 (GRID_SIZE * 0.55) 一致或稍大
        const nameFontSize = Math.floor(GRID_SIZE * 0.55);
        const nameFontStyle = `bold ${nameFontSize}px "KaiTi", "STKaiti", "Microsoft JhengHei", sans-serif`;

        if (metadata.title) {
            ctx.font = `bold ${Math.floor(GRID_SIZE * 0.65)}px "KaiTi", "STKaiti", "Microsoft JhengHei", sans-serif`;
            ctx.fillStyle = '#fbbf24';
            ctx.fillText(metadata.title, ACTUAL_WIDTH / 2, textY);
            textY += Math.floor(lineHeight * 1.3);
        }

        if (playerLines > 0) {
            ctx.font = nameFontStyle;
            const cx = ACTUAL_WIDTH / 2;
            const gap = Math.floor(GRID_SIZE * 0.8); // 名字與中間文字的間距

            const redName = metadata.redName || '';
            const blackName = metadata.blackName || '';
            const result = metadata.result;

            // 1. 紅方姓名 (靠右對齊)
            if (redName) {
                ctx.textAlign = 'right';
                ctx.fillStyle = '#f87171'; // 紅色
                ctx.fillText(redName, cx - gap/2, textY);
            }

            // 2. 中間文字邏輯 (VS / 勝 / 負 / 和)
            let centerText = '';
            let centerColor = '#71717a'; // 默認灰色
            let rightSuffix = ''; // 特殊情況：僅黑方有名字時，"負"或"和"顯示在黑方右邊

            if (result === 'red') {
                // 紅勝
                if (redName) { 
                    centerText = '勝'; 
                    centerColor = '#ef4444'; // 鮮紅
                }
            } else if (result === 'black') {
                // 黑勝 (紅負)
                if (redName) { 
                    centerText = '負'; 
                    centerColor = '#22c55e'; // 綠色
                } else if (blackName) {
                    rightSuffix = ' 負'; // 只填黑方，顯示 "黑方 負"
                }
            } else if (result === 'draw') {
                // 和棋
                if (redName || blackName) {
                    if (!redName && blackName) {
                        rightSuffix = ' 和';
                    } else {
                        centerText = '和';
                        centerColor = '#3b82f6'; // 藍色
                    }
                }
            } else {
                // 未知
                if (redName && blackName) {
                    centerText = 'VS';
                }
            }

            // 繪製中間文字
            if (centerText) {
                ctx.textAlign = 'center';
                ctx.fillStyle = centerColor;
                ctx.fillText(centerText, cx, textY);
            }

            // 3. 黑方姓名 (靠左對齊)
            if (blackName) {
                ctx.textAlign = 'left';
                ctx.fillStyle = '#a1a1aa'; // 淺灰
                const displayText = blackName + rightSuffix;
                ctx.fillText(displayText, cx + gap/2, textY);
            }
        }

        // C. 棋盤線
        ctx.translate(MARGIN, boardY + MARGIN);
        ctx.strokeStyle = '#3d2b1f';
        ctx.lineWidth = 1.6;

        for (let i = 0; i < 10; i++) {
            ctx.beginPath();
            ctx.moveTo(0, Math.floor(i * GRID_SIZE));
            ctx.lineTo(Math.floor(8 * GRID_SIZE), Math.floor(i * GRID_SIZE));
            ctx.stroke();
        }
        for (let j = 0; j < 9; j++) {
            const x = Math.floor(j * GRID_SIZE);
            if (j === 0 || j === 8) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, Math.floor(9 * GRID_SIZE)); ctx.stroke();
            } else {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, Math.floor(4 * GRID_SIZE)); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(x, Math.floor(5 * GRID_SIZE)); ctx.lineTo(x, Math.floor(9 * GRID_SIZE)); ctx.stroke();
            }
        }
        const drawX = (baseR: number) => {
            const y1 = Math.floor(baseR * GRID_SIZE);
            const y2 = Math.floor((baseR + 2) * GRID_SIZE);
            const x1 = Math.floor(3 * GRID_SIZE);
            const x2 = Math.floor(5 * GRID_SIZE);
            ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x2, y1); ctx.lineTo(x1, y2); ctx.stroke();
        };
        drawX(0); drawX(7);

        // 砲台/兵營裝飾符號
        const drawCorner = (cx: number, cy: number, skipLeft: boolean, skipRight: boolean) => {
            const len = Math.floor(GRID_SIZE * 0.18);
            const gap = Math.floor(GRID_SIZE * 0.08);
            ctx.lineWidth = 1.2;
            if (!skipLeft) {
                // 左上
                ctx.beginPath(); ctx.moveTo(cx - gap - len, cy - gap); ctx.lineTo(cx - gap, cy - gap); ctx.lineTo(cx - gap, cy - gap - len); ctx.stroke();
                // 左下
                ctx.beginPath(); ctx.moveTo(cx - gap - len, cy + gap); ctx.lineTo(cx - gap, cy + gap); ctx.lineTo(cx - gap, cy + gap + len); ctx.stroke();
            }
            if (!skipRight) {
                // 右上
                ctx.beginPath(); ctx.moveTo(cx + gap + len, cy - gap); ctx.lineTo(cx + gap, cy - gap); ctx.lineTo(cx + gap, cy - gap - len); ctx.stroke();
                // 右下
                ctx.beginPath(); ctx.moveTo(cx + gap + len, cy + gap); ctx.lineTo(cx + gap, cy + gap); ctx.lineTo(cx + gap, cy + gap + len); ctx.stroke();
            }
        };
        // 砲台位置
        [[1, 2], [7, 2], [1, 7], [7, 7]].forEach(([col, row]) => {
            drawCorner(Math.floor(col * GRID_SIZE), Math.floor(row * GRID_SIZE), col === 0, col === 8);
        });
        // 兵/卒位置
        [[0, 3], [2, 3], [4, 3], [6, 3], [8, 3], [0, 6], [2, 6], [4, 6], [6, 6], [8, 6]].forEach(([col, row]) => {
            drawCorner(Math.floor(col * GRID_SIZE), Math.floor(row * GRID_SIZE), col === 0, col === 8);
        });

        ctx.font = `bold ${Math.floor(GRID_SIZE * 0.55)}px "KaiTi", serif`;
        ctx.fillStyle = '#3d2b1f';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const riverY = Math.floor(4.5 * GRID_SIZE);
        ctx.fillText("楚 河", Math.floor(2 * GRID_SIZE), riverY);
        ctx.fillText("漢 界", Math.floor(6 * GRID_SIZE), riverY);

        // D. 棋子
        for (let r = 0; r < 10; r++) {
            for (let c = 0; c < 9; c++) {
                const p = board[r][c];
                if (p) {
                    const x = Math.floor(c * GRID_SIZE);
                    const y = Math.floor(r * GRID_SIZE);
                    const radius = Math.floor(GRID_SIZE * 0.45);

                    ctx.save();
                    ctx.shadowColor = "rgba(0,0,0,0.3)";
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetY = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);

                    if (p.color === 'red') {
                        ctx.fillStyle = '#fdfdfd';
                        ctx.strokeStyle = '#a61c1c';
                    } else {
                        const gradP = ctx.createRadialGradient(x - 3, y - 3, 2, x, y, radius);
                        gradP.addColorStop(0, '#2563eb');
                        gradP.addColorStop(1, '#1e3a8a');
                        ctx.fillStyle = gradP;
                        ctx.strokeStyle = '#000000';
                    }
                    ctx.fill();
                    ctx.shadowColor = "transparent";
                    ctx.lineWidth = 2.5;
                    ctx.stroke();

                    if (p.color === 'red') {
                        ctx.beginPath();
                        ctx.arc(x, y, radius - 4, 0, Math.PI * 2);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = '#e5e5e5';
                        ctx.stroke();
                        ctx.fillStyle = '#a61c1c';
                    } else {
                        ctx.fillStyle = '#ffffff';
                    }

                    const fontSize = Math.floor(GRID_SIZE * 0.65);
                    ctx.font = `bold ${fontSize}px "KaiTi", serif`;
                    ctx.textBaseline = 'middle';
                    // 修正：稍微增加偏移量 (0.01 -> 0.05) 以確保文字視覺置中
                    ctx.fillText(p.text, x, y + Math.floor(GRID_SIZE * 0.05));
                    ctx.restore();
                }
            }
        }
        ctx.restore();
    };

    const startIdx = Math.max(0, config.startRound);
    const endIdx = Math.min(activePath.length - 1, config.endRound);
    const totalFrames = endIdx - startIdx + 1;

    for (let i = startIdx; i <= endIdx; i++) {
        const node = activePath[i];
        const pct = Math.round(((i - startIdx) / totalFrames) * 90);
        onProgress(pct, `正在處理第 ${i} 回合影格...`);

        // 每次渲染前清空畫布
        ctx.fillStyle = '#18181b';
        ctx.fillRect(0, 0, ACTUAL_WIDTH, TOTAL_HEIGHT);
        drawBoard(node.boardState);

        const delay = (i === endIdx) ? 3000 : config.interval * 1000;

        // 使用傳遞畫布對象並開啟複製模式
        gif.addFrame(canvas, { copy: true, delay });

        await new Promise(r => setTimeout(r, 0));
    }

    onProgress(95, "正在進行最後編碼 (請稍候)...");

    return new Promise((resolve, reject) => {
        gif.on('finished', (blob: Blob) => {
            // Clean up the object URL
            URL.revokeObjectURL(workerScriptUrl);
            onProgress(100, "匯出完成！");
            resolve(blob);
        });
        gif.on('abort', () => {
            URL.revokeObjectURL(workerScriptUrl);
            reject("匯出被中止");
        });
        gif.render();
    });
};


==============================
File Path: lib\gifWorkerSource.ts
==============================

export const GIF_WORKER_SOURCE = `// gif.worker.js 0.2.0 - https://github.com/jnordberg/gif.js
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){var NeuQuant=require("./TypedNeuQuant.js");var LZWEncoder=require("./LZWEncoder.js");function ByteArray(){this.page=-1;this.pages=[];this.newPage()}ByteArray.pageSize=4096;ByteArray.charMap={};for(var i=0;i<256;i++)ByteArray.charMap[i]=String.fromCharCode(i);ByteArray.prototype.newPage=function(){this.pages[++this.page]=new Uint8Array(ByteArray.pageSize);this.cursor=0};ByteArray.prototype.getData=function(){var rv="";for(var p=0;p<this.pages.length;p++){for(var i=0;i<ByteArray.pageSize;i++){rv+=ByteArray.charMap[this.pages[p][i]]}}return rv};ByteArray.prototype.writeByte=function(val){if(this.cursor>=ByteArray.pageSize)this.newPage();this.pages[this.page][this.cursor++]=val};ByteArray.prototype.writeUTFBytes=function(string){for(var l=string.length,i=0;i<l;i++)this.writeByte(string.charCodeAt(i))};ByteArray.prototype.writeBytes=function(array,offset,length){for(var l=length||array.length,i=offset||0;i<l;i++)this.writeByte(array[i])};function GIFEncoder(width,height){this.width=~~width;this.height=~~height;this.transparent=null;this.transIndex=0;this.repeat=-1;this.delay=0;this.image=null;this.pixels=null;this.indexedPixels=null;this.colorDepth=null;this.colorTab=null;this.neuQuant=null;this.usedEntry=new Array;this.palSize=7;this.dispose=-1;this.firstFrame=true;this.sample=10;this.dither=false;this.globalPalette=false;this.out=new ByteArray}GIFEncoder.prototype.setDelay=function(milliseconds){this.delay=Math.round(milliseconds/10)};GIFEncoder.prototype.setFrameRate=function(fps){this.delay=Math.round(100/fps)};GIFEncoder.prototype.setDispose=function(disposalCode){if(disposalCode>=0)this.dispose=disposalCode};GIFEncoder.prototype.setRepeat=function(repeat){this.repeat=repeat};GIFEncoder.prototype.setTransparent=function(color){this.transparent=color};GIFEncoder.prototype.addFrame=function(imageData){this.image=imageData;this.colorTab=this.globalPalette&&this.globalPalette.slice?this.globalPalette:null;this.getImagePixels();this.analyzePixels();if(this.globalPalette===true)this.globalPalette=this.colorTab;if(this.firstFrame){this.writeLSD();this.writePalette();if(this.repeat>=0){this.writeNetscapeExt()}}this.writeGraphicCtrlExt();this.writeImageDesc();if(!this.firstFrame&&!this.globalPalette)this.writePalette();this.writePixels();this.firstFrame=false};GIFEncoder.prototype.finish=function(){this.out.writeByte(59)};GIFEncoder.prototype.setQuality=function(quality){if(quality<1)quality=1;this.sample=quality};GIFEncoder.prototype.setDither=function(dither){if(dither===true)dither="FloydSteinberg";this.dither=dither};GIFEncoder.prototype.setGlobalPalette=function(palette){this.globalPalette=palette};GIFEncoder.prototype.getGlobalPalette=function(){return this.globalPalette&&this.globalPalette.slice&&this.globalPalette.slice(0)||this.globalPalette};GIFEncoder.prototype.writeHeader=function(){this.out.writeUTFBytes("GIF89a")};GIFEncoder.prototype.analyzePixels=function(){if(!this.colorTab){this.neuQuant=new NeuQuant(this.pixels,this.sample);this.neuQuant.buildColormap();this.colorTab=this.neuQuant.getColormap()}if(this.dither){this.ditherPixels(this.dither.replace("-serpentine",""),this.dither.match(/-serpentine/)!==null)}else{this.indexPixels()}this.pixels=null;this.colorDepth=8;this.palSize=7;if(this.transparent!==null){this.transIndex=this.findClosest(this.transparent,true)}};GIFEncoder.prototype.indexPixels=function(imgq){var nPix=this.pixels.length/3;this.indexedPixels=new Uint8Array(nPix);var k=0;for(var j=0;j<nPix;j++){var index=this.findClosestRGB(this.pixels[k++]&255,this.pixels[k++]&255,this.pixels[k++]&255);this.usedEntry[index]=true;this.indexedPixels[j]=index}};GIFEncoder.prototype.ditherPixels=function(kernel,serpentine){var kernels={FalseFloydSteinberg:[[3/8,1,0],[3/8,0,1],[2/8,1,1]],FloydSteinberg:[[7/16,1,0],[3/16,-1,1],[5/16,0,1],[1/16,1,1]],Stucki:[[8/42,1,0],[4/42,2,0],[2/42,-2,1],[4/42,-1,1],[8/42,0,1],[4/42,1,1],[2/42,2,1],[1/42,-2,2],[2/42,-1,2],[4/42,0,2],[2/42,1,2],[1/42,2,2]],Atkinson:[[1/8,1,0],[1/8,2,0],[1/8,-1,1],[1/8,0,1],[1/8,1,1],[1/8,0,2]]};if(!kernel||!kernels[kernel]){throw"Unknown dithering kernel: "+kernel}var ds=kernels[kernel];var index=0,height=this.height,width=this.width,data=this.pixels;var direction=serpentine?-1:1;this.indexedPixels=new Uint8Array(this.pixels.length/3);for(var y=0;y<height;y++){if(serpentine)direction=direction*-1;for(var x=direction==1?0:width-1,xend=direction==1?width:0;x!==xend;x+=direction){index=y*width+x;var idx=index*3;var r1=data[idx];var g1=data[idx+1];var b1=data[idx+2];idx=this.findClosestRGB(r1,g1,b1);this.usedEntry[idx]=true;this.indexedPixels[index]=idx;idx*=3;var r2=this.colorTab[idx];var g2=this.colorTab[idx+1];var b2=this.colorTab[idx+2];var er=r1-r2;var eg=g1-g2;var eb=b1-b2;for(var i=direction==1?0:ds.length-1,end=direction==1?ds.length:0;i!==end;i+=direction){var x1=ds[i][1];var y1=ds[i][2];if(x1+x>=0&&x1+x<width&&y1+y>=0&&y1+y<height){var d=ds[i][0];idx=index+x1+y1*width;idx*=3;data[idx]=Math.max(0,Math.min(255,data[idx]+er*d));data[idx+1]=Math.max(0,Math.min(255,data[idx+1]+eg*d));data[idx+2]=Math.max(0,Math.min(255,data[idx+2]+eb*d))}}}}};GIFEncoder.prototype.findClosest=function(c,used){return this.findClosestRGB((c&16711680)>>16,(c&65280)>>8,c&255,used)};GIFEncoder.prototype.findClosestRGB=function(r,g,b,used){if(this.colorTab===null)return-1;if(this.neuQuant&&!used){return this.neuQuant.lookupRGB(r,g,b)}var c=b|g<<8|r<<16;var minpos=0;var dmin=256*256*256;var len=this.colorTab.length;for(var i=0,index=0;i<len;index++){var dr=r-(this.colorTab[i++]&255);var dg=g-(this.colorTab[i++]&255);var db=b-(this.colorTab[i++]&255);var d=dr*dr+dg*dg+db*db;if((!used||this.usedEntry[index])&&d<dmin){dmin=d;minpos=index}}return minpos};GIFEncoder.prototype.getImagePixels=function(){var w=this.width;var h=this.height;this.pixels=new Uint8Array(w*h*3);var data=this.image;var srcPos=0;var count=0;for(var i=0;i<h;i++){for(var j=0;j<w;j++){this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];this.pixels[count++]=data[srcPos++];srcPos++}}};GIFEncoder.prototype.writeGraphicCtrlExt=function(){this.out.writeByte(33);this.out.writeByte(249);this.out.writeByte(4);var transp,disp;if(this.transparent===null){transp=0;disp=0}else{transp=1;disp=2}if(this.dispose>=0){disp=dispose&7}disp<<=2;this.out.writeByte(0|disp|0|transp);this.writeShort(this.delay);this.out.writeByte(this.transIndex);this.out.writeByte(0)};GIFEncoder.prototype.writeImageDesc=function(){this.out.writeByte(44);this.writeShort(0);this.writeShort(0);this.writeShort(this.width);this.writeShort(this.height);if(this.firstFrame||this.globalPalette){this.out.writeByte(0)}else{this.out.writeByte(128|0|0|0|this.palSize)}};GIFEncoder.prototype.writeLSD=function(){this.writeShort(this.width);this.writeShort(this.height);this.out.writeByte(128|112|0|this.palSize);this.out.writeByte(0);this.out.writeByte(0)};GIFEncoder.prototype.writeNetscapeExt=function(){this.out.writeByte(33);this.out.writeByte(255);this.out.writeByte(11);this.out.writeUTFBytes("NETSCAPE2.0");this.out.writeByte(3);this.out.writeByte(1);this.writeShort(this.repeat);this.out.writeByte(0)};GIFEncoder.prototype.writePalette=function(){this.out.writeBytes(this.colorTab);var n=3*256-this.colorTab.length;for(var i=0;i<n;i++)this.out.writeByte(0)};GIFEncoder.prototype.writeShort=function(pValue){this.out.writeByte(pValue&255);this.out.writeByte(pValue>>8&255)};GIFEncoder.prototype.writePixels=function(){var enc=new LZWEncoder(this.width,this.height,this.indexedPixels,this.colorDepth);enc.encode(this.out)};GIFEncoder.prototype.stream=function(){return this.out};module.exports=GIFEncoder},{"./LZWEncoder.js":2,"./TypedNeuQuant.js":3}],2:[function(require,module,exports){var EOF=-1;var BITS=12;var HSIZE=5003;var masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535];function LZWEncoder(width,height,pixels,colorDepth){var initCodeSize=Math.max(2,colorDepth);var accum=new Uint8Array(256);var htab=new Int32Array(HSIZE);var codetab=new Int32Array(HSIZE);var cur_accum,cur_bits=0;var a_count;var free_ent=0;var maxcode;var clear_flg=false;var g_init_bits,ClearCode,EOFCode;function char_out(c,outs){accum[a_count++]=c;if(a_count>=254)flush_char(outs)}function cl_block(outs){cl_hash(HSIZE);free_ent=ClearCode+2;clear_flg=true;output(ClearCode,outs)}function cl_hash(hsize){for(var i=0;i<hsize;++i)htab[i]=-1}function compress(init_bits,outs){var fcode,c,i,ent,disp,hsize_reg,hshift;g_init_bits=init_bits;clear_flg=false;n_bits=g_init_bits;maxcode=MAXCODE(n_bits);ClearCode=1<<init_bits-1;EOFCode=ClearCode+1;free_ent=ClearCode+2;a_count=0;ent=nextPixel();hshift=0;for(fcode=HSIZE;fcode<65536;fcode*=2)++hshift;hshift=8-hshift;hsize_reg=HSIZE;cl_hash(hsize_reg);output(ClearCode,outs);outer_loop:while((c=nextPixel())!=EOF){fcode=(c<<BITS)+ent;i=c<<hshift^ent;if(htab[i]===fcode){ent=codetab[i];continue}else if(htab[i]>=0){disp=hsize_reg-i;if(i===0)disp=1;do{if((i-=disp)<0)i+=hsize_reg;if(htab[i]===fcode){ent=codetab[i];continue outer_loop}}while(htab[i]>=0)}output(ent,outs);ent=c;if(free_ent<1<<BITS){codetab[i]=free_ent++;htab[i]=fcode}else{cl_block(outs)}}output(ent,outs);output(EOFCode,outs)}function encode(outs){outs.writeByte(initCodeSize);remaining=width*height;curPixel=0;compress(initCodeSize+1,outs);outs.writeByte(0)}function flush_char(outs){if(a_count>0){outs.writeByte(a_count);outs.writeBytes(accum,0,a_count);a_count=0}}function MAXCODE(n_bits){return(1<<n_bits)-1}function nextPixel(){if(remaining===0)return EOF;--remaining;var pix=pixels[curPixel++];return pix&255}function output(code,outs){cur_accum&=masks[cur_bits];if(cur_bits>0)cur_accum|=code<<cur_bits;else cur_accum=code;cur_bits+=n_bits;while(cur_bits>=8){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}if(free_ent>maxcode||clear_flg){if(clear_flg){maxcode=MAXCODE(n_bits=g_init_bits);clear_flg=false}else{++n_bits;if(n_bits==BITS)maxcode=1<<BITS;else maxcode=MAXCODE(n_bits)}}if(code==EOFCode){while(cur_bits>0){char_out(cur_accum&255,outs);cur_accum>>=8;cur_bits-=8}flush_char(outs)}}this.encode=encode}module.exports=LZWEncoder},{}],3:[function(require,module,exports){var ncycles=100;var netsize=256;var maxnetpos=netsize-1;var netbiasshift=4;var intbiasshift=16;var intbias=1<<intbiasshift;var gammashift=10;var gamma=1<<gammashift;var betashift=10;var beta=intbias>>betashift;var betagamma=intbias<<gammashift-betashift;var initrad=netsize>>3;var radiusbiasshift=6;var radiusbias=1<<radiusbiasshift;var initradius=initrad*radiusbias;var radiusdec=30;var alphabiasshift=10;var initalpha=1<<alphabiasshift;var alphadec;var radbiasshift=8;var radbias=1<<radbiasshift;var alpharadbshift=alphabiasshift+radbiasshift;var alpharadbias=1<<alpharadbshift;var prime1=499;var prime2=491;var prime3=487;var prime4=503;var minpicturebytes=3*prime4;function NeuQuant(pixels,samplefac){var network;var netindex;var bias;var freq;var radpower;function init(){network=[];netindex=new Int32Array(256);bias=new Int32Array(netsize);freq=new Int32Array(netsize);radpower=new Int32Array(netsize>>3);var i,v;for(i=0;i<netsize;i++){v=(i<<netbiasshift+8)/netsize;network[i]=new Float64Array([v,v,v,0]);freq[i]=intbias/netsize;bias[i]=0}}function unbiasnet(){for(var i=0;i<netsize;i++){network[i][0]>>=netbiasshift;network[i][1]>>=netbiasshift;network[i][2]>>=netbiasshift;network[i][3]=i}}function altersingle(alpha,i,b,g,r){network[i][0]-=alpha*(network[i][0]-b)/initalpha;network[i][1]-=alpha*(network[i][1]-g)/initalpha;network[i][2]-=alpha*(network[i][2]-r)/initalpha}function alterneigh(radius,i,b,g,r){var lo=Math.abs(i-radius);var hi=Math.min(i+radius,netsize);var j=i+1;var k=i-1;var m=1;var p,a;while(j<hi||k>lo){a=radpower[m++];if(j<hi){p=network[j++];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}if(k>lo){p=network[k--];p[0]-=a*(p[0]-b)/alpharadbias;p[1]-=a*(p[1]-g)/alpharadbias;p[2]-=a*(p[2]-r)/alpharadbias}}}function contest(b,g,r){var bestd=~(1<<31);var bestbiasd=bestd;var bestpos=-1;var bestbiaspos=bestpos;var i,n,dist,biasdist,betafreq;for(i=0;i<netsize;i++){n=network[i];dist=Math.abs(n[0]-b)+Math.abs(n[1]-g)+Math.abs(n[2]-r);if(dist<bestd){bestd=dist;bestpos=i}biasdist=dist-(bias[i]>>intbiasshift-netbiasshift);if(biasdist<bestbiasd){bestbiasd=biasdist;bestbiaspos=i}betafreq=freq[i]>>betashift;freq[i]-=betafreq;bias[i]+=betafreq<<gammashift}freq[bestpos]+=beta;bias[bestpos]-=betagamma;return bestbiaspos}function inxbuild(){var i,j,p,q,smallpos,smallval,previouscol=0,startpos=0;for(i=0;i<netsize;i++){p=network[i];smallpos=i;smallval=p[1];for(j=i+1;j<netsize;j++){q=network[j];if(q[1]<smallval){smallpos=j;smallval=q[1]}}q=network[smallpos];if(i!=smallpos){j=q[0];q[0]=p[0];p[0]=j;j=q[1];q[1]=p[1];p[1]=j;j=q[2];q[2]=p[2];p[2]=j;j=q[3];q[3]=p[3];p[3]=j}if(smallval!=previouscol){netindex[previouscol]=startpos+i>>1;for(j=previouscol+1;j<smallval;j++)netindex[j]=i;previouscol=smallval;startpos=i}}netindex[previouscol]=startpos+maxnetpos>>1;for(j=previouscol+1;j<256;j++)netindex[j]=maxnetpos}function inxsearch(b,g,r){var a,p,dist;var bestd=1e3;var best=-1;var i=netindex[g];var j=i-1;while(i<netsize||j>=0){if(i<netsize){p=network[i];dist=p[1]-g;if(dist>=bestd)i=netsize;else{i++;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}if(j>=0){p=network[j];dist=g-p[1];if(dist>=bestd)j=-1;else{j--;if(dist<0)dist=-dist;a=p[0]-b;if(a<0)a=-a;dist+=a;if(dist<bestd){a=p[2]-r;if(a<0)a=-a;dist+=a;if(dist<bestd){bestd=dist;best=p[3]}}}}}return best}function learn(){var i;var lengthcount=pixels.length;var alphadec=30+(samplefac-1)/3;var samplepixels=lengthcount/(3*samplefac);var delta=~~(samplepixels/ncycles);var alpha=initalpha;var radius=initradius;var rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(i=0;i<rad;i++)radpower[i]=alpha*((rad*rad-i*i)*radbias/(rad*rad));var step;if(lengthcount<minpicturebytes){samplefac=1;step=3}else if(lengthcount%prime1!==0){step=3*prime1}else if(lengthcount%prime2!==0){step=3*prime2}else if(lengthcount%prime3!==0){step=3*prime3}else{step=3*prime4}var b,g,r,j;var pix=0;i=0;while(i<samplepixels){b=(pixels[pix]&255)<<netbiasshift;g=(pixels[pix+1]&255)<<netbiasshift;r=(pixels[pix+2]&255)<<netbiasshift;j=contest(b,g,r);altersingle(alpha,j,b,g,r);if(rad!==0)alterneigh(rad,j,b,g,r);pix+=step;if(pix>=lengthcount)pix-=lengthcount;i++;if(delta===0)delta=1;if(i%delta===0){alpha-=alpha/alphadec;radius-=radius/radiusdec;rad=radius>>radiusbiasshift;if(rad<=1)rad=0;for(j=0;j<rad;j++)radpower[j]=alpha*((rad*rad-j*j)*radbias/(rad*rad))}}}function buildColormap(){init();learn();unbiasnet();inxbuild()}this.buildColormap=buildColormap;function getColormap(){var map=[];var index=[];for(var i=0;i<netsize;i++)index[network[i][3]]=i;var k=0;for(var l=0;l<netsize;l++){var j=index[l];map[k++]=network[j][0];map[k++]=network[j][1];map[k++]=network[j][2]}return map}this.getColormap=getColormap;this.lookupRGB=inxsearch}module.exports=NeuQuant},{}],4:[function(require,module,exports){var GIFEncoder,renderFrame;GIFEncoder=require("./GIFEncoder.js");renderFrame=function(frame){var encoder,page,stream,transfer;encoder=new GIFEncoder(frame.width,frame.height);if(frame.index===0){encoder.writeHeader()}else{encoder.firstFrame=false}encoder.setTransparent(frame.transparent);encoder.setRepeat(frame.repeat);encoder.setDelay(frame.delay);encoder.setQuality(frame.quality);encoder.setDither(frame.dither);encoder.setGlobalPalette(frame.globalPalette);encoder.addFrame(frame.data);if(frame.last){encoder.finish()}if(frame.globalPalette===true){frame.globalPalette=encoder.getGlobalPalette()}stream=encoder.stream();frame.data=stream.pages;frame.cursor=stream.cursor;frame.pageSize=stream.constructor.pageSize;if(frame.canTransfer){transfer=function(){var i,len,ref,results;ref=frame.data;results=[];for(i=0,len=ref.length;i<len;i++){page=ref[i];results.push(page.buffer)}return results}();return self.postMessage(frame,transfer)}else{return self.postMessage(frame)}};self.onmessage=function(event){return renderFrame(event.data)}},{"./GIFEncoder.js":1}]},{},[4]);
//# sourceMappingURL=gif.worker.js.map
`;


==============================
File Path: lib\importer.ts
==============================

import { MoveNode, Piece, PieceColor, Point } from '../types';
import { getFen, fenToBoard, getChineseNotation } from './utils';
import { PIECES } from '../constants';

const CN_NUMS: Record<string, number> = {
    "一": 1, "二": 2, "三": 3, "四": 4, "五": 5, "六": 6, "七": 7, "八": 8, "九": 9,
    "１": 1, "２": 2, "３": 3, "４": 4, "５": 5, "６": 6, "７": 7, "８": 8, "９": 9,
    "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, "０": 0, "0": 0
};

interface ParsedGame {
    fen: string;
    moves: { moveStr: string; notation: string; comment?: string }[];
    header: Record<string, string>;
    root?: MoveNode;
}

interface SkeletonNode {
    id: string;
    moveStr: string;
    stepIndex: number;
    ownerId: number;
    comment: string;
    children: SkeletonNode[];
    parentId: string | null;
}

export const Importer = {
    parseInput(text: string): ParsedGame {
        if (text.includes('[DhtmlXQ')) {
            return this.parseDhtmlXQ(text);
        } else {
            return this.parseTextNotation(text);
        }
    },

    normalizeText(text: string): string {
        let out = text.replace(/[０-９１-９]/g, (m) => {
            const code = m.charCodeAt(0);
            if (code >= 65296 && code <= 65305) return String.fromCharCode(code - 65248);
            if (code >= 65313 && code <= 65321) return String.fromCharCode(code - 65248);
            return m;
        });

        out = out.replace(/[－—–]/g, '-');
        out = out.replace(/[，；：　]/g, ' ');
        out = out.replace(/↔/g, '-');
        out = out.replace(/进/g, '進');
        out = out.replace(/后/g, '後');
        out = out.replace(/马/g, '馬');
        out = out.replace(/车/g, '車');
        out = out.replace(/炮/g, '炮');
        out = out.replace(/\d+\.\s*/g, ' ');
        out = out.replace(/第[一二三四五六七八九十\d]+步[：:]/g, ' ');
        out = out.replace(/[，,。.、；;：:]/g, ' ');

        return out;
    },

    extractTextMetadata(text: string): Record<string, string> {
        const header: Record<string, string> = { Title: "", Event: "", Date: "", Red: "", Black: "", Result: "" };

        const extract = (patterns: RegExp[]) => {
            for (const pattern of patterns) {
                const match = text.match(pattern);
                if (match && match[1]) return match[1].trim();
            }
            return "";
        };

        header.Title = extract([/[棋局标標題题]+[：:]\s*(.+?)(?:\r?\n|$)/, /对局名称[：:]\s*(.+?)(?:\r?\n|$)/, /\[Game\s+"(.+?)"\]/i]);
        header.Event = extract([/赛事[名称稱]*[：:]\s*(.+?)(?:\r?\n|$)/, /賽事[名称稱]*[：:]\s*(.+?)(?:\r?\n|$)/, /\[Event\s+"(.+?)"\]/i]);
        header.Date = extract([/日期[：:]\s*(.+?)(?:\r?\n|$)/, /\[Date\s+"(.+?)"\]/i, /(\d{4}[.\-\/年]\d{1,2}[.\-\/月]\d{1,2})/]);
        header.Red = extract([/红方[名称稱]*[：:]\s*(.+?)(?:\r?\n|$)/, /紅方[名称稱]*[：:]\s*(.+?)(?:\r?\n|$)/, /\[Red\s+"(.+?)"\]/i]);
        header.Black = extract([/黑方[名称稱]*[：:]\s*(.+?)(?:\r?\n|$)/, /\[Black\s+"(.+?)"\]/i]);
        const resultRaw = extract([/[对對]局[结結]果[：:]\s*(.+?)(?:\r?\n|$)/, /結果[：:]\s*(.+?)(?:\r?\n|$)/, /\[Result\s+"(.+?)"\]/i]);

        if (resultRaw) {
            if (/红胜|紅勝|先[胜勝]|1-0/.test(resultRaw)) header.Result = "紅勝";
            else if (/黑胜|黑勝|先[负負]|后[胜勝]|0-1/.test(resultRaw)) header.Result = "黑勝";
            else if (/和|平|1\/2/.test(resultRaw)) header.Result = "和局";
            else header.Result = resultRaw;
        }

        return header;
    },

    parseTextNotation(text: string): ParsedGame {
        let fen = "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1";

        const header = this.extractTextMetadata(text);

        const fenMatch = text.match(/\[FEN\s+"([^"]+)"\]/i) || text.match(/[Ff][Ee][Nn][串：:\s]+([rnbakabnrcpRNBAKABNRCP1-9\/]+ [wb])/);
        if (fenMatch) {
            if (text.includes('[')) fen = fenMatch[1];
            else fen = fenMatch[1] + " - - 0 1";
        }

        let body = text.replace(/\[[^\]]+\]/g, " ");
        const comments: string[] = [];
        body = body.replace(/\{([\s\S]*?)\}/g, (m, p1) => {
            if (m.startsWith('{#')) return m;
            comments.push(p1.trim());
            return ` __COMMENT_${comments.length - 1}__ `;
        });
        body = body.replace(/\{#([\s\S]*?)#\}/g, (m, p1) => {
            comments.push(p1.trim());
            return ` __COMMENT_${comments.length - 1}__ `;
        });

        const normalizedBody = this.normalizeText(body);
        // Updated Regex: Supports "前马退4" (Pos+Piece), "兵前进1" (Piece+Pos), "炮二平五" (Piece+Col)
        const moveRegex = /([a-i][0-9]-?[a-i][0-9]|[RCNHPKAB][1-9][+.-][1-9]|(?:[\u4e00-\u9fa5]{2}|[\u4e00-\u9fa5][0-9])[進进退平][0-9一二三四五六七八九]|__COMMENT_\d+__)/gi;
        const rawTokens = normalizedBody.match(moveRegex) || [];

        const moves: { moveStr: string; notation: string; comment?: string }[] = [];
        let { board: currentBoard, turn: currentTurn } = fenToBoard(fen);
        let currentMoveObj: any = null;

        for (let token of rawTokens) {
            if (token.startsWith("__COMMENT_")) {
                if (currentMoveObj) {
                    const idx = parseInt(token.match(/\d+/)![0]);
                    currentMoveObj.comment = (currentMoveObj.comment || "") + (currentMoveObj.comment ? " " : "") + comments[idx];
                }
                continue;
            }

            let moveStr: string | null = null;
            const tokenLower = token.toLowerCase();
            if (/^[a-i][0-9]/.test(tokenLower)) {
                moveStr = this.iccsToMoveStr(token);
            } else if (/^[RCNHPKAB]/i.test(token)) {
                moveStr = this.parseWXFMove(token, currentBoard, currentTurn);
            } else if (/[\u4e00-\u9fa5]/.test(token)) {
                moveStr = this.parseChineseMove(token, currentBoard, currentTurn);
            }

            if (moveStr) {
                const [src, dst] = moveStr.split('-').map(Number);
                const r1 = Math.floor(src / 9), c1 = src % 9;
                const r2 = Math.floor(dst / 9), c2 = dst % 9;

                const piece = currentBoard[r1][c1];
                if (piece) {
                    let finalNotation = token;
                    if (!/[\u4e00-\u9fa5]/.test(token)) {
                        finalNotation = getChineseNotation(currentBoard, {
                            from: { r: r1, c: c1 },
                            to: { r: r2, c: c2 },
                            piece,
                            captured: currentBoard[r2][c2]
                        });
                    }

                    currentMoveObj = { moveStr, notation: finalNotation };
                    moves.push(currentMoveObj);

                    const newBoard = currentBoard.map(row => [...row]);
                    newBoard[r2][c2] = piece;
                    newBoard[r1][c1] = null;
                    currentBoard = newBoard;
                    currentTurn = currentTurn === 'red' ? 'black' : 'red';
                }
            }
        }

        return { fen, moves, header };
    },

    parseChineseMove(text: string, board: (Piece | null)[][], turn: PieceColor): string | null {
        if (text.length < 3) return null;
        const isRed = turn === 'red';
        
        let name = text[0];
        let srcColChar = text[1];
        let dir = text[2];
        let destChar = text[3];

        // Handle "前马...", "中炮...", "后车..." (Position indicator at start)
        // Check text[0] for Position markers
        if (["前", "后", "後", "中"].includes(text[0])) {
            const pos = text[0];
            name = text[1]; // The piece name is the second char
            srcColChar = pos; // Use the position marker as the "Source Column" logic identifier
            dir = text[2];
            destChar = text[3];
        }

        let candidates: { r: number, c: number }[] = [];
        for (let r = 0; r < 10; r++) {
            for (let c = 0; c < 9; c++) {
                const p = board[r][c];
                if (p && p.color === turn && this.matchPieceName(p.text, name)) {
                    candidates.push({ r, c });
                }
            }
        }

        if (["前", "后", "後", "中"].includes(srcColChar)) {
            const colGroups: Record<number, { r: number, c: number }[]> = {};
            candidates.forEach(cand => {
                if (!colGroups[cand.c]) colGroups[cand.c] = [];
                colGroups[cand.c].push(cand);
            });

            let bestCol = -1;
            for (const c in colGroups) {
                if (colGroups[c].length > 1) {
                    colGroups[c].sort((a, b) => a.r - b.r);
                    let picked = null;
                    if (isRed) {
                        if (srcColChar === "前") picked = colGroups[c][0];
                        if (srcColChar === "后" || srcColChar === "後") picked = colGroups[c][colGroups[c].length - 1];
                        if (srcColChar === "中") picked = colGroups[c][1];
                    } else {
                        if (srcColChar === "前") picked = colGroups[c][colGroups[c].length - 1];
                        if (srcColChar === "后" || srcColChar === "後") picked = colGroups[c][0];
                        if (srcColChar === "中") picked = colGroups[c][1];
                    }
                    if (picked) {
                        candidates = [picked];
                        bestCol = parseInt(c);
                        break;
                    }
                }
            }
            if (bestCol === -1) return null;
        } else {
            const colNum = CN_NUMS[srcColChar];
            if (colNum !== undefined) {
                const targetX1 = isRed ? (9 - colNum) : (colNum - 1);
                candidates = candidates.filter(cand => cand.c === targetX1);
            } else {
                return null;
            }
        }

        if (candidates.length === 0) return null;
        candidates.sort((a, b) => isRed ? (a.r - b.r) : (b.r - a.r));
        const from = candidates[0];

        const destNum = CN_NUMS[destChar];
        if (destNum === undefined) return null;

        let toR = from.r;
        let toC = from.c;
        const pName = board[from.r][from.c]?.text || '';
        const isLinear = ['車', '俥', '炮', '砲', '兵', '卒', '將', '帥', '帥', '将'].some(x => this.matchPieceName(x, pName));

        if (dir === "平") {
            toC = isRed ? (9 - destNum) : (destNum - 1);
        } else {
            const isForward = (dir === "進" || dir === "进");
            const moveSign = isRed ? (isForward ? -1 : 1) : (isForward ? 1 : -1);
            if (isLinear) {
                toR = from.r + (destNum * moveSign);
            } else {
                toC = isRed ? (9 - destNum) : (destNum - 1);
                const dc = Math.abs(toC - from.c);
                let dr = 0;
                if (this.matchPieceName('馬', pName)) dr = (dc === 2) ? 1 : 2;
                else if (this.matchPieceName('相', pName)) dr = 2;
                else dr = 1;
                toR = from.r + (dr * moveSign);
            }
        }

        if (toR < 0 || toR > 9 || toC < 0 || toC > 8) return null;
        return `${from.r * 9 + from.c}-${toR * 9 + toC}`;
    },

    parseWXFMove(wxf: string, board: (Piece | null)[][], turn: PieceColor): string | null {
        const pieceChar = wxf[0].toUpperCase();
        const col = parseInt(wxf[1]);
        const dir = wxf[2];
        const dest = parseInt(wxf[3]);
        const map: Record<string, string> = { 'R': '車', 'C': '炮', 'N': '馬', 'H': '馬', 'P': '兵', 'K': '將', 'A': '士', 'B': '相', 'E': '相', 'S': '兵' };
        const cnPiece = map[pieceChar];
        if (!cnPiece) return null;
        const cnDir = dir === '+' ? '進' : (dir === '-' ? '退' : '平');
        const cnCol = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'][col];
        const cnDest = dir === '.' ? ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'][dest] : dest.toString();
        return this.parseChineseMove(`${cnPiece}${cnCol}${cnDir}${cnDest}`, board, turn);
    },

    matchPieceName(actualName: string, queryName: string): boolean {
        const map: Record<string, string[]> = {
            '車': ['車', '俥', '车', 'R', 'r', '連'],
            '馬': ['馬', '傌', '马', 'N', 'n', 'H', 'h', '偶'],
            '炮': ['炮', '砲', '包', 'C', 'c'],
            '兵': ['兵', '卒', 'P', 'p'],
            '卒': ['兵', '卒', 'P', 'p'],
            '相': ['相', '象', 'B', 'b', 'E', 'e'],
            '象': ['相', '象', 'B', 'b', 'E', 'e'],
            '士': ['仕', '士', 'A', 'a'],
            '仕': ['仕', '士', 'A', 'a'],
            '將': ['將', '帥', '将', '帅', 'K', 'k'],
            '帥': ['將', '帥', '将', '帅', 'K', 'k']
        };
        let standardKey = '';
        for (const k in map) {
            if (map[k].includes(actualName) || k === actualName) {
                standardKey = k;
                break;
            }
        }
        if (!standardKey) return actualName === queryName;
        return map[standardKey].includes(queryName) || standardKey === queryName;
    },

    iccsToMoveStr(iccs: string): string {
        const matches = iccs.match(/([a-i])([0-9]).*([a-i])([0-9])/i);
        if (!matches) return "";
        const c1 = matches[1].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
        const r1 = 9 - parseInt(matches[2]);
        const c2 = matches[3].toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
        const r2 = 9 - parseInt(matches[4]);
        return `${r1 * 9 + c1}-${r2 * 9 + c2}`;
    },

    parseDhtmlXQ(text: string): ParsedGame {
        const getTag = (tag: string) => {
            const regex = new RegExp(`\\[${tag}\\]([\\s\\S]*?)\\[\\/${tag}\\]`, 'i');
            const m = text.match(regex);
            return m ? m[1].trim() : "";
        };

        const header: Record<string, string> = {
            Title: getTag('DhtmlXQ_title'),
            Event: getTag('DhtmlXQ_event'),
            Date: getTag('DhtmlXQ_date'),
            Red: getTag('DhtmlXQ_red'),
            Black: getTag('DhtmlXQ_black'),
            Result: getTag('DhtmlXQ_result')
        };

        const moveListTag = /\[DhtmlXQ_movelist\]([\d\s]+)\[\/DhtmlXQ_movelist\]/.exec(text);
        const firstMoveStr = moveListTag ? moveListTag[1].replace(/\s/g, "").substring(0, 4) : null;
        let isRedTop = false;
        if (firstMoveStr && firstMoveStr.length === 4) {
            if (parseInt(firstMoveStr[1]) > 4) isRedTop = true;
        }

        let fen = getTag('DhtmlXQ_fen');
        if (!fen) {
            const binit = getTag('DhtmlXQ_binit');
            fen = binit ? this.convertBinitToFen(binit, isRedTop) : "rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1";
        }

        const rootSkeleton: SkeletonNode = { id: 'root', moveStr: "", stepIndex: 0, ownerId: 0, children: [], comment: "", parentId: null };
        const multiNodeMap = new Map<number, SkeletonNode[]>();
        multiNodeMap.set(0, [rootSkeleton]);

        const parseLine = (str: string, parentNode: SkeletonNode, startStep: number, ownerId: number) => {
            str = str.replace(/[^\d]/g, "").split("||")[0];
            let curr = parentNode;
            let s = startStep;
            for (let i = 0; i < str.length; i += 4) {
                s++;
                const move = str.substring(i, i + 4);
                if (move.length < 4) break;
                const node: SkeletonNode = {
                    id: Math.random().toString(36).substring(2, 9),
                    moveStr: move, stepIndex: s, ownerId: ownerId, children: [], comment: "", parentId: curr.id
                };
                curr.children.push(node);
                curr = node;
                if (!multiNodeMap.has(s)) multiNodeMap.set(s, []);
                multiNodeMap.get(s)!.push(node);
            }
        };

        if (moveListTag) parseLine(moveListTag[1], rootSkeleton, 0, 0);

        const varRegex = /\[DhtmlXQ_move_(\d+)_(\d+)_(\d+)\]([\s\S]*?)\[\/DhtmlXQ_move_\1_\2_\3\]/g;
        let m;
        while ((m = varRegex.exec(text)) !== null) {
            // Correct mapping: sourceId (parent branch) _ step _ targetId (new branch)
            const sourceId = parseInt(m[1]);
            const pId = parseInt(m[2]);
            const targetId = parseInt(m[3]);
            
            const pIdx = pId - 1;
            const content = m[4];
            const candidates = multiNodeMap.get(pIdx);
            
            if (candidates && candidates.length > 0) {
                // Find parent node that matches the sourceId
                let parent = candidates.find(n => n.ownerId === sourceId);
                // Fallback to last node if specific ID not found (though structure implies it should exist)
                if (!parent) parent = candidates[candidates.length - 1];
                
                if (parent) {
                    parseLine(content, parent, pIdx, targetId);
                }
            }
        }

        const commentRegex = /\[DhtmlXQ_comment(\d+)(?:_(\d+))?\]([\s\S]*?)\[\/DhtmlXQ_comment\1(?:_\2)?\]/g;
        while ((m = commentRegex.exec(text)) !== null) {
            const step = parseInt(m[2] || m[1]);
            const id = m[2] ? parseInt(m[1]) : 0;
            const nodes = multiNodeMap.get(step);
            if (nodes) {
                let target = nodes.find(n => n.ownerId === id);
                if (!target) target = nodes[0];
                if (target) target.comment = m[3].trim();
            }
        }

        const { board: startBoard, turn: startTurn } = fenToBoard(fen);
        const hydrate = (skel: SkeletonNode, pBoard: (Piece | null)[][], pTurn: PieceColor): MoveNode => {
            let moveObj = null;
            let newBoard = pBoard;
            let nextTurn = pTurn;
            let newFen = getFen(newBoard, nextTurn);
            if (skel.moveStr) {
                const c1 = parseInt(skel.moveStr[0]);
                const r1 = parseInt(skel.moveStr[1]);
                const c2 = parseInt(skel.moveStr[2]);
                const r2 = parseInt(skel.moveStr[3]);
                const from = { r: r1, c: c1 };
                const to = { r: r2, c: c2 };
                const piece = pBoard[r1][c1];
                const captured = pBoard[r2][c2];
                if (piece) {
                    const notation = getChineseNotation(pBoard, { from, to, piece, captured });
                    moveObj = { from, to, piece, captured, notation };
                    newBoard = pBoard.map(row => [...row]);
                    newBoard[r2][c2] = piece;
                    newBoard[r1][c1] = null;
                    nextTurn = pTurn === 'red' ? 'black' : 'red';
                    newFen = getFen(newBoard, nextTurn);
                }
            }
            const node: MoveNode = {
                id: skel.id, parentId: skel.parentId, move: moveObj,
                boardState: newBoard, children: [], comment: skel.comment,
                turn: nextTurn, fen: newFen, stepIndex: skel.stepIndex, ownerId: skel.ownerId
            };
            if (skel.children.length > 0) {
                node.children = skel.children.map(c => hydrate(c, newBoard, nextTurn));
                node.selectedChildId = node.children[0].id;
            }
            return node;
        };

        return { fen, moves: [], header, root: hydrate(rootSkeleton, startBoard, startTurn) };
    },

    convertBinitToFen(binitStr: string, isRedTop: boolean): string {
        if (!binitStr || binitStr.length !== 64) return "";
        const boardChars = new Array(90).fill(null);
        const redGroup = "RNBAKABNRCCPPPPP".split("");
        const blackGroup = "rnbakabnrccppppp".split("");
        const topGroup = isRedTop ? redGroup : blackGroup;
        const bottomGroup = isRedTop ? blackGroup : redGroup;

        for (let i = 0; i < 32; i++) {
            const x = parseInt(binitStr[i * 2]);
            const y = parseInt(binitStr[i * 2 + 1]);
            const idx = y * 9 + x;
            if (i < 16) boardChars[idx] = topGroup[i];
            else boardChars[idx] = bottomGroup[i - 16];
        }

        let out = "";
        for (let r = 0; r < 10; r++) {
            let empty = 0;
            for (let c = 0; c < 9; c++) {
                const char = boardChars[r * 9 + c];
                if (char) {
                    if (empty > 0) { out += empty; empty = 0; }
                    out += char;
                } else { empty++; }
            }
            if (empty > 0) out += empty;
            if (r < 9) out += "/";
        }
        return out + " w - - 0 1";
    }
};


==============================
File Path: lib\utils.ts
==============================

import { Piece, PieceColor, Point, CloudMove } from '../types';
import { PIECES } from '../constants';

/**
 * Generates a Xiangqi FEN string from the board state.
 */
export const getFen = (board: (Piece | null)[][], turn: PieceColor): string => {
    let fen = '';
    
    // 1. Board Layout
    for (let r = 0; r < 10; r++) {
        let emptyCount = 0;
        for (let c = 0; c < 9; c++) {
            const piece = board[r][c];
            if (piece) {
                if (emptyCount > 0) {
                    fen += emptyCount;
                    emptyCount = 0;
                }
                fen += getPieceChar(piece);
            } else {
                emptyCount++;
            }
        }
        if (emptyCount > 0) {
            fen += emptyCount;
        }
        if (r < 9) {
            fen += '/';
        }
    }

    // 2. Turn (w = Red, b = Black)
    fen += ` ${turn === 'red' ? 'w' : 'b'}`;

    // 3. Placeholders
    fen += ' - - 0 1'; 

    return fen;
};

const getPieceChar = (piece: Piece): string => {
    const map: Record<string, string> = {
        king: 'K',
        advisor: 'A',
        elephant: 'B',
        horse: 'N',
        chariot: 'R',
        cannon: 'C',
        soldier: 'P'
    };
    const char = map[piece.type] || 'P';
    return piece.color === 'red' ? char : char.toLowerCase();
};

export const fenToBoard = (fen: string): { board: (Piece | null)[][], turn: PieceColor } => {
    const board: (Piece | null)[][] = Array(10).fill(null).map(() => Array(9).fill(null));
    const parts = fen.split(' ');
    const position = parts[0];
    const turnChar = parts[1] || 'w';

    const rows = position.split('/');
    let r = 0;
    let c = 0;

    const charToPieceType: Record<string, { type: string, color: PieceColor, text: string }> = {
        'K': { type: 'king', color: 'red', text: PIECES.red.king },
        'A': { type: 'advisor', color: 'red', text: PIECES.red.advisor },
        'B': { type: 'elephant', color: 'red', text: PIECES.red.elephant },
        'N': { type: 'horse', color: 'red', text: PIECES.red.horse },
        'R': { type: 'chariot', color: 'red', text: PIECES.red.chariot },
        'C': { type: 'cannon', color: 'red', text: PIECES.red.cannon },
        'P': { type: 'soldier', color: 'red', text: PIECES.red.soldier },
        'k': { type: 'king', color: 'black', text: PIECES.black.king },
        'a': { type: 'advisor', color: 'black', text: PIECES.black.advisor },
        'b': { type: 'elephant', color: 'black', text: PIECES.black.elephant },
        'n': { type: 'horse', color: 'black', text: PIECES.black.horse },
        'r': { type: 'chariot', color: 'black', text: PIECES.black.chariot },
        'c': { type: 'cannon', color: 'black', text: PIECES.black.cannon },
        'p': { type: 'soldier', color: 'black', text: PIECES.black.soldier }
    };

    for (let i = 0; i < position.length; i++) {
        const char = position[i];
        if (char === '/') {
            r++;
            c = 0;
        } else if (/\d/.test(char)) {
            c += parseInt(char);
        } else {
            const def = charToPieceType[char];
            if (def && r < 10 && c < 9) {
                board[r][c] = { type: def.type as any, color: def.color, text: def.text };
                c++;
            }
        }
    }

    return { board, turn: turnChar === 'w' ? 'red' : 'black' };
};

export const validatePiecePlacement = (pieceType: string, color: PieceColor, r: number, c: number): boolean => {
    if (pieceType === 'king' || pieceType === 'advisor') {
        if (c < 3 || c > 5) return false;
        if (color === 'red') {
            return r >= 7 && r <= 9;
        } else {
            return r >= 0 && r <= 2;
        }
    }

    if (pieceType === 'elephant') {
        if (color === 'red') {
            return r >= 5;
        } else {
            return r <= 4;
        }
    }

    return true;
};

export const toChineseNum = (n: number) => ['零','一','二','三','四','五','六','七','八','九'][n];

export const getChineseNotation = (board: (Piece|null)[][], move: {from: Point, to: Point, piece: Piece, captured: Piece|null}): string => {
    const { from, to, piece } = move;
    const isRed = piece.color === 'red';
    const fromCol = isRed ? (9 - from.c) : (from.c + 1);
    const toCol = isRed ? (9 - to.c) : (to.c + 1);
    let name = piece.text;
    let dir = '';
    let dest = ''; 
    const dr = to.r - from.r;
    
    if (from.r === to.r) {
        dir = '平';
        dest = isRed ? toChineseNum(toCol) : toCol.toString();
    } else {
        const isForward = isRed ? (dr < 0) : (dr > 0);
        dir = isForward ? '進' : '退';
        const dist = Math.abs(dr);
        if (['horse', 'elephant', 'advisor'].includes(piece.type)) {
            dest = isRed ? toChineseNum(toCol) : toCol.toString();
        } else {
            dest = isRed ? toChineseNum(dist) : dist.toString();
        }
    }
    const colStr = isRed ? toChineseNum(fromCol) : fromCol.toString();
    return `${name}${colStr}${dir}${dest}`;
};

// --- Cloudbook Helpers ---

export const ucciToCoords = (ucci: string): { from: Point, to: Point } | null => {
    if (!ucci || ucci.length < 4) return null;
    const c1 = ucci.charCodeAt(0) - 'a'.charCodeAt(0);
    const r1 = 9 - parseInt(ucci[1]);
    const c2 = ucci.charCodeAt(2) - 'a'.charCodeAt(0);
    const r2 = 9 - parseInt(ucci[3]);
    return { from: { r: r1, c: c1 }, to: { r: r2, c: c2 } };
};

export const fetchCloudBookData = async (fen: string): Promise<CloudMove[]> => {
    try {
        const url = `https://www.chessdb.cn/chessdb.php?action=queryall&board=${encodeURIComponent(fen)}&learn=1&showall=1`;
        const response = await fetch(url);
        if (!response.ok) throw new Error('Network response was not ok');
        
        const text = await response.text();
        
        if (text.startsWith('unknown') || text.startsWith('invalid')) {
            return [];
        }

        const parsedMoves: CloudMove[] = text.split('|').map(item => {
            const parts = item.split(',');
            const obj: any = {};
            parts.forEach(p => {
                const [k, v] = p.split(':');
                if (k && v) obj[k.trim()] = v.trim();
            });
            
            return {
                move: obj.move,
                score: parseInt(obj.score || '0'),
                rank: parseInt(obj.rank || '0'),
                winrate: parseFloat(obj.winrate || '0'),
                note: obj.note || ''
            };
        }).filter(m => m.move);
        
        return parsedMoves;
    } catch (err) {
        console.error("Cloud fetch error:", err);
        return [];
    }
};


==============================
File Path: logic\exporter.ts
==============================
// This file is deprecated. Please import from 'lib/exporter' instead.
export {};

==============================
File Path: logic\importer.ts
==============================
// This file is deprecated. Please import from 'lib/importer' instead.
export {};

==============================
File Path: utils\common.ts
==============================
// This file is deprecated. Please import from 'lib/utils' instead.
export {};

==============================
File Path: utils\exporter.ts
==============================
// This file is deprecated. Please import from 'lib/exporter' instead.
export {};

==============================
File Path: utils\gifGenerator.ts
==============================
// This file is deprecated. Please import from 'lib/gifGenerator' instead.
export {};

==============================
File Path: utils\importer.ts
==============================
// This file is deprecated. Please import from 'lib/importer' instead.
export {};
